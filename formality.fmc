Bit : * = %Bit.Self(P:@(self:Bit) *) @(0:(P Bit.0)) @(1:(P Bit.1)) (P Bit.Self);
Bits : * = %Bits.Self(P:@(self:Bits) *) @(nil:(P Bits.nil)) @(0:@(pred:Bits) (P (Bits.0 pred))) @(1:@(pred:Bits) (P (Bits.1 pred))) (P Bits.Self);
Bits.add : @(a:Bits) @(b:Bits) Bits = #a #b ((((b #b.self Bits) a) #b.pred ((((a #a.self Bits) b) #a.pred (Bits.0 ((Bits.add a.pred) b.pred))) #a.pred (Bits.1 ((Bits.add a.pred) b.pred)))) #b.pred ((((a #a.self Bits) b) #a.pred (Bits.1 ((Bits.add a.pred) b.pred))) #a.pred (Bits.0 ((Bits.add (Bits.inc a.pred)) b.pred))));
Bits.chunks_of : @(len:Nat) @(bits:Bits) (List Bits) = #len #bits ((((Bits.chunks_of.go len) bits) len) Bits.nil);
Bits.chunks_of.go : @(len:Nat) @(bits:Bits) @(need:Nat) @(chunk:Bits) (List Bits) = #len #bits #need #chunk ((((bits #bits.self (List Bits)) (((List.cons Bits) (Bits.reverse chunk)) (List.nil Bits))) #bits.pred (((need #need.self (List Bits)) !head = (Bits.reverse chunk); !tail = ((((Bits.chunks_of.go len) bits) len) Bits.nil); (((List.cons Bits) head) tail)) #need.pred !chunk = (Bits.0 chunk); ((((Bits.chunks_of.go len) bits.pred) need.pred) chunk))) #bits.pred (((need #need.self (List Bits)) !head = (Bits.reverse chunk); !tail = ((((Bits.chunks_of.go len) bits) len) Bits.nil); (((List.cons Bits) head) tail)) #need.pred !chunk = (Bits.1 chunk); ((((Bits.chunks_of.go len) bits.pred) need.pred) chunk)));
Bits.concat : @(a:Bits) @(b:Bits) Bits = #a #b ((((a #a.self Bits) b) #a.pred (Bits.0 ((Bits.concat a.pred) b))) #a.pred (Bits.1 ((Bits.concat a.pred) b)));
Bits.eql : @(a:Bits) @(b:Bits) Bool = #a #b ((((a #a.self Bool) ((((b #b.self Bool) Bool.true) #b.pred Bool.false) #b.pred Bool.false)) #a.pred ((((b #b.self Bool) Bool.false) #b.pred ((Bits.eql a.pred) b.pred)) #b.pred Bool.false)) #a.pred ((((b #b.self Bool) Bool.false) #b.pred Bool.false) #b.pred ((Bits.eql a.pred) b.pred)));
Bits.inc : @(a:Bits) Bits = #a ((((a #a.self Bits) (Bits.1 Bits.nil)) #a.pred (Bits.1 a.pred)) #a.pred (Bits.0 (Bits.inc a.pred)));
Bits.nil : Bits = #P #nil #0 #1 nil;
Bits.reverse : @(a:Bits) Bits = #a ((Bits.reverse.tco a) Bits.nil);
Bits.reverse.tco : @(a:Bits) @(r:Bits) Bits = #a #r ((((a #a.self Bits) r) #a.pred ((Bits.reverse.tco a.pred) (Bits.0 r))) #a.pred ((Bits.reverse.tco a.pred) (Bits.1 r)));
Bits.show : @(a:Bits) String = #a ((((a #a.self String) "") #a.pred ((String.cons '0') (Bits.show a.pred))) #a.pred ((String.cons '1') (Bits.show a.pred)));
Bits.tail : @(a:Bits) Bits = #a ((((a #a.self Bits) Bits.nil) #a.pred a.pred) #a.pred a.pred);
Bits.to_nat : @(b:Bits) Nat = #b ((((b #b.self Nat) +0) #b.pred ((Nat.mul +2) (Bits.to_nat b.pred))) #b.pred (Nat.succ ((Nat.mul +2) (Bits.to_nat b.pred))));
Bits.0 : @(pred:Bits) Bits = #pred #P #nil #0 #1 (0 pred);
Bits.1 : @(pred:Bits) Bits = #pred #P #nil #0 #1 (1 pred);
Bit.0 : Bit = #P #0 #1 0;
Bit.1 : Bit = #P #0 #1 1;
Bool : * = %Bool.Self(P:@(self:Bool) *) @(true:(P Bool.true)) @(false:(P Bool.false)) (P Bool.Self);
Bool.and : @(a:Bool) @(b:Bool) Bool = #a #b (((a #a.self Bool) b) Bool.false);
Bool.eql : @(a:Bool) @(b:Bool) Bool = #a #b (((a #a.self Bool) b) (Bool.not b));
Bool.false : Bool = #P #true #false false;
Bool.not : @(a:Bool) Bool = #a (((a #a.self Bool) Bool.false) Bool.true);
Bool.or : @(a:Bool) @(b:Bool) Bool = #a #b (((a #a.self Bool) Bool.true) b);
Bool.true : Bool = #P #true #false true;
Char : * = U16;
Char.new : @(b0:Bit) @(b1:Bit) @(b2:Bit) @(b3:Bit) @(b4:Bit) @(b5:Bit) @(b6:Bit) @(b7:Bit) @(b8:Bit) @(b9:Bit) @(bA:Bit) @(bB:Bit) @(bC:Bit) @(bD:Bit) @(bE:Bit) @(bF:Bit) U16 = #b0 #b1 #b2 #b3 #b4 #b5 #b6 #b7 #b8 #b9 #bA #bB #bC #bD #bE #bF !kF = (((b0 #x @(:(Word +0)) (Word +1)) (Word.0 Nat.zero)) (Word.1 Nat.zero)); !kE = (((b1 #x @(:(Word +1)) (Word +2)) (Word.0 (Nat.succ Nat.zero))) (Word.1 (Nat.succ Nat.zero))); !kD = (((b2 #x @(:(Word +2)) (Word +3)) (Word.0 (Nat.succ (Nat.succ Nat.zero)))) (Word.1 (Nat.succ (Nat.succ Nat.zero)))); !kC = (((b3 #x @(:(Word +3)) (Word +4)) (Word.0 (Nat.succ (Nat.succ (Nat.succ Nat.zero))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ Nat.zero))))); !kB = (((b4 #x @(:(Word +4)) (Word +5)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))); !kA = (((b5 #x @(:(Word +5)) (Word +6)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))); !k9 = (((b6 #x @(:(Word +6)) (Word +7)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))); !k8 = (((b7 #x @(:(Word +7)) (Word +8)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))); !k7 = (((b8 #x @(:(Word +8)) (Word +9)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))); !k6 = (((b9 #x @(:(Word +9)) (Word +10)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))); !k5 = (((bA #x @(:(Word +10)) (Word +11)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))))); !k4 = (((bB #x @(:(Word +11)) (Word +12)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))); !k3 = (((bC #x @(:(Word +12)) (Word +13)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))))))); !k2 = (((bD #x @(:(Word +13)) (Word +14)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))); !k1 = (((bE #x @(:(Word +14)) (Word +15)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))))))))); !k0 = (((bF #x @(:(Word +15)) (Word +16)) (Word.0 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) (Word.1 (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))); !kx = Word.nil; (U16.new (k0 (k1 (k2 (k3 (k4 (k5 (k6 (k7 (k8 (k9 (kA (kB (kC (kD (kE (kF kx)))))))))))))))));
Cmp : * = %Cmp.Self(P:@(self:Cmp) *) @(ltn:(P Cmp.ltn)) @(eql:(P Cmp.eql)) @(gtn:(P Cmp.gtn)) (P Cmp.Self);
Cmp.as_eql : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp.self Bool) Bool.false) Bool.true) Bool.false);
Cmp.as_gte : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp.self Bool) Bool.false) Bool.true) Bool.true);
Cmp.as_gtn : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp.self Bool) Bool.false) Bool.false) Bool.true);
Cmp.as_lte : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp.self Bool) Bool.true) Bool.true) Bool.false);
Cmp.as_ltn : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp.self Bool) Bool.true) Bool.false) Bool.false);
Cmp.eql : Cmp = #P #ltn #eql #gtn eql;
Cmp.gtn : Cmp = #P #ltn #eql #gtn gtn;
Cmp.ltn : Cmp = #P #ltn #eql #gtn ltn;
DPair : @(A:*) @(B:@(x:A) *) * = #A #B %DPair.Self(P:@(self:((DPair A) B)) *) @(new:@(fst:A) @(snd:(B fst)) (P ((((DPair.new A) B) fst) snd))) (P DPair.Self);
DPair.new : %(A:*) %(B:@(x:A) *) @(fst:A) @(snd:(B fst)) ((DPair A) B) = #A #B #fst #snd #P #new ((new fst) snd);
Debug.log : %(A:*) @(s:String) @(x:@(:Unit) A) A = #A #s #x (x Unit.new);
Either : @(A:*) @(B:*) * = #A #B %Either.Self(P:@(self:((Either A) B)) *) @(left:@(value:A) (P (((Either.left A) B) value))) @(right:@(value:B) (P (((Either.right A) B) value))) (P Either.Self);
Either.left : %(A:*) %(B:*) @(value:A) ((Either A) B) = #A #B #value #P #left #right (left value);
Either.right : %(A:*) %(B:*) @(value:B) ((Either A) B) = #A #B #value #P #left #right (right value);
Empty : * = %Empty.Self(P:@(self:Empty) *) (P Empty.Self);
Empty.absurd : %(P:*) @(x:Empty) P = #P #x (x #x.self P);
Fm.Binder : * = %Fm.Binder.Self(P:@(self:Fm.Binder) *) @(new:@(eras:Bool) @(name:Fm.Name) @(term:Fm.Term) (P (((Fm.Binder.new eras) name) term))) (P Fm.Binder.Self);
Fm.Binder.new : @(eras:Bool) @(name:Fm.Name) @(term:Fm.Term) Fm.Binder = #eras #name #term #P #new (((new eras) name) term);
Fm.Check : @(V:*) * = #V %Fm.Check.Self(P:@(self:(Fm.Check V)) *) @(result:@(value:(Maybe V)) @(errors:(List Fm.Error)) (P (((Fm.Check.result V) value) errors))) (P Fm.Check.Self);
Fm.Check.bind : %(A:*) %(B:*) @(a:(Fm.Check A)) @(f:@(:A) (Fm.Check B)) (Fm.Check B) = #A #B #a #f ((a #a.self (Fm.Check B)) #a.value #a.errors (((a.value #got.self (Fm.Check B)) (((Fm.Check.result B) (Maybe.none B)) a.errors)) #got.value (((f got.value) #b.self (Fm.Check B)) #b.value #b.errors (((Fm.Check.result B) b.value) (((List.concat Fm.Error) a.errors) b.errors)))));
Fm.Check.monad : (Monad Fm.Check) = (((Monad.new Fm.Check) Fm.Check.bind) Fm.Check.pure);
Fm.Check.none : %(A:*) (Fm.Check A) = #A (((Fm.Check.result A) (Maybe.none A)) (List.nil Fm.Error));
Fm.Check.pure : %(V:*) @(value:V) (Fm.Check V) = #V #value (((Fm.Check.result V) ((Maybe.some V) value)) (List.nil Fm.Error));
Fm.Check.result : %(V:*) @(value:(Maybe V)) @(errors:(List Fm.Error)) (Fm.Check V) = #V #value #errors #P #result ((result value) errors);
Fm.Check.value : %(A:*) @(chk:(Fm.Check A)) (Maybe A) = #A #chk ((chk #chk.self (Maybe A)) #chk.value #chk.errors chk.value);
Fm.Comp : * = %Fm.Comp.Self(P:@(self:Fm.Comp) *) @(nil:(P Fm.Comp.nil)) @(var:@(name:Fm.Name) (P (Fm.Comp.var name))) @(ref:@(name:Fm.Name) (P (Fm.Comp.ref name))) @(lam:@(name:Fm.Name) @(body:Fm.Comp) (P ((Fm.Comp.lam name) body))) @(app:@(func:Fm.Comp) @(argm:Fm.Comp) (P ((Fm.Comp.app func) argm))) @(let:@(name:Fm.Name) @(expr:Fm.Comp) @(body:Fm.Comp) (P (((Fm.Comp.let name) expr) body))) @(eli:@(prim:Fm.Prim) @(expr:Fm.Comp) (P ((Fm.Comp.eli prim) expr))) @(ins:@(prim:Fm.Prim) @(expr:Fm.Comp) (P ((Fm.Comp.ins prim) expr))) @(nat:@(natx:Nat) (P (Fm.Comp.nat natx))) @(chr:@(chrx:Char) (P (Fm.Comp.chr chrx))) @(str:@(strx:String) (P (Fm.Comp.str strx))) (P Fm.Comp.Self);
Fm.Comp.app : @(func:Fm.Comp) @(argm:Fm.Comp) Fm.Comp = #func #argm #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str ((app func) argm);
Fm.Comp.chr : @(chrx:Char) Fm.Comp = #chrx #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str (chr chrx);
Fm.Comp.compile : @(term:Fm.Term) @(type:(Maybe Fm.Term)) @(defs:Fm.Defs) @(ctx:Fm.Context) (Maybe Fm.Comp) = #term #type #defs #ctx ((((((((((((((((term #term.self (Maybe Fm.Comp)) #term.name #term.indx ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) (Fm.Comp.var term.name))) #term.name ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) (Fm.Comp.ref term.name))) ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) Fm.Comp.nil)) #term.eras #term.self #term.name #term.xtyp #term.body ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) Fm.Comp.nil)) #term.name #term.body (((type #type.self (Maybe Fm.Comp)) (Maybe.none Fm.Comp)) #type.value !typv = ((Fm.Term.reduce type.value) defs); ((((((((((((((((typv #typv.self (Maybe Fm.Comp)) #typv.name #typv.indx (Maybe.none Fm.Comp)) #typv.name (Maybe.none Fm.Comp)) (Maybe.none Fm.Comp)) #typv.eras #typv.self #typv.name #typv.xtyp #typv.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); !self_var = term; !body_var = ((Fm.Term.var term.name) ctx_size); !body_typ = ((typv.body self_var) body_var); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) typv.xtyp)) ctx); ((((((Monad.bind Maybe) Maybe.monad) Fm.Comp) Fm.Comp) ((((Fm.Comp.compile (term.body body_var)) ((Maybe.some Fm.Term) body_typ)) defs) body_ctx)) #body_cmp !term_cmp = (((typv.eras # Fm.Comp) body_cmp) ((Fm.Comp.lam term.name) body_cmp)); !term_cmp = (((((Fm.Comp.prim_of type.value) defs) #prim.self Fm.Comp) term_cmp) #prim.value ((Fm.Comp.ins prim.value) term_cmp)); ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) term_cmp))) #typv.name #typv.body (Maybe.none Fm.Comp)) #typv.func #typv.argm (Maybe.none Fm.Comp)) #typv.name #typv.expr #typv.body (Maybe.none Fm.Comp)) #typv.name #typv.expr #typv.body (Maybe.none Fm.Comp)) #typv.done #typv.term #typv.type (Maybe.none Fm.Comp)) #typv.name #typv.dref #typv.verb (Maybe.none Fm.Comp)) #typv.path (Maybe.none Fm.Comp)) #typv.natx (Maybe.none Fm.Comp)) #typv.chrx (Maybe.none Fm.Comp)) #typv.strx (Maybe.none Fm.Comp)) #typv.path #typv.expr #typv.name #typv.with #typv.cses #typv.moti (Maybe.none Fm.Comp)))) #term.func #term.argm ((((((Monad.bind Maybe) Maybe.monad) Fm.Term) Fm.Comp) ((Fm.Check.value Fm.Term) (((((Fm.Term.check term.func) (Maybe.none Fm.Term)) defs) ctx) (Maybe.none Fm.Path)))) #func_typ !func_typ = ((Fm.Term.reduce func_typ) defs); ((((((((((((((((func_typ #func_typ.self (Maybe Fm.Comp)) #func_typ.name #func_typ.indx (Maybe.none Fm.Comp)) #func_typ.name (Maybe.none Fm.Comp)) (Maybe.none Fm.Comp)) #func_typ.eras #func_typ.self #func_typ.name #func_typ.xtyp #func_typ.body ((((((Monad.bind Maybe) Maybe.monad) Fm.Comp) Fm.Comp) ((((Fm.Comp.compile term.func) (Maybe.none Fm.Term)) defs) ctx)) #func_cmp !func_cmp = (((((Fm.Comp.prim_of func_typ) defs) #prim.self Fm.Comp) func_cmp) #prim.value ((Fm.Comp.eli prim.value) func_cmp)); (((func_typ.eras # (Maybe Fm.Comp)) ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) func_cmp)) ((((((Monad.bind Maybe) Maybe.monad) Fm.Comp) Fm.Comp) ((((Fm.Comp.compile term.argm) ((Maybe.some Fm.Term) func_typ.xtyp)) defs) ctx)) #argm_cmp ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) ((Fm.Comp.app func_cmp) argm_cmp)))))) #func_typ.name #func_typ.body (Maybe.none Fm.Comp)) #func_typ.func #func_typ.argm (Maybe.none Fm.Comp)) #func_typ.name #func_typ.expr #func_typ.body (Maybe.none Fm.Comp)) #func_typ.name #func_typ.expr #func_typ.body (Maybe.none Fm.Comp)) #func_typ.done #func_typ.term #func_typ.type (Maybe.none Fm.Comp)) #func_typ.name #func_typ.dref #func_typ.verb (Maybe.none Fm.Comp)) #func_typ.path (Maybe.none Fm.Comp)) #func_typ.natx (Maybe.none Fm.Comp)) #func_typ.chrx (Maybe.none Fm.Comp)) #func_typ.strx (Maybe.none Fm.Comp)) #func_typ.path #func_typ.expr #func_typ.name #func_typ.with #func_typ.cses #func_typ.moti (Maybe.none Fm.Comp)))) #term.name #term.expr #term.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); ((((((Monad.bind Maybe) Maybe.monad) Fm.Term) Fm.Comp) ((Fm.Check.value Fm.Term) (((((Fm.Term.check term.expr) (Maybe.none Fm.Term)) defs) ctx) (Maybe.none Fm.Path)))) #expr_typ ((((((Monad.bind Maybe) Maybe.monad) Fm.Comp) Fm.Comp) ((((Fm.Comp.compile term.expr) (Maybe.none Fm.Term)) defs) ctx)) #expr_cmp !new_name = (String.flatten (((List.cons String) term.name) (((List.cons String) "_") (((List.cons String) (Nat.show ctx_size)) (List.nil String))))); !body_var = ((Fm.Term.var new_name) ctx_size); !body_val = (term.body body_var); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) expr_typ)) ctx); ((((((Monad.bind Maybe) Maybe.monad) Fm.Comp) Fm.Comp) ((((Fm.Comp.compile body_val) type) defs) body_ctx)) #body_cmp ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) (((Fm.Comp.let new_name) expr_cmp) body_cmp)))))) #term.name #term.expr #term.body ((((Fm.Comp.compile (term.body term.expr)) type) defs) ctx)) #term.done #term.term #term.type ((((Fm.Comp.compile term.term) ((Maybe.some Fm.Term) term.type)) defs) ctx)) #term.name #term.dref #term.verb ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) Fm.Comp.nil)) #term.path ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) Fm.Comp.nil)) #term.natx ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) (Fm.Comp.nat term.natx))) #term.chrx ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) (Fm.Comp.chr term.chrx))) #term.strx ((((Monad.pure Maybe) Maybe.monad) Fm.Comp) (Fm.Comp.str term.strx))) #term.path #term.expr #term.name #term.with #term.cses #term.moti (Maybe.none Fm.Comp));
Fm.Comp.data.ctrs : @(type:Fm.Term) @(defs:Fm.Defs) (List Nat) = #type #defs ((((((((((((((((((Fm.Term.reduce type) defs) #type.self (List Nat)) #type.name #type.indx (List.nil Nat)) #type.name (List.nil Nat)) (List.nil Nat)) #type.eras #type.self #type.name #type.xtyp #type.body (((List.cons Nat) ((Fm.Comp.data.ctr_args type.xtyp) defs)) ((Fm.Comp.data.ctrs ((type.body Fm.Term.typ) Fm.Term.typ)) defs))) #type.name #type.body (List.nil Nat)) #type.func #type.argm (List.nil Nat)) #type.name #type.expr #type.body (List.nil Nat)) #type.name #type.expr #type.body (List.nil Nat)) #type.done #type.term #type.type (List.nil Nat)) #type.name #type.dref #type.verb (List.nil Nat)) #type.path (List.nil Nat)) #type.natx (List.nil Nat)) #type.chrx (List.nil Nat)) #type.strx (List.nil Nat)) #type.path #type.expr #type.name #type.with #type.cses #type.moti (List.nil Nat));
Fm.Comp.data.ctr_args : @(type:Fm.Term) @(defs:Fm.Defs) Nat = #type #defs ((((((((((((((((((Fm.Term.reduce type) defs) #type.self Nat) #type.name #type.indx Nat.zero) #type.name Nat.zero) Nat.zero) #type.eras #type.self #type.name #type.xtyp #type.body (Nat.succ ((Fm.Comp.data.ctr_args ((type.body Fm.Term.typ) Fm.Term.typ)) defs))) #type.name #type.body Nat.zero) #type.func #type.argm Nat.zero) #type.name #type.expr #type.body Nat.zero) #type.name #type.expr #type.body Nat.zero) #type.done #type.term #type.type Nat.zero) #type.name #type.dref #type.verb Nat.zero) #type.path Nat.zero) #type.natx Nat.zero) #type.chrx Nat.zero) #type.strx Nat.zero) #type.path #type.expr #type.name #type.with #type.cses #type.moti Nat.zero);
Fm.Comp.eli : @(prim:Fm.Prim) @(expr:Fm.Comp) Fm.Comp = #prim #expr #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str ((eli prim) expr);
Fm.Comp.hs : @(comp:Fm.Comp) String = #comp ((((((((((((comp #comp.self String) "()") #comp.name (String.flatten (((List.cons String) "_") (((List.cons String) (Fm.Comp.hs.name comp.name)) (List.nil String))))) #comp.name (String.flatten (((List.cons String) "_") (((List.cons String) (Fm.Comp.hs.name comp.name)) (List.nil String))))) #comp.name #comp.body (String.flatten (((List.cons String) "(\\_") (((List.cons String) (Fm.Comp.hs.name comp.name)) (((List.cons String) "-> ") (((List.cons String) (Fm.Comp.hs comp.body)) (((List.cons String) ")") (List.nil String)))))))) #comp.func #comp.argm (String.flatten (((List.cons String) "(app ") (((List.cons String) (Fm.Comp.hs comp.func)) (((List.cons String) " ") (((List.cons String) (Fm.Comp.hs comp.argm)) (((List.cons String) ")") (List.nil String)))))))) #comp.name #comp.expr #comp.body (String.flatten (((List.cons String) "(let _") (((List.cons String) (Fm.Comp.hs.name comp.name)) (((List.cons String) " = ") (((List.cons String) (Fm.Comp.hs comp.expr)) (((List.cons String) " in ") (((List.cons String) (Fm.Comp.hs comp.body)) (((List.cons String) ")") (List.nil String)))))))))) #comp.prim #comp.expr (String.flatten (((List.cons String) "(_eli_") (((List.cons String) (Fm.Prim.name comp.prim)) (((List.cons String) " ") (((List.cons String) (Fm.Comp.hs comp.expr)) (((List.cons String) ")") (List.nil String)))))))) #comp.prim #comp.expr (String.flatten (((List.cons String) "(_ins_") (((List.cons String) (Fm.Prim.name comp.prim)) (((List.cons String) " ") (((List.cons String) (Fm.Comp.hs comp.expr)) (((List.cons String) ")") (List.nil String)))))))) #comp.natx (String.flatten (((List.cons String) "(") (((List.cons String) (Nat.show comp.natx)) (((List.cons String) "::Integer)") (List.nil String)))))) #comp.chrx (String.flatten (((List.cons String) "(") (((List.cons String) (Nat.show (Bits.to_nat ((Word.to_bits (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) (U16.to_word comp.chrx))))) (((List.cons String) "::Word16)") (List.nil String)))))) #comp.strx (String.flatten (((List.cons String) ((String.cons '\"') String.nil)) (((List.cons String) (Fm.escape comp.strx)) (((List.cons String) ((String.cons '\"') String.nil)) (List.nil String))))));
Fm.Comp.hs.defs : @(defs:Fm.Defs) String = #defs !list = ((Map.to_list Fm.Def) defs); !code = ((String.join "\u{A}") (((List.cons String) "import Unsafe.Coerce") (((List.cons String) "import Data.Word") (((List.cons String) "import Data.Bits") (((List.cons String) "app = unsafeCoerce") (((List.cons String) "_ins_bool = \\x-> x True False") (((List.cons String) "_eli_bool = \\x-> case x of { True -> (\\t-> \\f-> t); False -> (\\t-> \\f-> f); }") (((List.cons String) "_ins_nat = \\x-> (x 0 (\\p-> 1 + p)) :: Integer") (((List.cons String) "_eli_nat = \\x-> \\z-> \\s-> if x == 0 then z else (app s (x - 1))") (((List.cons String) "_ins_string = \\x-> x [] (\\h t-> (toEnum (fromIntegral h) :: Char) : t)") (((List.cons String) "_eli_string = \\x-> case x::String of { []-> \\n e-> n; (c:cs)-> \\n e-> e(fromIntegral(fromEnum c) :: Word16)cs }") (((List.cons String) "_ins_u16 = \\x-> x (\\x -> (go 0 0 x)::Word16) where go i u x = if i<16 then x u (\\x-> app go (i + 1) u x) (\\x-> app go (i+1) (u.|.(shiftL 1 i)) x) else u") (((List.cons String) "_eli_u16 = \\x-> (\\t -> t (go 0 (\\n o i-> n) (x::Word16))) where go i w x = if i<16 then go (i+1) (if (shiftR x (16-i-1).&.1)>0 then \\n o i-> app i w else \\n o i-> app o w) x else w") (((List.cons String) "") (List.nil String))))))))))))))); !code = (((((List.for ((Pair Bits) Fm.Def)) list) String) code) #def #code ((def #def.self String) #def.fst #def.snd ((def.snd #def.snd.self String) #def.snd.name #def.snd.term #def.snd.type #def.snd.done !name = def.snd.name; !line = ((((((Fm.get String) name) Fm.Comp.hs.native_ops) #got.self String) !comp = ((((Fm.Comp.compile def.snd.term) ((Maybe.some Fm.Term) def.snd.type)) defs) (List.nil ((Pair Fm.Name) Fm.Term))); !body = (((comp #comp.self String) "()") #comp.value (Fm.Comp.hs comp.value)); (String.flatten (((List.cons String) "_") (((List.cons String) (Fm.Comp.hs.name name)) (((List.cons String) " = ") (((List.cons String) body) (List.nil String))))))) #got.value got.value); (String.flatten (((List.cons String) code) (((List.cons String) line) (((List.cons String) "\u{A}") (List.nil String)))))))); code;
Fm.Comp.hs.name : @(name:Fm.Name) String = #name (((name #name.self String) "") #name.head #name.tail !chr = ((((((U16.btw 'A') name.head) 'Z') # Char) ((U16.add name.head) (Nat.to_u16 +32))) (((((U16.eql name.head) '.') # Char) '_') name.head)); ((String.cons chr) (Fm.Comp.hs.name name.tail)));
Fm.Comp.hs.native_ops : (Map String) = !pairs = (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.add") "_nat_add = \\n m-> (n::Integer) + (m::Integer)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.sub") "_nat_sub = \\n m-> max ((n::Integer) - (m::Integer)) 0")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.mul") "_nat_mul = \\n m-> (n::Integer) * (m::Integer)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.div") "_nat_div = \\n m-> div (n::Integer) (m::Integer)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.div_mod") "_nat_div_mod = \\n m t-> t (div (n::Integer) (m::Integer)) (mod n m)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.pow") "_nat_pow = \\n m-> (n::Integer) ^ (m::Integer)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.ltn") "_nat_ltn = \\n m-> (n::Integer) < (m::Integer)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.lte") "_nat_lte = \\n m-> (n::Integer) <= (m::Integer)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.eql") "_nat_eql = \\n m-> (n::Integer) == (m::Integer)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.gte") "_nat_gte = \\n m-> (n::Integer) >= (m::Integer)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.gtn") "_nat_gtn = \\n m-> (n::Integer) > (m::Integer)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "Nat.to_u16") "_nat_to_u16 = \\n-> (fromInteger (n::Integer)) :: Word16")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.add") "_u16_add = \\n m-> (n::Word16) + (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.sub") "_u16_sub = \\n m-> (n::Word16) - (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.mul") "_u16_add = \\n m-> (n::Word16) + (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.div") "_u16_div = \\n m-> div (n::Word16) (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.mod") "_u16_mod = \\n m-> mod (n::Word16) (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.pow") "_u16_pow = \\n m-> (n::Word16) ^ (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.ltn") "_u16_ltn = \\n m-> (n::Word16) < (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.lte") "_u16_lte = \\n m-> (n::Word16) <= (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.eql") "_u16_eql = \\n m-> (n::Word16) == (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.gte") "_u16_gte = \\n m-> (n::Word16) >= (m::Word16)")) (((List.cons ((Pair String) String)) ((((Pair.new String) String) "U16.gtn") "_u16_gtn = \\n m-> (n::Word16) > (m::Word16)")) (List.nil ((Pair String) String))))))))))))))))))))))))); !map = (Map.new String); !map = (((((List.for ((Pair String) String)) pairs) (Map String)) map) #pair #map ((pair #pair.self (Map String)) #pair.fst #pair.snd ((((Fm.set String) pair.fst) pair.snd) map))); map;
Fm.Comp.ins : @(prim:Fm.Prim) @(expr:Fm.Comp) Fm.Comp = #prim #expr #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str ((ins prim) expr);
Fm.Comp.lam : @(name:Fm.Name) @(body:Fm.Comp) Fm.Comp = #name #body #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str ((lam name) body);
Fm.Comp.let : @(name:Fm.Name) @(expr:Fm.Comp) @(body:Fm.Comp) Fm.Comp = #name #expr #body #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str (((let name) expr) body);
Fm.Comp.nat : @(natx:Nat) Fm.Comp = #natx #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str (nat natx);
Fm.Comp.nil : Fm.Comp = #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str nil;
Fm.Comp.prims : (List ((Pair String) Fm.Prim)) = (((List.cons ((Pair String) Fm.Prim)) ((((Pair.new String) Fm.Prim) "Bool.Self") Fm.Prim.bool)) (((List.cons ((Pair String) Fm.Prim)) ((((Pair.new String) Fm.Prim) "Nat.Self") Fm.Prim.nat)) (((List.cons ((Pair String) Fm.Prim)) ((((Pair.new String) Fm.Prim) "U16.Self") Fm.Prim.u16)) (((List.cons ((Pair String) Fm.Prim)) ((((Pair.new String) Fm.Prim) "String.Self") Fm.Prim.string)) (List.nil ((Pair String) Fm.Prim))))));
Fm.Comp.prim_of : @(type:Fm.Term) @(defs:Fm.Defs) (Maybe Fm.Prim) = #type #defs ((((((((((((((((((Fm.Term.reduce type) defs) #type.self (Maybe Fm.Prim)) #type.name #type.indx (Maybe.none Fm.Prim)) #type.name (Maybe.none Fm.Prim)) (Maybe.none Fm.Prim)) #type.eras #type.self #type.name #type.xtyp #type.body (((((List.fold ((Pair String) Fm.Prim)) Fm.Comp.prims) (Maybe Fm.Prim)) (((type.self #type.self.self (Maybe Fm.Prim)) (Maybe.none Fm.Prim)) #type.self.head #type.self.tail ((Maybe.some Fm.Prim) (Fm.Prim.data ((Fm.Comp.data.ctrs ((type.body Fm.Term.typ) Fm.Term.typ)) defs))))) #name_prim #cont ((name_prim #name_prim.self (Maybe Fm.Prim)) #name_prim.fst #name_prim.snd (((((String.eql name_prim.fst) type.self) # (Maybe Fm.Prim)) ((Maybe.some Fm.Prim) name_prim.snd)) cont)))) #type.name #type.body (Maybe.none Fm.Prim)) #type.func #type.argm (Maybe.none Fm.Prim)) #type.name #type.expr #type.body (Maybe.none Fm.Prim)) #type.name #type.expr #type.body (Maybe.none Fm.Prim)) #type.done #type.term #type.type (Maybe.none Fm.Prim)) #type.name #type.dref #type.verb (Maybe.none Fm.Prim)) #type.path (Maybe.none Fm.Prim)) #type.natx (Maybe.none Fm.Prim)) #type.chrx (Maybe.none Fm.Prim)) #type.strx (Maybe.none Fm.Prim)) #type.path #type.expr #type.name #type.with #type.cses #type.moti (Maybe.none Fm.Prim));
Fm.Comp.ref : @(name:Fm.Name) Fm.Comp = #name #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str (ref name);
Fm.Comp.str : @(strx:String) Fm.Comp = #strx #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str (str strx);
Fm.Comp.var : @(name:Fm.Name) Fm.Comp = #name #P #nil #var #ref #lam #app #let #eli #ins #nat #chr #str (var name);
Fm.Constructor : * = %Fm.Constructor.Self(P:@(self:Fm.Constructor) *) @(new:@(name:Fm.Name) @(args:(List Fm.Binder)) @(inds:(List Fm.Binder)) (P (((Fm.Constructor.new name) args) inds))) (P Fm.Constructor.Self);
Fm.Constructor.build_term : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor.self Fm.Term) #ctor.name #ctor.args #ctor.inds (((((Fm.Constructor.build_term.go type) ctor) type.name) type.pars) ctor.args)));
Fm.Constructor.build_term.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(args:(List Fm.Binder)) Fm.Term = #type #ctor #name #pars #args (((pars #pars.self Fm.Term) (((args #args.self Fm.Term) $lam_name = (Fm.Name.read "P"); $lam_body = #x ((Fm.Constructor.build_term.opt type) ctor); ((Fm.Term.lam lam_name) lam_body)) #args.head #args.tail ((args.head #args.head.self Fm.Term) #args.head.eras #args.head.name #args.head.term $ctr_name = args.head.name; $ctr_body = #x (((((Fm.Constructor.build_term.go type) ctor) name) pars) args.tail); ((Fm.Term.lam ctr_name) ctr_body)))) #pars.head #pars.tail ((pars.head #pars.head.self Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $par_name = pars.head.name; $par_body = #x (((((Fm.Constructor.build_term.go type) ctor) name) pars.tail) args); ((Fm.Term.lam par_name) par_body)));
Fm.Constructor.build_term.opt : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs (((Fm.Constructor.build_term.opt.go type) ctor) type.ctrs));
Fm.Constructor.build_term.opt.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(ctrs:(List Fm.Constructor)) Fm.Term = #type #ctor #ctrs (((ctrs #ctrs.self Fm.Term) ((ctor #ctor.self Fm.Term) #ctor.name #ctor.args #ctor.inds !ret = (Fm.Term.ref ctor.name); !ret = (((((List.for Fm.Binder) ctor.args) Fm.Term) ret) #arg #ret ((Fm.Term.app ret) (Fm.Term.ref ((arg #arg.self Fm.Name) #arg.eras #arg.name #arg.term arg.name)))); ret)) #ctrs.head #ctrs.tail ((ctrs.head #ctrs.head.self Fm.Term) #ctrs.head.name #ctrs.head.args #ctrs.head.inds $name = ctrs.head.name; $body = #x (((Fm.Constructor.build_term.opt.go type) ctor) ctrs.tail); ((Fm.Term.lam name) body)));
Fm.Constructor.build_type : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor.self Fm.Term) #ctor.name #ctor.args #ctor.inds (((((Fm.Constructor.build_type.go type) ctor) type.name) type.pars) ctor.args)));
Fm.Constructor.build_type.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(args:(List Fm.Binder)) Fm.Term = #type #ctor #name #pars #args (((pars #pars.self Fm.Term) (((args #args.self Fm.Term) ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor.self Fm.Term) #ctor.name #ctor.args #ctor.inds !type = (Fm.Term.ref name); !type = (((((List.for Fm.Binder) type.pars) Fm.Term) type) #var #type ((Fm.Term.app type) (Fm.Term.ref ((var #var.self Fm.Name) #var.eras #var.name #var.term var.name)))); !type = (((((List.for Fm.Binder) ctor.inds) Fm.Term) type) #var #type ((Fm.Term.app type) ((var #var.self Fm.Term) #var.eras #var.name #var.term var.term))); type))) #args.head #args.tail ((args.head #args.head.self Fm.Term) #args.head.eras #args.head.name #args.head.term $ctr_eras = args.head.eras; $ctr_name = args.head.name; $ctr_xtyp = args.head.term; $ctr_body = #s #x (((((Fm.Constructor.build_type.go type) ctor) name) pars) args.tail); (((((Fm.Term.all ctr_eras) "") ctr_name) ctr_xtyp) ctr_body)))) #pars.head #pars.tail ((pars.head #pars.head.self Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $pars_eras = pars.head.eras; $pars_name = pars.head.name; $pars_xtyp = pars.head.term; $pars_body = #s #x (((((Fm.Constructor.build_type.go type) ctor) name) pars.tail) args); (((((Fm.Term.all pars_eras) "") pars_name) pars_xtyp) pars_body)));
Fm.Constructor.new : @(name:Fm.Name) @(args:(List Fm.Binder)) @(inds:(List Fm.Binder)) Fm.Constructor = #name #args #inds #P #new (((new name) args) inds);
Fm.Context : * = (List ((Pair Fm.Name) Fm.Term));
Fm.Context.find : @(name:Fm.Name) @(ctx:Fm.Context) (Maybe Fm.Term) = #name #ctx (((ctx #ctx.self (Maybe Fm.Term)) (Maybe.none Fm.Term)) #ctx.head #ctx.tail ((ctx.head #ctx.head.self (Maybe Fm.Term)) #ctx.head.fst #ctx.head.snd (((((Fm.Name.eql name) ctx.head.fst) # (Maybe Fm.Term)) ((Maybe.some Fm.Term) ctx.head.snd)) ((Fm.Context.find name) ctx.tail))));
Fm.Context.names : @(ctx:Fm.Context) (List Fm.Name) = #ctx ((((List.mapped ((Pair Fm.Name) Fm.Term)) ctx) Fm.Name) #x (((Pair.fst Fm.Name) Fm.Term) x));
Fm.Context.show : @(context:Fm.Context) String = #context (((context #context.self String) "") #context.head #context.tail ((context.head #context.head.self String) #context.head.fst #context.head.snd !name = (Fm.Name.show context.head.fst); !type = (Fm.Term.show context.head.snd); !rest = (Fm.Context.show context.tail); (String.flatten (((List.cons String) rest) (((List.cons String) ((((String.is_empty rest) # String) "") "\u{A}")) (((List.cons String) "- ") (((List.cons String) name) (((List.cons String) ": ") (((List.cons String) type) (List.nil String))))))))));
Fm.Datatype : * = %Fm.Datatype.Self(P:@(self:Fm.Datatype) *) @(new:@(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) @(ctrs:(List Fm.Constructor)) (P ((((Fm.Datatype.new name) pars) inds) ctrs))) (P Fm.Datatype.Self);
Fm.Datatype.build_term : @(type:Fm.Datatype) Fm.Term = #type ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((((Fm.Datatype.build_term.go type) type.name) type.pars) type.inds));
Fm.Datatype.build_term.constructor : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((ctor #ctor.self Fm.Term) #ctor.name #ctor.args #ctor.inds (((Fm.Datatype.build_term.constructor.go type) ctor) ctor.args));
Fm.Datatype.build_term.constructors : @(type:Fm.Datatype) Fm.Term = #type ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs (((Fm.Datatype.build_term.constructors.go type) type.name) type.ctrs));
Fm.Datatype.build_term.constructors.go : @(type:Fm.Datatype) @(name:Fm.Name) @(ctrs:(List Fm.Constructor)) Fm.Term = #type #name #ctrs (((ctrs #ctrs.self Fm.Term) ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs !ret = (Fm.Term.ref (Fm.Name.read "P")); !ret = (((((List.for Fm.Binder) type.inds) Fm.Term) ret) #var #ret ((Fm.Term.app ret) (Fm.Term.ref ((var #var.self Fm.Name) #var.eras #var.name #var.term var.name)))); ((Fm.Term.app ret) (Fm.Term.ref ((String.concat name) ".Self"))))) #ctrs.head #ctrs.tail ((ctrs.head #ctrs.head.self Fm.Term) #ctrs.head.name #ctrs.head.args #ctrs.head.inds (((((Fm.Term.all Bool.false) "") ctrs.head.name) ((Fm.Datatype.build_term.constructor type) ctrs.head)) #s #x (((Fm.Datatype.build_term.constructors.go type) name) ctrs.tail))));
Fm.Datatype.build_term.constructor.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(args:(List Fm.Binder)) Fm.Term = #type #ctor #args (((args #args.self Fm.Term) ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor.self Fm.Term) #ctor.name #ctor.args #ctor.inds !ret = (Fm.Term.ref (Fm.Name.read "P")); !ret = (((((List.for Fm.Binder) ctor.inds) Fm.Term) ret) #var #ret ((Fm.Term.app ret) ((var #var.self Fm.Term) #var.eras #var.name #var.term var.term))); !ctr = (String.flatten (((List.cons String) type.name) (((List.cons Fm.Name) (Fm.Name.read ".")) (((List.cons Fm.Name) ctor.name) (List.nil Fm.Name))))); !slf = (Fm.Term.ref ctr); !slf = (((((List.for Fm.Binder) type.pars) Fm.Term) slf) #var #slf ((Fm.Term.app slf) (Fm.Term.ref ((var #var.self Fm.Name) #var.eras #var.name #var.term var.name)))); !slf = (((((List.for Fm.Binder) ctor.args) Fm.Term) slf) #var #slf ((Fm.Term.app slf) (Fm.Term.ref ((var #var.self Fm.Name) #var.eras #var.name #var.term var.name)))); ((Fm.Term.app ret) slf)))) #args.head #args.tail ((args.head #args.head.self Fm.Term) #args.head.eras #args.head.name #args.head.term !eras = args.head.eras; !name = args.head.name; !xtyp = args.head.term; !body = (((Fm.Datatype.build_term.constructor.go type) ctor) args.tail); (((((Fm.Term.all eras) "") name) xtyp) #s #x body)));
Fm.Datatype.build_term.go : @(type:Fm.Datatype) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) Fm.Term = #type #name #pars #inds (((pars #pars.self Fm.Term) (((inds #inds.self Fm.Term) $moti = (Fm.Datatype.build_term.motive type); $body = #s #x (Fm.Datatype.build_term.constructors type); (((((Fm.Term.all Bool.true) ((String.concat name) ".Self")) (Fm.Name.read "P")) moti) body)) #inds.head #inds.tail ((inds.head #inds.head.self Fm.Term) #inds.head.eras #inds.head.name #inds.head.term $ind_name = inds.head.name; $ind_body = #x ((((Fm.Datatype.build_term.go type) name) pars) inds.tail); ((Fm.Term.lam ind_name) ind_body)))) #pars.head #pars.tail ((pars.head #pars.head.self Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $par_name = pars.head.name; $par_body = #x ((((Fm.Datatype.build_term.go type) name) pars.tail) inds); ((Fm.Term.lam par_name) par_body)));
Fm.Datatype.build_term.motive : @(type:Fm.Datatype) Fm.Term = #type ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs (((Fm.Datatype.build_term.motive.go type) type.name) type.inds));
Fm.Datatype.build_term.motive.go : @(type:Fm.Datatype) @(name:Fm.Name) @(inds:(List Fm.Binder)) Fm.Term = #type #name #inds (((inds #inds.self Fm.Term) ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs !slf = (Fm.Term.ref name); !slf = (((((List.for Fm.Binder) type.pars) Fm.Term) slf) #var #slf ((Fm.Term.app slf) (Fm.Term.ref ((var #var.self Fm.Name) #var.eras #var.name #var.term var.name)))); !slf = (((((List.for Fm.Binder) type.inds) Fm.Term) slf) #var #slf ((Fm.Term.app slf) (Fm.Term.ref ((var #var.self Fm.Name) #var.eras #var.name #var.term var.name)))); (((((Fm.Term.all Bool.false) "") (Fm.Name.read "self")) slf) #s #x Fm.Term.typ))) #inds.head #inds.tail ((inds.head #inds.head.self Fm.Term) #inds.head.eras #inds.head.name #inds.head.term $ind_eras = inds.head.eras; $ind_name = inds.head.name; $ind_xtyp = inds.head.term; $ind_body = #s #x (((Fm.Datatype.build_term.motive.go type) name) inds.tail); (((((Fm.Term.all ind_eras) "") ind_name) ind_xtyp) ind_body)));
Fm.Datatype.build_type : @(type:Fm.Datatype) Fm.Term = #type ((type #type.self Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((((Fm.Datatype.build_type.go type) type.name) type.pars) type.inds));
Fm.Datatype.build_type.go : @(type:Fm.Datatype) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) Fm.Term = #type #name #pars #inds (((pars #pars.self Fm.Term) (((inds #inds.self Fm.Term) Fm.Term.typ) #inds.head #inds.tail ((inds.head #inds.head.self Fm.Term) #inds.head.eras #inds.head.name #inds.head.term $ind_eras = inds.head.eras; $ind_name = inds.head.name; $ind_xtyp = inds.head.term; $ind_body = #s #x ((((Fm.Datatype.build_type.go type) name) pars) inds.tail); (((((Fm.Term.all Bool.false) "") ind_name) ind_xtyp) ind_body)))) #pars.head #pars.tail ((pars.head #pars.head.self Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $par_eras = pars.head.eras; $par_name = pars.head.name; $par_xtyp = pars.head.term; $par_body = #s #x ((((Fm.Datatype.build_type.go type) name) pars.tail) inds); (((((Fm.Term.all Bool.false) "") par_name) par_xtyp) par_body)));
Fm.Datatype.new : @(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) @(ctrs:(List Fm.Constructor)) Fm.Datatype = #name #pars #inds #ctrs #P #new ((((new name) pars) inds) ctrs);
Fm.Def : * = %Fm.Def.Self(P:@(self:Fm.Def) *) @(new:@(name:Fm.Name) @(term:Fm.Term) @(type:Fm.Term) @(done:Bool) (P ((((Fm.Def.new name) term) type) done))) (P Fm.Def.Self);
Fm.Defs : * = (Map Fm.Def);
Fm.Defs.core : @(defs:Fm.Defs) String = #defs !result = ""; !result = (((((List.for ((Pair Bits) Fm.Def)) ((Map.to_list Fm.Def) defs)) String) result) #def #result ((def #def.self String) #def.fst #def.snd ((def.snd #def.snd.self String) #def.snd.name #def.snd.term #def.snd.type #def.snd.done !name = def.snd.name; !term = (Fm.Term.core def.snd.term); !type = (Fm.Term.core def.snd.type); (String.flatten (((List.cons String) result) (((List.cons Fm.Name) name) (((List.cons String) " : ") (((List.cons String) type) (((List.cons String) " = ") (((List.cons String) term) (((List.cons String) ";\u{A}") (List.nil String)))))))))))); result;
Fm.Defs.read : @(code:String) (Maybe Fm.Defs) = #code ((((Fm.Parser.file code) #parsed.self (Maybe Fm.Defs)) #parsed.code #parsed.err (Maybe.none Fm.Defs)) #parsed.code #parsed.val ((Maybe.some Fm.Defs) parsed.val));
Fm.Defs.report : @(defs:Fm.Defs) String = #defs !result = ""; !result = (((((List.for ((Pair Bits) Fm.Def)) ((Map.to_list Fm.Def) defs)) String) result) #def #result ((def #def.self String) #def.fst #def.snd ((def.snd #def.snd.self String) #def.snd.name #def.snd.term #def.snd.type #def.snd.done !name = def.snd.name; !term = def.snd.term; !type = def.snd.type; !check = (((((Fm.Term.check term) ((Maybe.some Fm.Term) type)) defs) (List.nil ((Pair Fm.Name) Fm.Term))) Fm.MPath.nil); ((check #check.self String) #check.value #check.errors (((check.errors #check.errors.self String) result) #check.errors.head #check.errors.tail !name_str = (Fm.Name.show name); !type_str = "<error>"; !result = (((((List.for Fm.Error) check.errors) String) result) #error #result (String.flatten (((List.cons String) result) (((List.cons String) "On ") (((List.cons String) name_str) (((List.cons String) ":\u{A}") (((List.cons String) ((Fm.Error.show error) defs)) (((List.cons String) "\u{A}") (List.nil String))))))))); result))))); (((result #result.self String) "All terms check.") #result.head #result.tail result);
Fm.Defs.show : @(defs:Fm.Defs) String = #defs !str = ""; !str = (((((List.for ((Pair Bits) Fm.Def)) ((Map.to_list Fm.Def) defs)) String) str) #name_def #str ((name_def #name_def.self String) #name_def.fst #name_def.snd ((name_def.snd #def.self String) #def.name #def.term #def.type #def.done (String.flatten (((List.cons String) str) (((List.cons String) (Fm.Name.show def.name)) (((List.cons String) ": ") (((List.cons String) (Fm.Term.show def.type)) (((List.cons String) "\u{A}  ") (((List.cons String) (Fm.Term.show def.term)) (((List.cons String) "\u{A}") (List.nil String)))))))))))); str;
Fm.Def.new : @(name:Fm.Name) @(term:Fm.Term) @(type:Fm.Term) @(done:Bool) Fm.Def = #name #term #type #done #P #new ((((new name) term) type) done);
Fm.Error : * = %Fm.Error.Self(P:@(self:Fm.Error) *) @(type_mismatch:@(expected:((Either String) Fm.Term)) @(detected:((Either String) Fm.Term)) @(context:Fm.Context) (P (((Fm.Error.type_mismatch expected) detected) context))) @(show_goal:@(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) @(goal:(Maybe Fm.Term)) @(context:Fm.Context) (P (((((Fm.Error.show_goal name) dref) verb) goal) context))) @(patch:@(path:Bits) @(term:Fm.Term) (P ((Fm.Error.patch path) term))) @(undefined_reference:@(name:Fm.Name) (P (Fm.Error.undefined_reference name))) @(cant_infer:@(term:Fm.Term) @(context:Fm.Context) (P ((Fm.Error.cant_infer term) context))) (P Fm.Error.Self);
Fm.Error.cant_infer : @(term:Fm.Term) @(context:Fm.Context) Fm.Error = #term #context #P #type_mismatch #show_goal #patch #undefined_reference #cant_infer ((cant_infer term) context);
Fm.Error.patch : @(path:Bits) @(term:Fm.Term) Fm.Error = #path #term #P #type_mismatch #show_goal #patch #undefined_reference #cant_infer ((patch path) term);
Fm.Error.show : @(error:Fm.Error) @(defs:Fm.Defs) String = #error #defs ((((((error #error.self String) #error.expected #error.detected #error.context !expected = (((error.expected #error.expected.self String) #error.expected.value error.expected.value) #error.expected.value (Fm.Term.show ((Fm.Term.normalize error.expected.value) (Map.new Fm.Def)))); !detected = (((error.detected #error.detected.self String) #error.detected.value error.detected.value) #error.detected.value (Fm.Term.show ((Fm.Term.normalize error.detected.value) (Map.new Fm.Def)))); !context = (Fm.Context.show error.context); (String.flatten (((List.cons String) "Type mismatch.\u{A}") (((List.cons String) "- Expected: ") (((List.cons String) expected) (((List.cons String) "\u{A}") (((List.cons String) "- Detected: ") (((List.cons String) detected) (((List.cons String) "\u{A}") (((List.cons String) "With context:\u{A}") (((List.cons String) context) (List.nil String)))))))))))) #error.name #error.dref #error.verb #error.goal #error.context !goal_name = (String.flatten (((List.cons String) "Goal ?") (((List.cons String) (Fm.Name.show error.name)) (((List.cons String) ":\u{A}") (List.nil String))))); !with_type = (((error.goal #error.goal.self String) "") #error.goal.value !goal = (((Fm.Term.expand error.dref) error.goal.value) defs); (String.flatten (((List.cons String) "With type: ") (((List.cons String) (((error.verb # String) ((Fm.Term.show.go goal) ((Maybe.some @(:Bits) Bits) #x x))) (Fm.Term.show goal))) (((List.cons String) "\u{A}") (List.nil String)))))); !with_ctxt = (String.flatten (((List.cons String) "With ctxt:\u{A}") (((List.cons String) (Fm.Context.show error.context)) (List.nil String)))); (String.flatten (((List.cons String) goal_name) (((List.cons String) with_type) (((List.cons String) with_ctxt) (List.nil String)))))) #error.path #error.term (String.flatten (((List.cons String) "Patching: ") (((List.cons String) (Fm.Term.show error.term)) (List.nil String))))) #error.name (String.flatten (((List.cons String) "Undefined reference: ") (((List.cons String) (Fm.Name.show error.name)) (List.nil String))))) #error.term #error.context !term = (Fm.Term.show error.term); !context = (Fm.Context.show error.context); (String.flatten (((List.cons String) "Can\'t infer type of: ") (((List.cons String) term) (((List.cons String) "\u{A}") (((List.cons String) "With ctxt:\u{A}") (((List.cons String) context) (List.nil String))))))));
Fm.Error.show_goal : @(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) @(goal:(Maybe Fm.Term)) @(context:Fm.Context) Fm.Error = #name #dref #verb #goal #context #P #type_mismatch #show_goal #patch #undefined_reference #cant_infer (((((show_goal name) dref) verb) goal) context);
Fm.Error.type_mismatch : @(expected:((Either String) Fm.Term)) @(detected:((Either String) Fm.Term)) @(context:Fm.Context) Fm.Error = #expected #detected #context #P #type_mismatch #show_goal #patch #undefined_reference #cant_infer (((type_mismatch expected) detected) context);
Fm.Error.undefined_reference : @(name:Fm.Name) Fm.Error = #name #P #type_mismatch #show_goal #patch #undefined_reference #cant_infer (undefined_reference name);
Fm.Letter : * = Char;
Fm.MPath : * = (Maybe Fm.Path);
Fm.MPath.nil : (Maybe Fm.Path) = ((Maybe.some Fm.Path) Fm.Path.nil);
Fm.MPath.to_bits : @(path:(Maybe Fm.Path)) Bits = #path (((path #path.self Bits) Bits.nil) #path.value (path.value Bits.nil));
Fm.MPath.0 : @(path:(Maybe Fm.Path)) (Maybe Fm.Path) = #path ((((Maybe.mapped Fm.Path) path) Fm.Path) Fm.Path.0);
Fm.MPath.1 : @(path:(Maybe Fm.Path)) (Maybe Fm.Path) = #path ((((Maybe.mapped Fm.Path) path) Fm.Path) Fm.Path.1);
Fm.Name : * = String;
Fm.Name.eql : @(a:Fm.Name) @(b:Fm.Name) Bool = #a #b ((String.eql a) b);
Fm.Name.from_bits : @(bits:Bits) Fm.Name = #bits !list = ((Bits.chunks_of +6) bits); !name = (((((List.fold Bits) list) Fm.Name) String.nil) #bts #name !u16 = (U16.new ((Word.from_bits +16) (Bits.reverse bts))); !chr = ((((((U16.btw (Nat.to_u16 +0)) u16) (Nat.to_u16 +25)) # Char) ((U16.add u16) (Nat.to_u16 +65))) ((((((U16.btw (Nat.to_u16 +26)) u16) (Nat.to_u16 +51)) # U16) ((U16.add u16) (Nat.to_u16 +71))) ((((((U16.btw (Nat.to_u16 +52)) u16) (Nat.to_u16 +61)) # U16) ((U16.sub u16) (Nat.to_u16 +4))) (((((U16.eql (Nat.to_u16 +62)) u16) # U16) (Nat.to_u16 +46)) (Nat.to_u16 +95))))); ((String.cons chr) name)); name;
Fm.Name.is_letter : @(chr:Char) Bool = #chr ((((((U16.btw 'A') chr) 'Z') # Bool) Bool.true) ((((((U16.btw 'a') chr) 'z') # Bool) Bool.true) ((((((U16.btw '0') chr) '9') # Bool) Bool.true) (((((U16.eql '.') chr) # Bool) Bool.true) (((((U16.eql '_') chr) # Bool) Bool.true) Bool.false)))));
Fm.Name.read : @(str:String) Fm.Name = #str str;
Fm.Name.show : @(name:Fm.Name) String = #name name;
Fm.Name.to_bits : @(name:Fm.Name) Bits = #name (((name #name.self Bits) Bits.nil) #name.head #name.tail !chr = name.head; !u16 = ((((((U16.btw 'A') chr) 'Z') # U16) ((U16.sub chr) (Nat.to_u16 +65))) ((((((U16.btw 'a') chr) 'z') # U16) ((U16.sub chr) (Nat.to_u16 +71))) ((((((U16.btw '0') chr) '9') # U16) ((U16.add chr) (Nat.to_u16 +4))) (((((U16.eql '.') chr) # U16) (Nat.to_u16 +62)) (((((U16.eql '_') chr) # U16) (Nat.to_u16 +63)) (Nat.to_u16 +0)))))); !bts = ((u16 #u16.self Bits) #u16.value ((Word.to_bits +6) (((Word.trim +16) +6) u16.value))); ((Bits.concat (Bits.reverse bts)) (Fm.Name.to_bits name.tail)));
Fm.Parser.annotation : @(term:Fm.Term) (Parser Fm.Term) = #term ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "::")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #type ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.ann Bool.false) term) type))));
Fm.Parser.application : @(func:Fm.Term) (Parser Fm.Term) = #func ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text "(")) (((List.cons (Parser Unit)) (Parser.text "<")) (List.nil (Parser Unit)))))) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Term)) Fm.Term) ((Parser.many1 Fm.Term) ((Fm.Parser.item Fm.Term) Fm.Parser.term))) #args ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.spaces_text ")")) (((List.cons (Parser Unit)) (Parser.spaces_text ">")) (List.nil (Parser Unit)))))) # ((((Monad.pure Parser) Parser.monad) Fm.Term) (((((List.for Fm.Term) args) Fm.Term) func) #x #f ((Fm.Term.app f) x))))));
Fm.Parser.arrow : @(xtyp:Fm.Term) (Parser Fm.Term) = #xtyp ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "->")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) (((((Fm.Term.all Bool.false) "") "") xtyp) #s #x body))));
Fm.Parser.binder : (Parser (List Fm.Binder)) = ((((((Monad.bind Parser) Parser.monad) (List (List Fm.Binder))) (List Fm.Binder)) ((Parser.many1 (List Fm.Binder)) ((Parser.first_of (List Fm.Binder)) (((List.cons (Parser (List Fm.Binder))) (Fm.Parser.binder.homo Bool.true)) (((List.cons (Parser (List Fm.Binder))) (Fm.Parser.binder.homo Bool.false)) (List.nil (Parser (List Fm.Binder)))))))) #lists ((((Monad.pure Parser) Parser.monad) (List Fm.Binder)) ((List.flatten Fm.Binder) lists)));
Fm.Parser.binder.homo : @(eras:Bool) (Parser (List Fm.Binder)) = #eras ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.spaces_text (((eras # String) "<") "("))) # ((((((Monad.bind Parser) Parser.monad) (List ((Pair Fm.Name) Fm.Term))) (List Fm.Binder)) ((Parser.many1 ((Pair Fm.Name) Fm.Term)) ((Fm.Parser.item ((Pair Fm.Name) Fm.Term)) Fm.Parser.name_term))) #bind ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.spaces_text (((eras # String) ">") ")"))) # ((((Monad.pure Parser) Parser.monad) (List Fm.Binder)) ((((List.mapped ((Pair Fm.Name) Fm.Term)) bind) Fm.Binder) #pair ((pair #pair.self Fm.Binder) #pair.fst #pair.snd (((Fm.Binder.new eras) pair.fst) pair.snd)))))));
Fm.Parser.case : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "case ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Name)) Fm.Term) ((Parser.maybe Fm.Name) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Name) (Fm.Parser.spaces_text "as")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Name) Fm.Parser.spaces) # Fm.Parser.name1)))) #name !name = (((name #name.self Fm.Name) ((((((((((((((((expr #expr.self Fm.Name) #expr.name #expr.indx expr.name) #expr.name expr.name) (Fm.Name.read "self")) #expr.eras #expr.self #expr.name #expr.xtyp #expr.body (Fm.Name.read "self")) #expr.name #expr.body (Fm.Name.read "self")) #expr.func #expr.argm (Fm.Name.read "self")) #expr.name #expr.expr #expr.body (Fm.Name.read "self")) #expr.name #expr.expr #expr.body (Fm.Name.read "self")) #expr.done #expr.term #expr.type (Fm.Name.read "self")) #expr.name #expr.dref #expr.verb (Fm.Name.read "self")) #expr.path (Fm.Name.read "self")) #expr.natx (Fm.Name.read "self")) #expr.chrx (Fm.Name.read "self")) #expr.strx (Fm.Name.read "self")) #expr.path #expr.expr #expr.name #expr.with #expr.cses #expr.moti (Fm.Name.read "self"))) #name.value name.value); ((((((Monad.bind Parser) Parser.monad) (List Fm.Def)) Fm.Term) ((Parser.many Fm.Def) Fm.Parser.case.with)) #with ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "{")) # ((((((Monad.bind Parser) Parser.monad) (List ((Pair Fm.Name) Fm.Term))) Fm.Term) ((Parser.many ((Pair Fm.Name) Fm.Term)) Fm.Parser.case.case)) #cses !cses = ((((Map.from_list Fm.Name) Fm.Term) Fm.Name.to_bits) cses); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "}")) # ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Term)) Fm.Term) ((Parser.maybe Fm.Term) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text ":")) # Fm.Parser.term))) #moti !moti = (((moti #moti.self Fm.Term) (Fm.Term.hol Bits.nil)) #moti.value moti.value); ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((((Fm.Term.cse Bits.nil) expr) name) with) cses) moti)))))))))));
Fm.Parser.case.case : (Parser ((Pair Fm.Name) Fm.Term)) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) ((Pair Fm.Name) Fm.Term)) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) ((Pair Fm.Name) Fm.Term)) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) ((Pair Fm.Name) Fm.Term)) (Fm.Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) ((Pair Fm.Name) Fm.Term)) Fm.Parser.term) #term ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) ((Pair Fm.Name) Fm.Term)) ((Parser.maybe Unit) (Fm.Parser.spaces_text ","))) # ((((Monad.pure Parser) Parser.monad) ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) name) term)))))));
Fm.Parser.case.with : (Parser Fm.Def) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.spaces_text "with")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Def) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Def) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #type ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #term ((((Monad.pure Parser) Parser.monad) Fm.Def) ((((Fm.Def.new name) term) type) Bool.false)))))))));
Fm.Parser.char : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "\'")) # ((((((Monad.bind Parser) Parser.monad) Char) Fm.Term) Fm.Parser.char.single) #chrx ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.text "\'")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.chr chrx)))));
Fm.Parser.char.single : (Parser Char) = ((Parser.first_of Char) (((List.cons (Parser Char)) ((Parser.first_of Char) ((((List.mapped ((Pair String) Char)) Fm.escapes) (Parser Char)) #esc ((esc #esc.self (Parser Char)) #esc.fst #esc.snd ((((((Monad.bind Parser) Parser.monad) Unit) Char) (Parser.text esc.fst)) # ((((Monad.pure Parser) Parser.monad) Char) esc.snd)))))) (((List.cons (Parser Char)) Parser.one) (List.nil (Parser Char)))));
Fm.Parser.constructor : @(namespace:Fm.Name) (Parser Fm.Constructor) = #namespace ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Constructor) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Constructor) ((Parser.maybe (List Fm.Binder)) Fm.Parser.binder)) #args ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Constructor) ((Parser.maybe (List Fm.Binder)) ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.spaces_text "~")) # Fm.Parser.binder))) #inds !args = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) args); !inds = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) inds); ((((Monad.pure Parser) Parser.monad) Fm.Constructor) (((Fm.Constructor.new name) args) inds)))));
Fm.Parser.datatype : (Parser Fm.Datatype) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Datatype) (Fm.Parser.spaces_text "type ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Datatype) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Datatype) ((Parser.maybe (List Fm.Binder)) Fm.Parser.binder)) #pars ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Datatype) ((Parser.maybe (List Fm.Binder)) ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.spaces_text "~")) # Fm.Parser.binder))) #inds !pars = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) pars); !inds = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) inds); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Datatype) (Fm.Parser.spaces_text "{")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Constructor)) Fm.Datatype) ((Parser.many Fm.Constructor) ((Fm.Parser.item Fm.Constructor) (Fm.Parser.constructor name)))) #ctrs ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Datatype) (Fm.Parser.spaces_text "}")) # ((((Monad.pure Parser) Parser.monad) Fm.Datatype) ((((Fm.Datatype.new name) pars) inds) ctrs)))))))));
Fm.Parser.def : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "def ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Fm.Term) ((Parser.maybe Unit) (Fm.Parser.spaces_text ";"))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.def name) expr) #x body)))))))));
Fm.Parser.definition : (Parser Fm.Def) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Def) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Def) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) (List (List Fm.Binder))) Fm.Def) ((Parser.many (List Fm.Binder)) Fm.Parser.binder)) #args !args = ((List.flatten Fm.Binder) args); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #type ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #term !type = ((Fm.Parser.make_forall args) type); !term = ((Fm.Parser.make_lambda ((((List.mapped Fm.Binder) args) Fm.Name) #x ((x #x.self Fm.Name) #x.eras #x.name #x.term x.name))) term); !type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) type); !term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) term); ((((Monad.pure Parser) Parser.monad) Fm.Def) ((((Fm.Def.new name) term) type) Bool.false))))))));
Fm.Parser.do : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "do ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "{")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements name)) #term ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "}")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) term)))))));
Fm.Parser.do.statements : @(monad_name:Fm.Name) (Parser Fm.Term) = #monad_name ((Parser.first_of Fm.Term) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "var ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements monad_name)) #body !term = ((Fm.Term.app (Fm.Term.ref "Monad.bind")) (Fm.Term.ref monad_name)); !term = ((Fm.Term.app term) (Fm.Term.ref ((String.concat monad_name) ".monad"))); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) expr); !term = ((Fm.Term.app term) ((Fm.Term.lam name) #x body)); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "let ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements monad_name)) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.let name) expr) #x body)))))))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "return ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # !term = ((Fm.Term.app (Fm.Term.ref "Monad.pure")) (Fm.Term.ref monad_name)); !term = ((Fm.Term.app term) (Fm.Term.ref ((String.concat monad_name) ".monad"))); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) expr); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements monad_name)) #body !term = ((Fm.Term.app (Fm.Term.ref "Monad.bind")) (Fm.Term.ref monad_name)); !term = ((Fm.Term.app term) (Fm.Term.ref ((String.concat monad_name) ".monad"))); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) expr); !term = ((Fm.Term.app term) ((Fm.Term.lam "") #x body)); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) expr)))) (List.nil (Parser Fm.Term))))))));
Fm.Parser.file : (Parser Fm.Defs) = (Fm.Parser.file.go (Map.new Fm.Def));
Fm.Parser.file.go : @(defs:Fm.Defs) (Parser Fm.Defs) = #defs ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Def)) Fm.Defs) ((Parser.maybe Fm.Def) Fm.Parser.definition)) #def (((def #def.self (Parser Fm.Defs)) ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Datatype)) Fm.Defs) ((Parser.maybe Fm.Datatype) Fm.Parser.datatype)) #adt (((adt #adt.self (Parser Fm.Defs)) ((((Monad.pure Parser) Parser.monad) Fm.Defs) defs)) #adt.value ((adt.value #adt.value.self (Parser Fm.Defs)) #adt.value.name #adt.value.pars #adt.value.inds #adt.value.ctrs !term = (Fm.Datatype.build_term adt.value); !term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) term); !type = (Fm.Datatype.build_type adt.value); !type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) type); !defs = ((((Fm.set Fm.Def) adt.value.name) ((((Fm.Def.new adt.value.name) term) type) Bool.false)) defs); !defs = (((((List.fold Fm.Constructor) adt.value.ctrs) Fm.Defs) defs) #ctr #defs !typ_name = adt.value.name; !ctr_name = (String.flatten (((List.cons String) typ_name) (((List.cons Fm.Name) (Fm.Name.read ".")) (((List.cons Fm.Name) ((ctr #ctr.self Fm.Name) #ctr.name #ctr.args #ctr.inds ctr.name)) (List.nil Fm.Name))))); !ctr_term = ((Fm.Constructor.build_term adt.value) ctr); !ctr_term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) ctr_term); !ctr_type = ((Fm.Constructor.build_type adt.value) ctr); !ctr_type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) ctr_type); ((((Fm.set Fm.Def) ctr_name) ((((Fm.Def.new ctr_name) ctr_term) ctr_type) Bool.false)) defs)); (Fm.Parser.file.go defs))))) #def.value ((def.value #def.value.self (Parser Fm.Defs)) #def.value.name #def.value.term #def.value.type #def.value.done (Fm.Parser.file.go ((((Fm.set Fm.Def) def.value.name) def.value) defs)))));
Fm.Parser.forall : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #self ((((((Monad.bind Parser) Parser.monad) (List Fm.Binder)) Fm.Term) Fm.Parser.binder) #bind ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Fm.Term) ((Parser.maybe Unit) (Parser.spaces_text "->"))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body !term = (((((List.fold Fm.Binder) bind) Fm.Term) body) #x #t ((x #x.self Fm.Term) #x.eras #x.name #x.term (((((Fm.Term.all x.eras) "") x.name) x.term) #s #x t))); ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((((((((((((((term #term.self Fm.Term) #term.name #term.indx term) #term.name term) term) #term.eras #term.self #term.name #term.xtyp #term.body (((((Fm.Term.all term.eras) self) term.name) term.xtyp) term.body)) #term.name #term.body term) #term.func #term.argm term) #term.name #term.expr #term.body term) #term.name #term.expr #term.body term) #term.done #term.term #term.type term) #term.name #term.dref #term.verb term) #term.path term) #term.natx term) #term.chrx term) #term.strx term) #term.path #term.expr #term.name #term.with #term.cses #term.moti term)))))));
Fm.Parser.forin : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "for ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #elem ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "in")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #list ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "with")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #loop !term = (Fm.Term.ref "List.for"); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) list); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.ref name)); !lamb = ((Fm.Term.lam elem) #i ((Fm.Term.lam name) #x loop)); !term = ((Fm.Term.app term) lamb); !term = (((Fm.Term.let name) term) #x (Fm.Term.ref name)); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))))))));
Fm.Parser.goal : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "?")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) (List Bits)) Fm.Term) ((Parser.many Bits) ((((((Monad.bind Parser) Parser.monad) Unit) Bits) (Fm.Parser.spaces_text "-")) # ((((((Monad.bind Parser) Parser.monad) Nat) Bits) Parser.nat) #nat !bits = (Bits.reverse (Bits.tail (Bits.reverse (Nat.to_bits nat)))); ((((Monad.pure Parser) Parser.monad) Bits) bits))))) #dref ((((((Monad.bind Parser) Parser.monad) Bool) Fm.Term) ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Bool) ((Parser.maybe Unit) (Parser.text "-"))) #verb ((((Monad.pure Parser) Parser.monad) Bool) ((Maybe.to_bool Unit) verb)))) #verb ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.gol name) dref) verb))))));
Fm.Parser.hole : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "_")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.hol Bits.nil)));
Fm.Parser.if : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "if ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #cond ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "then")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #tcse ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "else")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #fcse !term = cond; !term = ((Fm.Term.app term) ((Fm.Term.lam "") #x (Fm.Term.hol Bits.nil))); !term = ((Fm.Term.app term) tcse); !term = ((Fm.Term.app term) fcse); ((((Monad.pure Parser) Parser.monad) Fm.Term) term)))))));
Fm.Parser.item : %(V:*) @(parser:(Parser V)) (Parser V) = #V #parser ((((((Monad.bind Parser) Parser.monad) (List Unit)) V) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) V) V) parser) #value ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) V) ((Parser.maybe Unit) (Fm.Parser.spaces_text ","))) # ((((Monad.pure Parser) Parser.monad) V) value))));
Fm.Parser.lambda : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.spaces_text "(")) (((List.cons (Parser Unit)) (Parser.spaces_text "<")) (List.nil (Parser Unit)))))) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Name)) Fm.Term) ((Parser.many1 Fm.Name) ((Fm.Parser.item Fm.Name) Fm.Parser.name1))) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text ")")) (((List.cons (Parser Unit)) (Parser.text ">")) (List.nil (Parser Unit)))))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) ((Fm.Parser.make_lambda name) body))))));
Fm.Parser.let : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "let ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Fm.Term) ((Parser.maybe Unit) (Fm.Parser.spaces_text ";"))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.let name) expr) #x body)))))))));
Fm.Parser.letforin : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "let ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "for ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #elem ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "in")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #list ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #loop ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body !term = (Fm.Term.ref "List.for"); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) list); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.ref name)); !lamb = ((Fm.Term.lam elem) #i ((Fm.Term.lam name) #x loop)); !term = ((Fm.Term.app term) lamb); !term = (((Fm.Term.let name) term) #x body); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))))))))));
Fm.Parser.letter : (Parser Fm.Letter) = #code (((code #code.self (Parser.Reply Fm.Letter)) (((Parser.Reply.error Fm.Letter) code) "Unexpected eof.")) #code.head #code.tail ((((Fm.Name.is_letter code.head) # (Parser.Reply Fm.Letter)) (((Parser.Reply.value Char) code.tail) code.head)) (((Parser.Reply.error Fm.Letter) code) "Expected letter.")));
Fm.Parser.list : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "[")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Term)) Fm.Term) ((Parser.many Fm.Term) ((Fm.Parser.item Fm.Term) Fm.Parser.term))) #vals ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "]")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) (((((List.fold Fm.Term) vals) Fm.Term) ((Fm.Term.app (Fm.Term.ref (Fm.Name.read "List.nil"))) (Fm.Term.hol Bits.nil))) #x #xs !term = (Fm.Term.ref (Fm.Name.read "List.cons")); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) x); !term = ((Fm.Term.app term) xs); term)))));
Fm.Parser.make_forall : @(binds:(List Fm.Binder)) @(body:Fm.Term) Fm.Term = #binds #body (((binds #binds.self Fm.Term) body) #binds.head #binds.tail ((binds.head #binds.head.self Fm.Term) #binds.head.eras #binds.head.name #binds.head.term $all_eras = binds.head.eras; $all_self = ""; $all_name = binds.head.name; $all_xtyp = binds.head.term; $all_body = #s #x ((Fm.Parser.make_forall binds.tail) body); (((((Fm.Term.all all_eras) all_self) all_name) all_xtyp) all_body)));
Fm.Parser.make_lambda : @(names:(List Fm.Name)) @(body:Fm.Term) Fm.Term = #names #body (((names #names.self Fm.Term) body) #names.head #names.tail ((Fm.Term.lam names.head) #x ((Fm.Parser.make_lambda names.tail) body)));
Fm.Parser.name : (Parser Fm.Name) = ((((((Monad.bind Parser) Parser.monad) (List Char)) Fm.Name) ((Parser.many Fm.Letter) Fm.Parser.letter)) #chrs ((((Monad.pure Parser) Parser.monad) Fm.Name) (((((List.fold Char) chrs) String) String.nil) String.cons)));
Fm.Parser.name1 : (Parser Fm.Name) = ((((((Monad.bind Parser) Parser.monad) (List Char)) Fm.Name) ((Parser.many1 Fm.Letter) Fm.Parser.letter)) #chrs ((((Monad.pure Parser) Parser.monad) Fm.Name) (((((List.fold Char) chrs) String) String.nil) String.cons)));
Fm.Parser.name_term : (Parser ((Pair Fm.Name) Fm.Term)) = ((((((Monad.bind Parser) Parser.monad) Fm.Name) ((Pair Fm.Name) Fm.Term)) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) Unit) ((Pair Fm.Name) Fm.Term)) (Fm.Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) ((Pair Fm.Name) Fm.Term)) Fm.Parser.term) #type ((((Monad.pure Parser) Parser.monad) ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) name) type)))));
Fm.Parser.nat : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Parser.nat) #natx ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.nat natx))));
Fm.Parser.pair : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "{")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #val0 ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ",")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #val1 ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "}")) # !term = (Fm.Term.ref "Pair.new"); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) val0); !term = ((Fm.Term.app term) val1); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))));
Fm.Parser.parenthesis : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "(")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #term ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text ")")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) term))));
Fm.Parser.reference : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.ref name))));
Fm.Parser.spaces : (Parser (List Unit)) = ((Parser.many Unit) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text " ")) (((List.cons (Parser Unit)) (Parser.text "\u{A}")) (((List.cons (Parser Unit)) ((((((Monad.bind Parser) Parser.monad) Unit) Unit) (Parser.text "//")) # ((((((Monad.bind Parser) Parser.monad) (List Char)) Unit) ((Parser.many Char) (Parser.char_if #chr (Bool.not ((U16.eql chr) '\u{A}'))))) # (Parser.text "\u{A}")))) (List.nil (Parser Unit)))))));
Fm.Parser.spaces_text : @(text:String) (Parser Unit) = #text ((((((Monad.bind Parser) Parser.monad) (List Unit)) Unit) Fm.Parser.spaces) # (Parser.text text));
Fm.Parser.string : (Parser Fm.Term) = !quot = ((String.cons '\"') String.nil); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text quot)) # ((((((Monad.bind Parser) Parser.monad) (List Char)) Fm.Term) (((Parser.until Char) (Parser.text quot)) Fm.Parser.char.single)) #chrs ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.text quot)) # !strx = (((((List.fold Char) chrs) String) String.nil) String.cons); ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.str strx)))));
Fm.Parser.suffix : @(term:Fm.Term) (Parser Fm.Term) = #term #code !suffix_parser = ((Parser.first_of Fm.Term) (((List.cons (Parser Fm.Term)) (Fm.Parser.application term)) (((List.cons (Parser Fm.Term)) (Fm.Parser.arrow term)) (((List.cons (Parser Fm.Term)) (Fm.Parser.annotation term)) (List.nil (Parser Fm.Term)))))); ((((suffix_parser code) #suffix_parsed.self (Parser.Reply Fm.Term)) #suffix_parsed.code #suffix_parsed.err (((Parser.Reply.value Fm.Term) code) term)) #suffix_parsed.code #suffix_parsed.val ((Fm.Parser.suffix suffix_parsed.val) suffix_parsed.code));
Fm.Parser.term : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) ((Parser.first_of Fm.Term) (((List.cons (Parser Fm.Term)) Fm.Parser.type) (((List.cons (Parser Fm.Term)) Fm.Parser.forall) (((List.cons (Parser Fm.Term)) Fm.Parser.lambda) (((List.cons (Parser Fm.Term)) Fm.Parser.parenthesis) (((List.cons (Parser Fm.Term)) Fm.Parser.letforin) (((List.cons (Parser Fm.Term)) Fm.Parser.let) (((List.cons (Parser Fm.Term)) Fm.Parser.def) (((List.cons (Parser Fm.Term)) Fm.Parser.if) (((List.cons (Parser Fm.Term)) Fm.Parser.char) (((List.cons (Parser Fm.Term)) Fm.Parser.string) (((List.cons (Parser Fm.Term)) Fm.Parser.pair) (((List.cons (Parser Fm.Term)) Fm.Parser.list) (((List.cons (Parser Fm.Term)) Fm.Parser.forin) (((List.cons (Parser Fm.Term)) Fm.Parser.do) (((List.cons (Parser Fm.Term)) Fm.Parser.case) (((List.cons (Parser Fm.Term)) Fm.Parser.goal) (((List.cons (Parser Fm.Term)) Fm.Parser.hole) (((List.cons (Parser Fm.Term)) Fm.Parser.nat) (((List.cons (Parser Fm.Term)) Fm.Parser.reference) (List.nil (Parser Fm.Term))))))))))))))))))))))) #term (Fm.Parser.suffix term));
Fm.Parser.type : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "Type")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) Fm.Term.typ));
Fm.Path : * = @(:Bits) Bits;
Fm.Path.nil : Fm.Path = #x x;
Fm.Path.to_bits : @(path:Fm.Path) Bits = #path (path Bits.nil);
Fm.Path.0 : @(path:Fm.Path) Fm.Path = #path #x (path (Bits.0 x));
Fm.Path.1 : @(path:Fm.Path) Fm.Path = #path #x (path (Bits.1 x));
Fm.Prim : * = %Fm.Prim.Self(P:@(self:Fm.Prim) *) @(bool:(P Fm.Prim.bool)) @(nat:(P Fm.Prim.nat)) @(u16:(P Fm.Prim.u16)) @(string:(P Fm.Prim.string)) @(data:@(ctrs:(List Nat)) (P (Fm.Prim.data ctrs))) (P Fm.Prim.Self);
Fm.Prim.bool : Fm.Prim = #P #bool #nat #u16 #string #data bool;
Fm.Prim.ctrs : @(prim:Fm.Prim) (List Nat) = #prim ((((((prim #prim.self (List Nat)) (((List.cons Nat) +0) (((List.cons Nat) +0) (List.nil Nat)))) (((List.cons Nat) +0) (((List.cons Nat) +2) (List.nil Nat)))) (((List.cons Nat) +1) (List.nil Nat))) (((List.cons Nat) +0) (((List.cons Nat) +2) (List.nil Nat)))) #prim.ctrs prim.ctrs);
Fm.Prim.data : @(ctrs:(List Nat)) Fm.Prim = #ctrs #P #bool #nat #u16 #string #data (data ctrs);
Fm.Prim.name : @(prim:Fm.Prim) String = #prim ((((((prim #prim.self String) "bool") "nat") "u16") "string") #prim.ctrs "data");
Fm.Prim.nat : Fm.Prim = #P #bool #nat #u16 #string #data nat;
Fm.Prim.string : Fm.Prim = #P #bool #nat #u16 #string #data string;
Fm.Prim.u16 : Fm.Prim = #P #bool #nat #u16 #string #data u16;
Fm.Term : * = %Fm.Term.Self(P:@(self:Fm.Term) *) @(var:@(name:Fm.Name) @(indx:Nat) (P ((Fm.Term.var name) indx))) @(ref:@(name:Fm.Name) (P (Fm.Term.ref name))) @(typ:(P Fm.Term.typ)) @(all:@(eras:Bool) @(self:Fm.Name) @(name:Fm.Name) @(xtyp:Fm.Term) @(body:@(:Fm.Term) @(:Fm.Term) Fm.Term) (P (((((Fm.Term.all eras) self) name) xtyp) body))) @(lam:@(name:Fm.Name) @(body:@(:Fm.Term) Fm.Term) (P ((Fm.Term.lam name) body))) @(app:@(func:Fm.Term) @(argm:Fm.Term) (P ((Fm.Term.app func) argm))) @(let:@(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) (P (((Fm.Term.let name) expr) body))) @(def:@(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) (P (((Fm.Term.def name) expr) body))) @(ann:@(done:Bool) @(term:Fm.Term) @(type:Fm.Term) (P (((Fm.Term.ann done) term) type))) @(gol:@(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) (P (((Fm.Term.gol name) dref) verb))) @(hol:@(path:Bits) (P (Fm.Term.hol path))) @(nat:@(natx:Nat) (P (Fm.Term.nat natx))) @(chr:@(chrx:Char) (P (Fm.Term.chr chrx))) @(str:@(strx:String) (P (Fm.Term.str strx))) @(cse:@(path:Bits) @(expr:Fm.Term) @(name:Fm.Name) @(with:(List Fm.Def)) @(cses:(Map Fm.Term)) @(moti:Fm.Term) (P ((((((Fm.Term.cse path) expr) name) with) cses) moti))) (P Fm.Term.Self);
Fm.Term.all : @(eras:Bool) @(self:Fm.Name) @(name:Fm.Name) @(xtyp:Fm.Term) @(body:@(:Fm.Term) @(:Fm.Term) Fm.Term) Fm.Term = #eras #self #name #xtyp #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((((all eras) self) name) xtyp) body);
Fm.Term.ann : @(done:Bool) @(term:Fm.Term) @(type:Fm.Term) Fm.Term = #done #term #type #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((ann done) term) type);
Fm.Term.app : @(func:Fm.Term) @(argm:Fm.Term) Fm.Term = #func #argm #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((app func) argm);
Fm.Term.bind : @(vars:Fm.Context) @(path:Fm.Path) @(term:Fm.Term) Fm.Term = #vars #path #term ((((((((((((((((term #term.self Fm.Term) #term.name #term.indx ((((((List.at_last ((Pair Fm.Name) Fm.Term)) term.indx) vars) #got.self Fm.Term) ((Fm.Term.var term.name) term.indx)) #got.value (((Pair.snd Fm.Name) Fm.Term) got.value))) #term.name (((((Fm.Context.find term.name) vars) #got.self Fm.Term) (Fm.Term.ref term.name)) #got.value got.value)) Fm.Term.typ) #term.eras #term.self #term.name #term.xtyp #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $xtyp = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.xtyp); $body = #s #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.self) s)) vars))) (Fm.Path.1 path)) ((term.body ((Fm.Term.var term.self) vlen)) ((Fm.Term.var term.name) (Nat.succ vlen)))); (((((Fm.Term.all term.eras) term.self) term.name) xtyp) body)) #term.name #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $body = #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) vars)) (Fm.Path.0 path)) (term.body ((Fm.Term.var term.name) vlen))); ((Fm.Term.lam term.name) body)) #term.func #term.argm $func = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.func); $argm = (((Fm.Term.bind vars) (Fm.Path.1 path)) term.argm); ((Fm.Term.app func) argm)) #term.name #term.expr #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $expr = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.expr); $body = #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) vars)) (Fm.Path.1 path)) (term.body ((Fm.Term.var term.name) vlen))); (((Fm.Term.let term.name) expr) body)) #term.name #term.expr #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $expr = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.expr); $body = #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) vars)) (Fm.Path.1 path)) (term.body ((Fm.Term.var term.name) vlen))); (((Fm.Term.def term.name) expr) body)) #term.done #term.term #term.type $term = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.term); $type = (((Fm.Term.bind vars) (Fm.Path.1 path)) term.type); (((Fm.Term.ann term.done) term) type)) #term.name #term.dref #term.verb (((Fm.Term.gol term.name) term.dref) term.verb)) #term.path (Fm.Term.hol (Fm.Path.to_bits path))) #term.natx (Fm.Term.nat term.natx)) #term.chrx (Fm.Term.chr term.chrx)) #term.strx (Fm.Term.str term.strx)) #term.path #term.expr #term.name #term.with #term.cses #term.moti !expr = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.expr); !name = term.name; !with = term.with; !cses = term.cses; !moti = term.moti; ((((((Fm.Term.cse (Fm.Path.to_bits path)) expr) name) with) cses) moti));
Fm.Term.check : @(term:Fm.Term) @(type:(Maybe Fm.Term)) @(defs:Fm.Defs) @(ctx:Fm.Context) @(path:Fm.MPath) (Fm.Check Fm.Term) = #term #type #defs #ctx #path ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) ((((((((((((((((term #term.self (Fm.Check Fm.Term)) #term.name #term.indx ((((((List.at_last ((Pair Fm.Name) Fm.Term)) term.indx) ctx) #got.self (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (Fm.Error.undefined_reference term.name)) (List.nil Fm.Error)))) #got.value ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) ((got.value #got.value.self Fm.Term) #got.value.fst #got.value.snd got.value.snd)))) #term.name ((((((Fm.get Fm.Def) term.name) defs) #got.self (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (Fm.Error.undefined_reference term.name)) (List.nil Fm.Error)))) #got.value ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) ((got.value #got.value.self Fm.Term) #got.value.name #got.value.term #got.value.type #got.value.done got.value.type)))) ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term.typ)) #term.eras #term.self #term.name #term.xtyp #term.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); !self_var = ((Fm.Term.var term.self) ctx_size); !body_var = ((Fm.Term.var term.name) (Nat.succ ctx_size)); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) term.xtyp)) (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.self) term)) ctx)); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.xtyp) ((Maybe.some Fm.Term) Fm.Term.typ)) defs) ctx) (Fm.MPath.0 path))) # ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check ((term.body self_var) body_var)) ((Maybe.some Fm.Term) Fm.Term.typ)) defs) body_ctx) (Fm.MPath.1 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term.typ)))) #term.name #term.body (((type #type.self (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((Fm.Error.cant_infer term) ctx)) (List.nil Fm.Error)))) #type.value !typv = ((Fm.Term.reduce type.value) defs); ((((((((((((((((typv #typv.self (Fm.Check Fm.Term)) #typv.name #typv.indx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.name !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.eras #typv.self #typv.name #typv.xtyp #typv.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); !self_var = term; !body_var = ((Fm.Term.var term.name) ctx_size); !body_typ = ((typv.body self_var) body_var); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) typv.xtyp)) ctx); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check (term.body body_var)) ((Maybe.some Fm.Term) body_typ)) defs) body_ctx) (Fm.MPath.0 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) type.value))) #typv.name #typv.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.func #typv.argm !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.name #typv.expr #typv.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.name #typv.expr #typv.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.done #typv.term #typv.type !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.name #typv.dref #typv.verb !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.path !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.natx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.chrx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.strx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.path #typv.expr #typv.name #typv.with #typv.cses #typv.moti !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))))) #term.func #term.argm ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.func) (Maybe.none Fm.Term)) defs) ctx) (Fm.MPath.0 path))) #func_typ !func_typ = ((Fm.Term.reduce func_typ) defs); ((((((((((((((((func_typ #func_typ.self (Fm.Check Fm.Term)) #func_typ.name #func_typ.indx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.name !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.eras #func_typ.self #func_typ.name #func_typ.xtyp #func_typ.body ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.argm) ((Maybe.some Fm.Term) func_typ.xtyp)) defs) ctx) (Fm.MPath.1 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) ((func_typ.body term.func) term.argm)))) #func_typ.name #func_typ.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.func #func_typ.argm !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.name #func_typ.expr #func_typ.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.name #func_typ.expr #func_typ.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.done #func_typ.term #func_typ.type !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.name #func_typ.dref #func_typ.verb !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.path !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.natx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.chrx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.strx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.path #func_typ.expr #func_typ.name #func_typ.with #func_typ.cses #func_typ.moti !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))))) #term.name #term.expr #term.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.expr) (Maybe.none Fm.Term)) defs) ctx) (Fm.MPath.0 path))) #expr_typ !body_val = (term.body ((Fm.Term.var term.name) ctx_size)); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) expr_typ)) ctx); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check body_val) type) defs) body_ctx) (Fm.MPath.1 path))) #body_typ ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) body_typ)))) #term.name #term.expr #term.body (((((Fm.Term.check (term.body term.expr)) type) defs) ctx) path)) #term.done #term.term #term.type (((term.done # (Fm.Check Fm.Term)) ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) term.type)) ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.term) ((Maybe.some Fm.Term) term.type)) defs) ctx) (Fm.MPath.0 path))) # ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.type) ((Maybe.some Fm.Term) Fm.Term.typ)) defs) ctx) (Fm.MPath.1 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) term.type))))) #term.name #term.dref #term.verb (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((((Fm.Error.show_goal term.name) term.dref) term.verb) type) ctx)) (List.nil Fm.Error)))) #term.path (((Fm.Check.result Fm.Term) type) (List.nil Fm.Error))) #term.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) (Fm.Term.ref "Nat"))) #term.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) (Fm.Term.ref "Char"))) #term.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) (Fm.Term.ref "String"))) #term.path #term.expr #term.name #term.with #term.cses #term.moti !expr = term.expr; ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check expr) (Maybe.none Fm.Term)) defs) ctx) (Fm.MPath.0 path))) #etyp !dsug = ((((((((Fm.Term.desugar_cse term.expr) term.name) term.with) term.cses) term.moti) etyp) defs) ctx); (((dsug #dsug.self (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((Fm.Error.cant_infer term) ctx)) (List.nil Fm.Error)))) #dsug.value (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((Fm.Error.patch (Fm.MPath.to_bits path)) dsug.value)) (List.nil Fm.Error))))))) #infr (((type #type.self (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) infr)) (List.nil Fm.Error))) #type.value ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Fm.Term) (((((Fm.Term.equal type.value) infr) defs) ((List.length ((Pair Fm.Name) Fm.Term)) ctx)) Set.new)) #eqls (((eqls # (Fm.Check Fm.Term)) ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) type.value)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch (((Either.right String) Fm.Term) type.value)) (((Either.right String) Fm.Term) infr)) ctx)) (List.nil Fm.Error)))))));
Fm.Term.chr : @(chrx:Char) Fm.Term = #chrx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (chr chrx);
Fm.Term.core : @(term:Fm.Term) String = #term ((((((((((((((((term #term.self String) #term.name #term.indx (Fm.Name.show term.name)) #term.name (Fm.Name.show term.name)) "*") #term.eras #term.self #term.name #term.xtyp #term.body !eras = term.eras; !init = (((eras # String) "%") "@"); !self = (Fm.Name.show term.self); !name = (Fm.Name.show term.name); !xtyp = (Fm.Term.core term.xtyp); !body = (Fm.Term.core ((term.body ((Fm.Term.var term.self) +0)) ((Fm.Term.var term.name) +0))); (String.flatten (((List.cons String) init) (((List.cons String) self) (((List.cons String) "(") (((List.cons String) name) (((List.cons String) ":") (((List.cons String) xtyp) (((List.cons String) ") ") (((List.cons String) body) (List.nil String))))))))))) #term.name #term.body !name = (Fm.Name.show term.name); !body = (Fm.Term.core (term.body ((Fm.Term.var term.name) +0))); (String.flatten (((List.cons String) "#") (((List.cons String) name) (((List.cons String) " ") (((List.cons String) body) (List.nil String))))))) #term.func #term.argm !func = (Fm.Term.core term.func); !argm = (Fm.Term.core term.argm); (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) " ") (((List.cons String) argm) (((List.cons String) ")") (List.nil String)))))))) #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = (Fm.Term.core term.expr); !body = (Fm.Term.core (term.body ((Fm.Term.var term.name) +0))); (String.flatten (((List.cons String) "!") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = (Fm.Term.core term.expr); !body = (Fm.Term.core (term.body ((Fm.Term.var term.name) +0))); (String.flatten (((List.cons String) "$") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.done #term.term #term.type !term = (Fm.Term.core term.term); !type = (Fm.Term.core term.type); (String.flatten (((List.cons String) "{") (((List.cons String) term) (((List.cons String) ":") (((List.cons String) type) (((List.cons String) "}") (List.nil String)))))))) #term.name #term.dref #term.verb "<ERROR>") #term.path "<ERROR>") #term.natx (String.flatten (((List.cons String) "+") (((List.cons String) (Nat.show term.natx)) (List.nil String))))) #term.chrx (String.flatten (((List.cons String) "\'") (((List.cons String) (Fm.escape.char term.chrx)) (((List.cons String) "\'") (List.nil String)))))) #term.strx (String.flatten (((List.cons String) "\"") (((List.cons String) (Fm.escape term.strx)) (((List.cons String) "\"") (List.nil String)))))) #term.path #term.expr #term.name #term.with #term.cses #term.moti "<ERROR>");
Fm.Term.cse : @(path:Bits) @(expr:Fm.Term) @(name:Fm.Name) @(with:(List Fm.Def)) @(cses:(Map Fm.Term)) @(moti:Fm.Term) Fm.Term = #path #expr #name #with #cses #moti #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((((((cse path) expr) name) with) cses) moti);
Fm.Term.def : @(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) Fm.Term = #name #expr #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((def name) expr) body);
Fm.Term.desugar_app : @(func:Fm.Term) @(args:(Map Fm.Term)) @(type:Fm.Term) @(defs:Fm.Defs) Fm.Term = #func #args #type #defs ((((((((((((((((((Fm.Term.reduce type) defs) #type.self Fm.Term) #type.name #type.indx func) #type.name func) func) #type.eras #type.self #type.name #type.xtyp #type.body ((((((Fm.get Fm.Term) type.name) args) #got.self Fm.Term) func) #got.value !func = ((Fm.Term.app func) got.value); !type = ((type.body ((Fm.Term.var type.self) +0)) ((Fm.Term.var type.name) +0)); ((((Fm.Term.desugar_app func) args) type) defs))) #type.name #type.body func) #type.func #type.argm func) #type.name #type.expr #type.body func) #type.name #type.expr #type.body func) #type.done #type.term #type.type func) #type.name #type.dref #type.verb func) #type.path func) #type.natx func) #type.chrx func) #type.strx func) #type.path #type.expr #type.name #type.with #type.cses #type.moti func);
Fm.Term.desugar_cse : @(expr:Fm.Term) @(name:Fm.Name) @(with:(List Fm.Def)) @(cses:(Map Fm.Term)) @(moti:Fm.Term) @(type:Fm.Term) @(defs:Fm.Defs) @(ctxt:Fm.Context) (Maybe Fm.Term) = #expr #name #with #cses #moti #type #defs #ctxt ((((((((((((((((((Fm.Term.reduce type) defs) #type.self (Maybe Fm.Term)) #type.name #type.indx (Maybe.none Fm.Term)) #type.name (Maybe.none Fm.Term)) (Maybe.none Fm.Term)) #type.eras #type.self #type.name #type.xtyp #type.body !moti = ((Fm.Term.desugar_cse.motive with) moti); !argm = (((((Fm.Term.desugar_cse.argument name) (List.nil Fm.Def)) type.xtyp) moti) defs); !expr = ((Fm.Term.app expr) argm); !type = ((type.body ((Fm.Term.var type.self) +0)) ((Fm.Term.var type.name) +0)); ((Maybe.some Fm.Term) (((((((Fm.Term.desugar_cse.cases expr) name) with) cses) type) defs) ctxt))) #type.name #type.body (Maybe.none Fm.Term)) #type.func #type.argm (Maybe.none Fm.Term)) #type.name #type.expr #type.body (Maybe.none Fm.Term)) #type.name #type.expr #type.body (Maybe.none Fm.Term)) #type.done #type.term #type.type (Maybe.none Fm.Term)) #type.name #type.dref #type.verb (Maybe.none Fm.Term)) #type.path (Maybe.none Fm.Term)) #type.natx (Maybe.none Fm.Term)) #type.chrx (Maybe.none Fm.Term)) #type.strx (Maybe.none Fm.Term)) #type.path #type.expr #type.name #type.with #type.cses #type.moti (Maybe.none Fm.Term));
Fm.Term.desugar_cse.argument : @(name:Fm.Name) @(wyth:(List Fm.Def)) @(type:Fm.Term) @(body:Fm.Term) @(defs:Fm.Defs) Fm.Term = #name #wyth #type #body #defs ((((((((((((((((((Fm.Term.reduce type) defs) #type.self Fm.Term) #type.name #type.indx (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.name (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.eras #type.self #type.name #type.xtyp #type.body $type = ((type.body ((Fm.Term.var type.self) +0)) ((Fm.Term.var type.name) +0)); $lam_name = (String.flatten (((List.cons String) name) (((List.cons Fm.Name) (Fm.Name.read ".")) (((List.cons Fm.Name) type.name) (List.nil Fm.Name))))); $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth) type) body) defs); ((Fm.Term.lam lam_name) lam_body)) #type.name #type.body (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.func #type.argm (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.name #type.expr #type.body (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.name #type.expr #type.body (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.done #type.term #type.type (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.name #type.dref #type.verb (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.path (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.natx (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.chrx (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.strx (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.path #type.expr #type.name #type.with #type.cses #type.moti (((wyth #wyth.self Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body))));
Fm.Term.desugar_cse.cases : @(expr:Fm.Term) @(name:Fm.Name) @(wyth:(List Fm.Def)) @(cses:(Map Fm.Term)) @(type:Fm.Term) @(defs:Fm.Defs) @(ctxt:Fm.Context) Fm.Term = #expr #name #wyth #cses #type #defs #ctxt ((((((((((((((((((Fm.Term.reduce type) defs) #type.self Fm.Term) #type.name #type.indx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.name !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.eras #type.self #type.name #type.xtyp #type.body !got = (((Maybe.or Fm.Term) (((Fm.get Fm.Term) type.name) cses)) (((Fm.get Fm.Term) "_") cses)); (((got #got.self Fm.Term) !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done ((Fm.Term.app expr) def.term))); expr) #got.value !argm = (((((Fm.Term.desugar_cse.argument name) wyth) type.xtyp) got.value) defs); !expr = ((Fm.Term.app expr) argm); !type = ((type.body ((Fm.Term.var type.self) +0)) ((Fm.Term.var type.name) +0)); (((((((Fm.Term.desugar_cse.cases expr) name) wyth) cses) type) defs) ctxt))) #type.name #type.body !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.func #type.argm !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.name #type.expr #type.body !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.name #type.expr #type.body !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.done #type.term #type.type !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.name #type.dref #type.verb !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.path !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.natx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.chrx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.strx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr) #type.path #type.expr #type.name #type.with #type.cses #type.moti !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def.self Fm.Term) #def.name #def.term #def.type #def.done def.term))); expr);
Fm.Term.desugar_cse.motive : @(wyth:(List Fm.Def)) @(moti:Fm.Term) Fm.Term = #wyth #moti (((wyth #wyth.self Fm.Term) moti) #wyth.head #wyth.tail ((wyth.head #wyth.head.self Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.done $all_name = wyth.head.name; $all_xtyp = wyth.head.type; $all_body = #s #x ((Fm.Term.desugar_cse.motive wyth.tail) moti); (((((Fm.Term.all Bool.false) "") all_name) all_xtyp) all_body)));
Fm.Term.equal : @(a:Fm.Term) @(b:Fm.Term) @(defs:Fm.Defs) @(lv:Nat) @(seen:Set) (Fm.Check Bool) = #a #b #defs #lv #seen !a1 = ((Fm.Term.reduce a) defs); !b1 = ((Fm.Term.reduce b) defs); !ah = ((Fm.Term.serialize a1) lv); !bh = ((Fm.Term.serialize b1) lv); !id = ((Bits.concat ah) bh); (((((Bool.or ((Bits.eql ah) bh)) ((Set.has id) seen)) # (Fm.Check Bool)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.true)) ((((((((((((((((a1 #a1.self (Fm.Check Bool)) #a1.name #a1.indx ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.eras #a1.self #a1.name #a1.xtyp #a1.body ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body !seen = ((Set.set id) seen); !a1_body = ((a1.body ((Fm.Term.var a1.self) lv)) ((Fm.Term.var a1.name) (Nat.succ lv))); !b1_body = ((b1.body ((Fm.Term.var b1.self) lv)) ((Fm.Term.var b1.name) (Nat.succ lv))); !eq_self = ((String.eql a1.self) b1.self); !eq_eras = ((Bool.eql a1.eras) b1.eras); (((((Bool.and eq_self) eq_eras) # (Fm.Check Bool)) ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.xtyp) b1.xtyp) defs) lv) seen)) #eq_type ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1_body) b1_body) defs) (Nat.succ (Nat.succ lv))) seen)) #eq_body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) ((Bool.and eq_type) eq_body))))) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name #a1.body ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body !seen = ((Set.set id) seen); !a1_body = (a1.body ((Fm.Term.var a1.name) lv)); !b1_body = (b1.body ((Fm.Term.var b1.name) lv)); ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1_body) b1_body) defs) (Nat.succ lv)) seen)) #eq_body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) eq_body))) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.func #a1.argm ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm !seen = ((Set.set id) seen); ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.func) b1.func) defs) lv) seen)) #eq_func ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.argm) b1.argm) defs) lv) seen)) #eq_argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) ((Bool.and eq_func) eq_argm))))) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name #a1.expr #a1.body ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body !seen = ((Set.set id) seen); !a1_body = (a1.body ((Fm.Term.var a1.name) lv)); !b1_body = (b1.body ((Fm.Term.var b1.name) lv)); ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.expr) b1.expr) defs) lv) seen)) #eq_expr ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1_body) b1_body) defs) (Nat.succ lv)) seen)) #eq_body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) ((Bool.and eq_expr) eq_body))))) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name #a1.expr #a1.body ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.done #a1.term #a1.type ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name #a1.dref #a1.verb ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.path ((Fm.Term.equal.patch a1.path) b)) #a1.natx ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.chrx ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.strx ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.path #a1.expr #a1.name #a1.with #a1.cses #a1.moti ((((((((((((((((b1 #b1.self (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))));
Fm.Term.equal.patch : @(path:Bits) @(term:Fm.Term) (Fm.Check Bool) = #path #term (((Fm.Check.result Bool) ((Maybe.some Bool) Bool.true)) (((List.cons Fm.Error) ((Fm.Error.patch path) ((Fm.Term.normalize term) (Map.new Fm.Def)))) (List.nil Fm.Error)));
Fm.Term.expand : @(dref:(List Bits)) @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #dref #term #defs !term = ((Fm.Term.normalize term) (Map.new Fm.Def)); !term = (((((List.for Bits) dref) Fm.Term) term) #path #term ((Fm.Term.normalize (((Fm.Term.expand_at path) term) defs)) (Map.new Fm.Def))); term;
Fm.Term.expand_at : @(path:Bits) @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #path #term #defs (((Fm.Term.patch_at path) term) #term ((((((((((((((((term #term.self Fm.Term) #term.name #term.indx term) #term.name ((((((Fm.get Fm.Def) term.name) defs) #got.self Fm.Term) (Fm.Term.ref term.name)) #got.value ((got.value #got.value.self Fm.Term) #got.value.name #got.value.term #got.value.type #got.value.done got.value.term))) term) #term.eras #term.self #term.name #term.xtyp #term.body term) #term.name #term.body term) #term.func #term.argm term) #term.name #term.expr #term.body term) #term.name #term.expr #term.body term) #term.done #term.term #term.type term) #term.name #term.dref #term.verb term) #term.path term) #term.natx term) #term.chrx term) #term.strx term) #term.path #term.expr #term.name #term.with #term.cses #term.moti term));
Fm.Term.gol : @(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) Fm.Term = #name #dref #verb #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((gol name) dref) verb);
Fm.Term.hol : @(path:Bits) Fm.Term = #path #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (hol path);
Fm.Term.lam : @(name:Fm.Name) @(body:@(:Fm.Term) Fm.Term) Fm.Term = #name #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((lam name) body);
Fm.Term.let : @(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) Fm.Term = #name #expr #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((let name) expr) body);
Fm.Term.nat : @(natx:Nat) Fm.Term = #natx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (nat natx);
Fm.Term.normalize : @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #term #defs ((((((((((((((((((Fm.Term.reduce term) defs) #term.self Fm.Term) #term.name #term.indx ((Fm.Term.var term.name) term.indx)) #term.name (Fm.Term.ref term.name)) Fm.Term.typ) #term.eras #term.self #term.name #term.xtyp #term.body $xtyp = ((Fm.Term.normalize term.xtyp) defs); $body = #s #x ((Fm.Term.normalize ((term.body s) x)) defs); (((((Fm.Term.all term.eras) term.self) term.name) xtyp) body)) #term.name #term.body $body = #x ((Fm.Term.normalize (term.body x)) defs); ((Fm.Term.lam term.name) body)) #term.func #term.argm $func = ((Fm.Term.normalize term.func) defs); $argm = ((Fm.Term.normalize term.argm) defs); ((Fm.Term.app func) argm)) #term.name #term.expr #term.body $expr = ((Fm.Term.normalize term.expr) defs); $body = #x ((Fm.Term.normalize (term.body x)) defs); (((Fm.Term.let term.name) expr) body)) #term.name #term.expr #term.body $expr = ((Fm.Term.normalize term.expr) defs); $body = #x ((Fm.Term.normalize (term.body x)) defs); (((Fm.Term.def term.name) expr) body)) #term.done #term.term #term.type $term = ((Fm.Term.normalize term.term) defs); $type = ((Fm.Term.normalize term.type) defs); (((Fm.Term.ann term.done) term) type)) #term.name #term.dref #term.verb (((Fm.Term.gol term.name) term.dref) term.verb)) #term.path (Fm.Term.hol term.path)) #term.natx (Fm.Term.nat term.natx)) #term.chrx (Fm.Term.chr term.chrx)) #term.strx (Fm.Term.str term.strx)) #term.path #term.expr #term.name #term.with #term.cses #term.moti term);
Fm.Term.patch_at : @(path:Bits) @(term:Fm.Term) @(fn:@(:Fm.Term) Fm.Term) Fm.Term = #path #term #fn ((((((((((((((((term #term.self Fm.Term) #term.name #term.indx ((((path #path.self Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.name ((((path #path.self Fm.Term) (fn term)) #path.pred term) #path.pred term)) ((((path #path.self Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.eras #term.self #term.name #term.xtyp #term.body ((((path #path.self Fm.Term) (fn term)) #path.pred (((((Fm.Term.all term.eras) term.self) term.name) (((Fm.Term.patch_at path.pred) term.xtyp) fn)) term.body)) #path.pred (((((Fm.Term.all term.eras) term.self) term.name) term.xtyp) #s #x (((Fm.Term.patch_at path.pred) ((term.body s) x)) fn)))) #term.name #term.body ((((path #path.self Fm.Term) (fn term)) #path.pred ((Fm.Term.lam term.name) #x (((Fm.Term.patch_at (Bits.tail path)) (term.body x)) fn))) #path.pred ((Fm.Term.lam term.name) #x (((Fm.Term.patch_at (Bits.tail path)) (term.body x)) fn)))) #term.func #term.argm ((((path #path.self Fm.Term) (fn term)) #path.pred ((Fm.Term.app (((Fm.Term.patch_at path.pred) term.func) fn)) term.argm)) #path.pred ((Fm.Term.app term.func) (((Fm.Term.patch_at path.pred) term.argm) fn)))) #term.name #term.expr #term.body ((((path #path.self Fm.Term) (fn term)) #path.pred (((Fm.Term.let term.name) (((Fm.Term.patch_at path.pred) term.expr) fn)) term.body)) #path.pred (((Fm.Term.let term.name) term.expr) #x (((Fm.Term.patch_at path.pred) (term.body x)) fn)))) #term.name #term.expr #term.body ((((path #path.self Fm.Term) (fn term)) #path.pred (((Fm.Term.def term.name) (((Fm.Term.patch_at path.pred) term.expr) fn)) term.body)) #path.pred (((Fm.Term.def term.name) term.expr) #x (((Fm.Term.patch_at path.pred) (term.body x)) fn)))) #term.done #term.term #term.type ((((path #path.self Fm.Term) (fn term)) #path.pred (((Fm.Term.ann term.done) (((Fm.Term.patch_at path) term.term) fn)) term.type)) #path.pred (((Fm.Term.ann term.done) (((Fm.Term.patch_at path) term.term) fn)) term.type))) #term.name #term.dref #term.verb ((((path #path.self Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.path ((((path #path.self Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.natx ((((path #path.self Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.chrx ((((path #path.self Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.strx ((((path #path.self Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.path #term.expr #term.name #term.with #term.cses #term.moti ((((path #path.self Fm.Term) (fn term)) #path.pred term) #path.pred term));
Fm.Term.read : @(code:String) (Maybe Fm.Term) = #code ((((Fm.Parser.term code) #parsed.self (Maybe Fm.Term)) #parsed.code #parsed.err (Maybe.none Fm.Term)) #parsed.code #parsed.val ((Maybe.some Fm.Term) parsed.val));
Fm.Term.reduce : @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #term #defs ((((((((((((((((term #term.self Fm.Term) #term.name #term.indx term) #term.name ((((((Fm.get Fm.Def) term.name) defs) #got.self Fm.Term) (Fm.Term.ref term.name)) #got.value ((got.value #got.value.self Fm.Term) #got.value.name #got.value.term #got.value.type #got.value.done ((Fm.Term.reduce got.value.term) defs)))) term) #term.eras #term.self #term.name #term.xtyp #term.body term) #term.name #term.body term) #term.func #term.argm !func = ((Fm.Term.reduce term.func) defs); ((((((((((((((((func #func.self Fm.Term) #func.name #func.indx term) #func.name term) term) #func.eras #func.self #func.name #func.xtyp #func.body term) #func.name #func.body ((Fm.Term.reduce (func.body term.argm)) defs)) #func.func #func.argm term) #func.name #func.expr #func.body term) #func.name #func.expr #func.body term) #func.done #func.term #func.type term) #func.name #func.dref #func.verb term) #func.path term) #func.natx term) #func.chrx term) #func.strx term) #func.path #func.expr #func.name #func.with #func.cses #func.moti term)) #term.name #term.expr #term.body ((Fm.Term.reduce (term.body term.expr)) defs)) #term.name #term.expr #term.body ((Fm.Term.reduce (term.body term.expr)) defs)) #term.done #term.term #term.type ((Fm.Term.reduce term.term) defs)) #term.name #term.dref #term.verb term) #term.path term) #term.natx ((Fm.Term.reduce (Fm.Term.unroll_nat term.natx)) defs)) #term.chrx ((Fm.Term.reduce (Fm.Term.unroll_chr term.chrx)) defs)) #term.strx ((Fm.Term.reduce (Fm.Term.unroll_str term.strx)) defs)) #term.path #term.expr #term.name #term.with #term.cses #term.moti term);
Fm.Term.ref : @(name:Fm.Name) Fm.Term = #name #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (ref name);
Fm.Term.serialize : @(term:Fm.Term) @(depth:Nat) Bits = #term #depth ((((Fm.Term.serialize.go term) depth) depth) Bits.nil);
Fm.Term.serialize.go : @(term:Fm.Term) @(depth:Nat) @(init:Nat) @(x:Bits) Bits = #term #depth #init #x ((((((((((((((((term #term.self Bits) #term.name #term.indx (((((Nat.gte term.indx) init) # Bits) !name = (Bits.concat (Nat.to_bits (Nat.pred ((Nat.sub depth) term.indx)))); (Bits.0 (Bits.0 (Bits.1 (name x))))) !name = (Bits.concat (Nat.to_bits term.indx)); (Bits.0 (Bits.1 (Bits.0 (name x)))))) #term.name !name = (Bits.concat (Fm.Name.to_bits term.name)); (Bits.0 (Bits.0 (Bits.0 (name x))))) (Bits.0 (Bits.1 (Bits.1 x)))) #term.eras #term.self #term.name #term.xtyp #term.body !eras = (((term.eras # @(pred:Bits) Bits) Bits.1) Bits.0); !self = (Bits.concat (Fm.Name.to_bits term.self)); !xtyp = (((Fm.Term.serialize.go term.xtyp) depth) init); !body = (((Fm.Term.serialize.go ((term.body ((Fm.Term.var term.self) depth)) ((Fm.Term.var term.name) (Nat.succ depth)))) (Nat.succ (Nat.succ depth))) init); (Bits.1 (Bits.0 (Bits.0 (eras (self (xtyp (body x)))))))) #term.name #term.body !body = (((Fm.Term.serialize.go (term.body ((Fm.Term.var term.name) depth))) (Nat.succ depth)) init); (Bits.1 (Bits.0 (Bits.1 (body x))))) #term.func #term.argm !func = (((Fm.Term.serialize.go term.func) depth) init); !argm = (((Fm.Term.serialize.go term.argm) depth) init); (Bits.1 (Bits.1 (Bits.0 (func (argm x)))))) #term.name #term.expr #term.body !expr = (((Fm.Term.serialize.go term.expr) depth) init); !body = (((Fm.Term.serialize.go (term.body ((Fm.Term.var term.name) depth))) (Nat.succ depth)) init); (Bits.1 (Bits.1 (Bits.1 (expr (body x)))))) #term.name #term.expr #term.body ((((Fm.Term.serialize.go (term.body term.expr)) depth) init) x)) #term.done #term.term #term.type ((((Fm.Term.serialize.go term.term) depth) init) x)) #term.name #term.dref #term.verb !name = (Bits.concat (Fm.Name.to_bits term.name)); (Bits.0 (Bits.0 (Bits.0 (name x))))) #term.path x) #term.natx (Bits.0 (Bits.0 (Bits.0 ((Bits.concat (Nat.to_bits term.natx)) x))))) #term.chrx (Bits.0 (Bits.0 (Bits.0 ((Bits.concat ((Word.to_bits +16) (U16.to_word term.chrx))) x))))) #term.strx ((((Fm.Term.serialize.go (Fm.Term.unroll_str term.strx)) depth) init) x)) #term.path #term.expr #term.name #term.with #term.cses #term.moti x);
Fm.Term.serialize.string : @(term:Fm.Term) @(depth:Nat) @(init:Nat) String = #term #depth #init ((((((((((((((((term #term.self String) #term.name #term.indx (((((Nat.gte term.indx) init) # String) ((String.concat "#") (Nat.show (Nat.pred ((Nat.sub depth) term.indx))))) ((String.concat "^") (Nat.show term.indx)))) #term.name term.name) "*") #term.eras #term.self #term.name #term.xtyp #term.body (String.flatten (((List.cons String) "\u{2200}") (((List.cons Fm.Name) term.self) (((List.cons String) (((Fm.Term.serialize.string term.xtyp) depth) init)) (((List.cons String) (((Fm.Term.serialize.string ((term.body ((Fm.Term.var term.self) depth)) ((Fm.Term.var term.name) (Nat.succ depth)))) (Nat.succ (Nat.succ depth))) init)) (List.nil String))))))) #term.name #term.body (String.flatten (((List.cons String) "\u{3BB}") (((List.cons String) (((Fm.Term.serialize.string (term.body ((Fm.Term.var term.name) depth))) (Nat.succ depth)) init)) (List.nil String))))) #term.func #term.argm (String.flatten (((List.cons String) "@") (((List.cons String) (((Fm.Term.serialize.string term.func) depth) init)) (((List.cons String) (((Fm.Term.serialize.string term.argm) depth) init)) (List.nil String)))))) #term.name #term.expr #term.body (String.flatten (((List.cons String) "$") (((List.cons String) (((Fm.Term.serialize.string term.expr) depth) init)) (((List.cons String) (((Fm.Term.serialize.string (term.body ((Fm.Term.var term.name) depth))) (Nat.succ depth)) init)) (List.nil String)))))) #term.name #term.expr #term.body (((Fm.Term.serialize.string (term.body term.expr)) depth) init)) #term.done #term.term #term.type (((Fm.Term.serialize.string term.term) depth) init)) #term.name #term.dref #term.verb (String.flatten (((List.cons String) "?") (((List.cons Fm.Name) term.name) (List.nil Fm.Name))))) #term.path "_") #term.natx "_") #term.chrx "_") #term.strx "_") #term.path #term.expr #term.name #term.with #term.cses #term.moti "_");
Fm.Term.show : @(term:Fm.Term) String = #term ((Fm.Term.show.go term) (Maybe.none @(:Bits) Bits));
Fm.Term.show.as_nat : @(term:Fm.Term) (Maybe String) = #term ((((Maybe.mapped Nat) (Fm.Term.show.as_nat.go term)) String) Nat.show);
Fm.Term.show.as_nat.go : @(term:Fm.Term) (Maybe Nat) = #term ((((((((((((((((term #term.self (Maybe Nat)) #term.name #term.indx (Maybe.none Nat)) #term.name (((((String.eql term.name) "Nat.zero") # (Maybe Nat)) ((Maybe.some Nat) +0)) (Maybe.none Nat))) (Maybe.none Nat)) #term.eras #term.self #term.name #term.xtyp #term.body (Maybe.none Nat)) #term.name #term.body (Maybe.none Nat)) #term.func #term.argm ((((((((((((((((term.func #term.func.self (Maybe Nat)) #term.func.name #term.func.indx (Maybe.none Nat)) #term.func.name (((((String.eql term.func.name) "Nat.succ") # (Maybe Nat)) ((((((Monad.bind Maybe) Maybe.monad) Nat) Nat) (Fm.Term.show.as_nat.go term.argm)) #pred ((((Monad.pure Maybe) Maybe.monad) Nat) (Nat.succ pred)))) (Maybe.none Nat))) (Maybe.none Nat)) #term.func.eras #term.func.self #term.func.name #term.func.xtyp #term.func.body (Maybe.none Nat)) #term.func.name #term.func.body (Maybe.none Nat)) #term.func.func #term.func.argm (Maybe.none Nat)) #term.func.name #term.func.expr #term.func.body (Maybe.none Nat)) #term.func.name #term.func.expr #term.func.body (Maybe.none Nat)) #term.func.done #term.func.term #term.func.type (Maybe.none Nat)) #term.func.name #term.func.dref #term.func.verb (Maybe.none Nat)) #term.func.path (Maybe.none Nat)) #term.func.natx (Maybe.none Nat)) #term.func.chrx (Maybe.none Nat)) #term.func.strx (Maybe.none Nat)) #term.func.path #term.func.expr #term.func.name #term.func.with #term.func.cses #term.func.moti (Maybe.none Nat))) #term.name #term.expr #term.body (Maybe.none Nat)) #term.name #term.expr #term.body (Maybe.none Nat)) #term.done #term.term #term.type (Maybe.none Nat)) #term.name #term.dref #term.verb (Maybe.none Nat)) #term.path (Maybe.none Nat)) #term.natx (Maybe.none Nat)) #term.chrx (Maybe.none Nat)) #term.strx (Maybe.none Nat)) #term.path #term.expr #term.name #term.with #term.cses #term.moti (Maybe.none Nat));
Fm.Term.show.go : @(term:Fm.Term) @(path:(Maybe @(:Bits) Bits)) String = #term #path ((((Fm.Term.show.as_nat term) #as_nat.self String) ((((((((((((((((term #term.self String) #term.name #term.indx (Fm.Name.show term.name)) #term.name !name = (Fm.Name.show term.name); (((path #path.self String) name) #path.value !path_val = ((Bits.concat (Fm.Path.to_bits path.value)) (Bits.1 Bits.nil)); !path_str = (Nat.show (Bits.to_nat path_val)); (String.flatten (((List.cons String) name) (((List.cons String) "-") (((List.cons String) path_str) (List.nil String))))))) "Type") #term.eras #term.self #term.name #term.xtyp #term.body !eras = term.eras; !self = (Fm.Name.show term.self); !name = (Fm.Name.show term.name); !type = ((Fm.Term.show.go term.xtyp) (Fm.MPath.0 path)); !open = (((eras # String) "<") "("); !clos = (((eras # String) ">") ")"); !body = ((Fm.Term.show.go ((term.body ((Fm.Term.var term.self) +0)) ((Fm.Term.var term.name) +0))) (Fm.MPath.1 path)); (String.flatten (((List.cons String) self) (((List.cons String) open) (((List.cons String) name) (((List.cons String) ":") (((List.cons String) type) (((List.cons String) clos) (((List.cons String) " ") (((List.cons String) body) (List.nil String))))))))))) #term.name #term.body !name = (Fm.Name.show term.name); !body = ((Fm.Term.show.go (term.body ((Fm.Term.var term.name) +0))) (Fm.MPath.0 path)); (String.flatten (((List.cons String) "(") (((List.cons String) name) (((List.cons String) ") ") (((List.cons String) body) (List.nil String))))))) #term.func #term.argm !func = ((Fm.Term.show.go term.func) (Fm.MPath.0 path)); !argm = ((Fm.Term.show.go term.argm) (Fm.MPath.1 path)); !wrap = (((func #func.self Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (((List.cons String) "(") (((List.cons String) argm) (((List.cons String) ")") (List.nil String))))))))) (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) argm) (((List.cons String) ")") (List.nil String)))))))) #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = ((Fm.Term.show.go term.expr) (Fm.MPath.0 path)); !body = ((Fm.Term.show.go (term.body ((Fm.Term.var term.name) +0))) (Fm.MPath.1 path)); (String.flatten (((List.cons String) "let ") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = ((Fm.Term.show.go term.expr) (Fm.MPath.0 path)); !body = ((Fm.Term.show.go (term.body ((Fm.Term.var term.name) +0))) (Fm.MPath.1 path)); (String.flatten (((List.cons String) "def ") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.done #term.term #term.type !term = ((Fm.Term.show.go term.term) (Fm.MPath.0 path)); !type = ((Fm.Term.show.go term.type) (Fm.MPath.1 path)); (String.flatten (((List.cons String) term) (((List.cons String) "::") (((List.cons String) type) (List.nil String)))))) #term.name #term.dref #term.verb !name = (Fm.Name.show term.name); (String.flatten (((List.cons String) "?") (((List.cons String) name) (List.nil String))))) #term.path "_") #term.natx (String.flatten (((List.cons String) (Nat.show term.natx)) (List.nil String)))) #term.chrx (String.flatten (((List.cons String) "\'") (((List.cons String) (Fm.escape.char term.chrx)) (((List.cons String) "\'") (List.nil String)))))) #term.strx (String.flatten (((List.cons String) "\"") (((List.cons String) (Fm.escape term.strx)) (((List.cons String) "\"") (List.nil String)))))) #term.path #term.expr #term.name #term.with #term.cses #term.moti !expr = ((Fm.Term.show.go term.expr) (Fm.MPath.0 path)); !name = (Fm.Name.show term.name); !with = ((String.join "") ((((List.mapped Fm.Def) term.with) String) #def ((def #def.self String) #def.name #def.term #def.type #def.done !name = (Fm.Name.show def.name); !type = ((Fm.Term.show.go def.type) (Maybe.none @(:Bits) Bits)); !term = ((Fm.Term.show.go def.term) (Maybe.none @(:Bits) Bits)); (String.flatten (((List.cons String) name) (((List.cons String) ": ") (((List.cons String) type) (((List.cons String) " = ") (((List.cons String) term) (((List.cons String) ";") (List.nil String))))))))))); !cses = ((Map.to_list Fm.Term) term.cses); !cses = ((String.join "") ((((List.mapped ((Pair Bits) Fm.Term)) cses) String) #x !name = (Fm.Name.from_bits (((Pair.fst Bits) Fm.Term) x)); !term = ((Fm.Term.show.go (((Pair.snd Bits) Fm.Term) x)) (Maybe.none @(:Bits) Bits)); (String.flatten (((List.cons String) name) (((List.cons String) ": ") (((List.cons String) term) (((List.cons String) "; ") (List.nil String)))))))); !moti = ((Fm.Term.show.go term.moti) (Maybe.none @(:Bits) Bits)); (String.flatten (((List.cons String) "case ") (((List.cons String) expr) (((List.cons String) " as ") (((List.cons String) name) (((List.cons String) with) (((List.cons String) " { ") (((List.cons String) cses) (((List.cons String) "} : ") (((List.cons String) moti) (List.nil String))))))))))))) #as_nat.value as_nat.value);
Fm.Term.str : @(strx:String) Fm.Term = #strx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (str strx);
Fm.Term.typ : Fm.Term = #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse typ;
Fm.Term.unroll_chr : @(chrx:Char) Fm.Term = #chrx ((chrx #chrx.self Fm.Term) #chrx.value !term = (Fm.Term.ref (Fm.Name.read "Word.from_bits")); !term = ((Fm.Term.app term) (Fm.Term.nat +16)); !term = ((Fm.Term.app term) (Fm.Term.unroll_chr.bits ((Word.to_bits +16) chrx.value))); !term = ((Fm.Term.app (Fm.Term.ref (Fm.Name.read "U16.new"))) term); term);
Fm.Term.unroll_chr.bits : @(bits:Bits) Fm.Term = #bits ((((bits #bits.self Fm.Term) (Fm.Term.ref (Fm.Name.read "Bits.nil"))) #bits.pred ((Fm.Term.app (Fm.Term.ref (Fm.Name.read "Bits.0"))) (Fm.Term.unroll_chr.bits bits.pred))) #bits.pred ((Fm.Term.app (Fm.Term.ref (Fm.Name.read "Bits.1"))) (Fm.Term.unroll_chr.bits bits.pred)));
Fm.Term.unroll_nat : @(natx:Nat) Fm.Term = #natx (((natx #natx.self Fm.Term) (Fm.Term.ref (Fm.Name.read "Nat.zero"))) #natx.pred !func = (Fm.Term.ref (Fm.Name.read "Nat.succ")); !argm = (Fm.Term.nat natx.pred); ((Fm.Term.app func) argm));
Fm.Term.unroll_str : @(strx:String) Fm.Term = #strx (((strx #strx.self Fm.Term) (Fm.Term.ref (Fm.Name.read "String.nil"))) #strx.head #strx.tail !char = (Fm.Term.chr strx.head); !term = (Fm.Term.ref (Fm.Name.read "String.cons")); !term = ((Fm.Term.app term) char); !term = ((Fm.Term.app term) (Fm.Term.str strx.tail)); term);
Fm.Term.var : @(name:Fm.Name) @(indx:Nat) Fm.Term = #name #indx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((var name) indx);
Fm.backslash : Char = (Nat.to_u16 +92);
Fm.escape : @(str:String) String = #str (((str #str.self String) String.nil) #str.head #str.tail !head = (Fm.escape.char str.head); !tail = (Fm.escape str.tail); ((String.concat head) tail));
Fm.escapes : (List ((Pair String) Char)) = (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\b") '\u{8}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\f") '\u{C}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\n") '\u{A}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\r") '\u{D}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\t") '\u{9}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\v") '\u{B}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) ((String.cons Fm.backslash) ((String.cons Fm.backslash) String.nil))) Fm.backslash)) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\\"") '\"')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\0") '\u{0}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\\'") '\'')) (List.nil ((Pair String) Char))))))))))));
Fm.escape.char : @(chr:Char) String = #chr (((((U16.eql chr) Fm.backslash) # String) ((String.cons Fm.backslash) ((String.cons chr) String.nil))) (((((U16.eql chr) '\"') # String) ((String.cons Fm.backslash) ((String.cons chr) String.nil))) (((((U16.eql chr) '\'') # String) ((String.cons Fm.backslash) ((String.cons chr) String.nil))) ((((((U16.btw ' ') chr) '~') # String) ((String.cons chr) String.nil)) (String.flatten (((List.cons String) ((String.cons Fm.backslash) String.nil)) (((List.cons String) "u{") (((List.cons String) (U16.show_hex chr)) (((List.cons String) "}") (((List.cons String) String.nil) (List.nil String)))))))))));
Fm.exports : Unit = !Fm.to_core = Fm.to_core; !Fm.report = Fm.report; Unit.new;
Fm.get : %(A:*) @(name:Fm.Name) @(map:(Map A)) (Maybe A) = #A #name #map (((Map.get A) (Fm.Name.to_bits name)) map);
Fm.report : @(code:String) String = #code !defs = (((Maybe.default Fm.Defs) (Map.new Fm.Def)) (Fm.Defs.read code)); !defs = (Fm.synth defs); (Fm.Defs.report defs);
Fm.set : %(A:*) @(name:Fm.Name) @(val:A) @(map:(Map A)) (Map A) = #A #name #val #map ((((Map.set A) (Fm.Name.to_bits name)) val) map);
Fm.synth : @(defs:Fm.Defs) Fm.Defs = #defs !defs = (((((List.for ((Pair Bits) Fm.Def)) ((Map.to_list Fm.Def) defs)) Fm.Defs) defs) #def #defs ((def #def.self Fm.Defs) #def.fst #def.snd ((def.snd #def.snd.self Fm.Defs) #def.snd.name #def.snd.term #def.snd.type #def.snd.done !name = def.snd.name; !term = def.snd.term; !type = def.snd.type; !done = def.snd.done; !defn = ((((Fm.synth.one name) term) type) defs); ((((Fm.set Fm.Def) name) defn) defs)))); defs;
Fm.synth.fix : @(term:Fm.Term) @(type:Fm.Term) @(defs:Fm.Defs) @(errs:(List Fm.Error)) @(fixs:Bool) (Maybe ((Pair Fm.Term) Fm.Term)) = #term #type #defs #errs #fixs (((errs #errs.self (Maybe ((Pair Fm.Term) Fm.Term))) (((fixs # (Maybe ((Pair Fm.Term) Fm.Term))) ((Maybe.some ((Pair Fm.Term) Fm.Term)) ((((Pair.new Fm.Term) Fm.Term) term) type))) (Maybe.none ((Pair Fm.Term) Fm.Term)))) #errs.head #errs.tail ((((((errs.head #errs.head.self (Maybe ((Pair Fm.Term) Fm.Term))) #errs.head.expected #errs.head.detected #errs.head.context (((((Fm.synth.fix term) type) defs) errs.tail) fixs)) #errs.head.name #errs.head.dref #errs.head.verb #errs.head.goal #errs.head.context (((((Fm.synth.fix term) type) defs) errs.tail) fixs)) #errs.head.path #errs.head.term ((((errs.head.path #errs.head.path.self (Maybe ((Pair Fm.Term) Fm.Term))) (Maybe.none ((Pair Fm.Term) Fm.Term))) #errs.head.path.pred !patched_term = (((Fm.Term.patch_at errs.head.path.pred) term) #x errs.head.term); (((((Fm.synth.fix patched_term) type) defs) errs.tail) Bool.true)) #errs.head.path.pred !patched_type = (((Fm.Term.patch_at errs.head.path.pred) type) #x errs.head.term); (((((Fm.synth.fix term) patched_type) defs) errs.tail) Bool.true))) #errs.head.name (((((Fm.synth.fix term) type) defs) errs.tail) fixs)) #errs.head.term #errs.head.context (((((Fm.synth.fix term) type) defs) errs.tail) fixs)));
Fm.synth.one : @(name:Fm.Name) @(term:Fm.Term) @(type:Fm.Term) @(defs:Fm.Defs) Fm.Def = #name #term #type #defs !checked = ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Unit) (((((Fm.Term.check type) ((Maybe.some Fm.Term) Fm.Term.typ)) defs) (List.nil ((Pair Fm.Name) Fm.Term))) (Fm.MPath.1 Fm.MPath.nil))) #chk_type ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Unit) (((((Fm.Term.check term) ((Maybe.some Fm.Term) type)) defs) (List.nil ((Pair Fm.Name) Fm.Term))) (Fm.MPath.0 Fm.MPath.nil))) #chk_term ((((Monad.pure Fm.Check) Fm.Check.monad) Unit) Unit.new))); ((checked #checked.self Fm.Def) #checked.value #checked.errors (((checked.errors #checked.errors.self Fm.Def) ((((Fm.Def.new name) term) type) Bool.true)) #checked.errors.head #checked.errors.tail !fixed = (((((Fm.synth.fix term) type) defs) checked.errors) Bool.false); (((fixed #fixed.self Fm.Def) ((((Fm.Def.new name) term) type) Bool.true)) #fixed.value ((fixed.value #fixed.value.self Fm.Def) #fixed.value.fst #fixed.value.snd !term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) (Fm.Path.0 Fm.Path.nil)) fixed.value.fst); !type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) (Fm.Path.1 Fm.Path.nil)) fixed.value.snd); ((((Fm.synth.one name) term) type) defs)))));
Fm.to_core : @(code:String) String = #code !defs = (((Maybe.default Fm.Defs) (Map.new Fm.Def)) (Fm.Defs.read code)); !defs = (Fm.synth defs); (Fm.Defs.core defs);
IO : @(A:*) * = #A %IO.Self(P:@(self:(IO A)) *) @(end:@(value:A) (P ((IO.end A) value))) @(ask:@(query:String) @(param:String) @(then:@(response:String) (IO A)) (P ((((IO.ask A) query) param) then))) (P IO.Self);
IO.ask : %(A:*) @(query:String) @(param:String) @(then:@(response:String) (IO A)) (IO A) = #A #query #param #then #P #end #ask (((ask query) param) then);
IO.bind : %(A:*) %(B:*) @(a:(IO A)) @(f:@(:A) (IO B)) (IO B) = #A #B #a #f (((a #a.self (IO B)) #a.value (f a.value)) #a.query #a.param #a.then ((((IO.ask B) a.query) a.param) #x ((((IO.bind A) B) (a.then x)) f)));
IO.end : %(A:*) @(value:A) (IO A) = #A #value #P #end #ask (end value);
IO.get_args : (IO String) = ((((IO.ask String) "get_args") "") #line ((IO.end String) line));
IO.get_file : @(name:String) (IO String) = #name ((((IO.ask String) "get_file") name) #file ((IO.end String) file));
IO.get_line : (IO String) = ((((IO.ask String) "get_line") "") #line ((IO.end String) line));
IO.monad : (Monad IO) = (((Monad.new IO) IO.bind) IO.end);
IO.print : @(text:String) (IO Unit) = #text ((((IO.ask Unit) "print") text) #skip ((IO.end Unit) Unit.new));
IO.prompt : @(text:String) (IO String) = #text ((((IO.ask String) "print") text) #skip ((((IO.ask String) "get_line") "") #line ((IO.end String) line)));
List : @(A:*) * = #A %List.Self(P:@(self:(List A)) *) @(nil:(P (List.nil A))) @(cons:@(head:A) @(tail:(List A)) (P (((List.cons A) head) tail))) (P List.Self);
List.at : %(A:*) @(index:Nat) @(list:(List A)) (Maybe A) = #A #index #list (((list #list.self (Maybe A)) (Maybe.none A)) #list.head #list.tail (((index #index.self (Maybe A)) ((Maybe.some A) list.head)) #index.pred (((List.at A) index.pred) list.tail)));
List.at_last : %(A:*) @(index:Nat) @(list:(List A)) (Maybe A) = #A #index #list (((List.at A) index) ((List.reverse A) list));
List.concat : %(A:*) @(as:(List A)) @(bs:(List A)) (List A) = #A #as #bs (((as #as.self (List A)) bs) #as.head #as.tail (((List.cons A) as.head) (((List.concat A) as.tail) bs)));
List.cons : %(A:*) @(head:A) @(tail:(List A)) (List A) = #A #head #tail #P #nil #cons ((cons head) tail);
List.eql : %(A:*) @(eql:@(:A) @(:A) Bool) @(a:(List A)) @(b:(List A)) Bool = #A #eql #a #b (((a #a.self Bool) (((b #b.self Bool) Bool.true) #b.head #b.tail Bool.false)) #a.head #a.tail (((b #b.self Bool) Bool.false) #b.head #b.tail ((Bool.and ((eql a.head) b.head)) ((((List.eql A) eql) a.tail) b.tail))));
List.flatten : %(A:*) @(xs:(List (List A))) (List A) = #A #xs (((xs #xs.self (List A)) (List.nil A)) #xs.head #xs.tail (((List.concat A) xs.head) ((List.flatten A) xs.tail)));
List.fold : %(A:*) @(list:(List A)) %(P:*) @(:P) @(:@(:A) @(:P) P) P = #A #list #P #nil #cons (((list #list.self P) nil) #list.head #list.tail ((cons list.head) (((((List.fold A) list.tail) P) nil) cons)));
List.for : %(A:*) @(xs:(List A)) %(B:*) @(b:B) @(f:@(:A) @(:B) B) B = #A #xs #B #b #f (((xs #xs.self B) b) #xs.head #xs.tail (((((List.for A) xs.tail) B) ((f xs.head) b)) f));
List.length : %(A:*) @(xs:(List A)) Nat = #A #xs (((List.length.go A) xs) +0);
List.length.go : %(A:*) @(xs:(List A)) @(n:Nat) Nat = #A #xs #n (((xs #xs.self Nat) n) #xs.head #xs.tail (((List.length.go A) xs.tail) (Nat.succ n)));
List.map : %(A:*) %(B:*) @(f:@(:A) B) @(as:(List A)) (List B) = #A #B #f #as (((as #as.self (List B)) (List.nil B)) #as.head #as.tail (((List.cons B) (f as.head)) ((((List.map A) B) f) as.tail)));
List.mapped : %(A:*) @(as:(List A)) %(B:*) @(f:@(:A) B) (List B) = #A #as #B #f (((as #as.self (List B)) (List.nil B)) #as.head #as.tail (((List.cons B) (f as.head)) ((((List.mapped A) as.tail) B) f)));
List.nil : %(A:*) (List A) = #A #P #nil #cons nil;
List.range.nat : @(nat:Nat) (List Nat) = #nat ((List.range.nat.go nat) (List.nil Nat));
List.range.nat.go : @(nat:Nat) @(list:(List Nat)) (List Nat) = #nat #list (((nat #nat.self (List Nat)) list) #nat.pred ((List.range.nat.go nat.pred) (((List.cons Nat) nat.pred) list)));
List.reverse : %(A:*) @(xs:(List A)) (List A) = #A #xs (((List.reverse.go A) xs) (List.nil A));
List.reverse.go : %(A:*) @(xs:(List A)) @(res:(List A)) (List A) = #A #xs #res (((xs #xs.self (List A)) res) #xs.head #xs.tail (((List.reverse.go A) xs.tail) (((List.cons A) xs.head) res)));
Map : @(A:*) * = #A %Map.Self(P:@(self:(Map A)) *) @(new:(P (Map.new A))) @(tie:@(val:(Maybe A)) @(lft:(Map A)) @(rgt:(Map A)) (P ((((Map.tie A) val) lft) rgt))) (P Map.Self);
Map.delete : %(A:*) @(key:Bits) @(map:(Map A)) (Map A) = #A #key #map (((map #map.self (Map A)) (Map.new A)) #map.val #map.lft #map.rgt ((((key #key.self (Map A)) ((((Map.tie A) (Maybe.none A)) map.lft) map.rgt)) #key.pred (((Map.delete A) key.pred) map.lft)) #key.pred (((Map.delete A) key.pred) map.rgt)));
Map.fold : %(A:*) @(map:(Map A)) %(P:*) @(:P) @(:@(:(Maybe A)) @(:P) @(:P) P) P = #A #map #P #new #tie (((map #map.self P) new) #map.val #map.lft #map.rgt (((tie map.val) (((((Map.fold A) map.lft) P) new) tie)) (((((Map.fold A) map.rgt) P) new) tie)));
Map.from_list : %(A:*) %(B:*) @(f:@(:A) Bits) @(xs:(List ((Pair A) B))) (Map B) = #A #B #f #xs (((xs #xs.self (Map B)) (Map.new B)) #xs.head #xs.tail ((xs.head #p.self (Map B)) #p.fst #p.snd ((((Map.set B) (f p.fst)) p.snd) ((((Map.from_list A) B) f) xs.tail))));
Map.get : %(A:*) @(bits:Bits) @(map:(Map A)) (Maybe A) = #A #bits #map ((((bits #bits.self (Maybe A)) (((map #map.self (Maybe A)) (Maybe.none A)) #map.val #map.lft #map.rgt map.val)) #bits.pred (((map #map.self (Maybe A)) (Maybe.none A)) #map.val #map.lft #map.rgt (((Map.get A) bits.pred) map.lft))) #bits.pred (((map #map.self (Maybe A)) (Maybe.none A)) #map.val #map.lft #map.rgt (((Map.get A) bits.pred) map.rgt)));
Map.new : %(A:*) (Map A) = #A #P #new #tie new;
Map.set : %(A:*) @(bits:Bits) @(val:A) @(map:(Map A)) (Map A) = #A #bits #val #map ((((bits #bits.self (Map A)) (((map #map.self (Map A)) ((((Map.tie A) ((Maybe.some A) val)) (Map.new A)) (Map.new A))) #map.val #map.lft #map.rgt ((((Map.tie A) ((Maybe.some A) val)) map.lft) map.rgt))) #bits.pred (((map #map.self (Map A)) ((((Map.tie A) (Maybe.none A)) ((((Map.set A) bits.pred) val) (Map.new A))) (Map.new A))) #map.val #map.lft #map.rgt ((((Map.tie A) map.val) ((((Map.set A) bits.pred) val) map.lft)) map.rgt))) #bits.pred (((map #map.self (Map A)) ((((Map.tie A) (Maybe.none A)) (Map.new A)) ((((Map.set A) bits.pred) val) (Map.new A)))) #map.val #map.lft #map.rgt ((((Map.tie A) map.val) map.lft) ((((Map.set A) bits.pred) val) map.rgt))));
Map.tie : %(A:*) @(val:(Maybe A)) @(lft:(Map A)) @(rgt:(Map A)) (Map A) = #A #val #lft #rgt #P #new #tie (((tie val) lft) rgt);
Map.to_list : %(A:*) @(xs:(Map A)) (List ((Pair Bits) A)) = #A #xs ((List.reverse ((Pair Bits) A)) ((((Map.to_list.go A) xs) Bits.nil) (List.nil ((Pair Bits) A))));
Map.to_list.go : %(A:*) @(xs:(Map A)) @(key:Bits) @(list:(List ((Pair Bits) A))) (List ((Pair Bits) A)) = #A #xs #key #list (((xs #xs.self (List ((Pair Bits) A))) list) #xs.val #xs.lft #xs.rgt !list0 = (((xs.val #xs.val.self (List ((Pair Bits) A))) list) #xs.val.value (((List.cons ((Pair Bits) A)) ((((Pair.new Bits) A) (Bits.reverse key)) xs.val.value)) list)); !list1 = ((((Map.to_list.go A) xs.lft) (Bits.0 key)) list0); !list2 = ((((Map.to_list.go A) xs.rgt) (Bits.1 key)) list1); list2);
Maybe : @(A:*) * = #A %Maybe.Self(P:@(self:(Maybe A)) *) @(none:(P (Maybe.none A))) @(some:@(value:A) (P ((Maybe.some A) value))) (P Maybe.Self);
Maybe.bind : %(A:*) %(B:*) @(m:(Maybe A)) @(f:@(:A) (Maybe B)) (Maybe B) = #A #B #m #f (((m #m.self (Maybe B)) (Maybe.none B)) #m.value (f m.value));
Maybe.default : %(A:*) @(a:A) @(m:(Maybe A)) A = #A #a #m (((m #m.self A) a) #m.value m.value);
Maybe.mapped : %(A:*) @(m:(Maybe A)) %(B:*) @(f:@(:A) B) (Maybe B) = #A #m #B #f (((m #m.self (Maybe B)) (Maybe.none B)) #m.value ((Maybe.some B) (f m.value)));
Maybe.monad : (Monad Maybe) = (((Monad.new Maybe) Maybe.bind) Maybe.some);
Maybe.none : %(A:*) (Maybe A) = #A #P #none #some none;
Maybe.or : %(A:*) @(a:(Maybe A)) @(b:(Maybe A)) (Maybe A) = #A #a #b (((a #a.self (Maybe A)) b) #a.value ((Maybe.some A) a.value));
Maybe.pure : %(A:*) @(a:A) (Maybe A) = #A #a ((Maybe.some A) a);
Maybe.some : %(A:*) @(value:A) (Maybe A) = #A #value #P #none #some (some value);
Maybe.to_bool : %(A:*) @(m:(Maybe A)) Bool = #A #m (((m #m.self Bool) Bool.false) #m.value Bool.true);
Monad : @(M:@(:*) *) * = #M %Monad.Self(P:@(self:(Monad M)) *) @(new:@(bind:%(A:*) %(B:*) @(m:(M A)) @(f:@(x:A) (M B)) (M B)) @(pure:%(A:*) @(x:A) (M A)) (P (((Monad.new M) bind) pure))) (P Monad.Self);
Monad.bind : %(M:@(:*) *) @(m:(Monad M)) %(A:*) %(B:*) @(:(M A)) @(:@(:A) (M B)) (M B) = #M #m ((m #m.self %(A:*) %(B:*) @(:(M A)) @(:@(:A) (M B)) (M B)) #m.bind #m.pure m.bind);
Monad.new : %(M:@(:*) *) @(bind:%(A:*) %(B:*) @(m:(M A)) @(f:@(x:A) (M B)) (M B)) @(pure:%(A:*) @(x:A) (M A)) (Monad M) = #M #bind #pure #P #new ((new bind) pure);
Monad.pure : %(M:@(:*) *) @(m:(Monad M)) %(A:*) @(:A) (M A) = #M #m ((m #m.self %(A:*) @(:A) (M A)) #m.bind #m.pure m.pure);
Nat : * = %Nat.Self(P:@(self:Nat) *) @(zero:(P Nat.zero)) @(succ:@(pred:Nat) (P (Nat.succ pred))) (P Nat.Self);
Nat.add : @(n:Nat) @(m:Nat) Nat = #n #m (((n #n.self Nat) m) #n.pred (Nat.succ ((Nat.add n.pred) m)));
Nat.apply : %(A:*) @(n:Nat) @(f:@(x:A) A) @(x:A) A = #A #n #f #x (((n #n.self A) x) #n.pred ((((Nat.apply A) n.pred) f) (f x)));
Nat.cmp : @(a:Nat) @(b:Nat) Cmp = #a #b (((a #a.self Cmp) (((b #b.self Cmp) Cmp.eql) #b.pred Cmp.ltn)) #a.pred (((b #b.self Cmp) Cmp.gtn) #b.pred ((Nat.cmp a.pred) b.pred)));
Nat.div : @(n:Nat) @(m:Nat) Nat = #n #m (((Pair.fst Nat) Nat) ((Nat.div_mod n) m));
Nat.div_mod : @(n:Nat) @(m:Nat) ((Pair Nat) Nat) = #n #m (((Nat.div_mod.go n) m) Nat.zero);
Nat.div_mod.go : @(n:Nat) @(m:Nat) @(d:Nat) ((Pair Nat) Nat) = #n #m #d (((((Nat.sub_rem n) m) #p.self ((Pair Nat) Nat)) #p.value (((Nat.div_mod.go p.value) m) (Nat.succ d))) #p.value ((((Pair.new Nat) Nat) d) n));
Nat.double : @(n:Nat) Nat = #n (((n #n.self Nat) Nat.zero) #n.pred (Nat.succ (Nat.double n.pred)));
Nat.eql : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_eql ((Nat.cmp n) m));
Nat.from_base : @(base:Nat) @(ds:(List Nat)) Nat = #base #ds ((((Nat.from_base.go base) ((List.reverse Nat) ds)) +1) +0);
Nat.from_base.go : @(b:Nat) @(ds:(List Nat)) @(p:Nat) @(res:Nat) Nat = #b #ds #p #res (((ds #ds.self Nat) res) #ds.head #ds.tail ((((Nat.from_base.go b) ds.tail) ((Nat.mul b) p)) ((Nat.add ((Nat.mul ds.head) p)) res)));
Nat.gte : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_gte ((Nat.cmp n) m));
Nat.gtn : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_gtn ((Nat.cmp n) m));
Nat.lte : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_lte ((Nat.cmp n) m));
Nat.ltn : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_ltn ((Nat.cmp n) m));
Nat.mod : @(n:Nat) @(m:Nat) Nat = #n #m (((Pair.snd Nat) Nat) ((Nat.div_mod n) m));
Nat.mul : @(n:Nat) @(m:Nat) Nat = #n #m (((n #n.self Nat) Nat.zero) #n.pred ((Nat.add m) ((Nat.mul n.pred) m)));
Nat.pred : @(n:Nat) Nat = #n (((n #n.self Nat) Nat.zero) #n.pred n.pred);
Nat.show : @(n:Nat) String = #n ((Nat.to_string_base +10) n);
Nat.show_digit : @(base:Nat) @(n:Nat) Char = #base #n !m = ((Nat.mod n) base); !base64 = (((List.cons Char) '0') (((List.cons Char) '1') (((List.cons Char) '2') (((List.cons Char) '3') (((List.cons Char) '4') (((List.cons Char) '5') (((List.cons Char) '6') (((List.cons Char) '7') (((List.cons Char) '8') (((List.cons Char) '9') (((List.cons Char) 'A') (((List.cons Char) 'B') (((List.cons Char) 'C') (((List.cons Char) 'D') (((List.cons Char) 'E') (((List.cons Char) 'F') (((List.cons Char) 'G') (((List.cons Char) 'H') (((List.cons Char) 'I') (((List.cons Char) 'J') (((List.cons Char) 'K') (((List.cons Char) 'L') (((List.cons Char) 'M') (((List.cons Char) 'N') (((List.cons Char) 'O') (((List.cons Char) 'P') (((List.cons Char) 'Q') (((List.cons Char) 'R') (((List.cons Char) 'S') (((List.cons Char) 'T') (((List.cons Char) 'U') (((List.cons Char) 'V') (((List.cons Char) 'W') (((List.cons Char) 'X') (((List.cons Char) 'Y') (((List.cons Char) 'Z') (((List.cons Char) 'a') (((List.cons Char) 'b') (((List.cons Char) 'c') (((List.cons Char) 'd') (((List.cons Char) 'e') (((List.cons Char) 'f') (((List.cons Char) 'g') (((List.cons Char) 'h') (((List.cons Char) 'i') (((List.cons Char) 'j') (((List.cons Char) 'k') (((List.cons Char) 'l') (((List.cons Char) 'm') (((List.cons Char) 'n') (((List.cons Char) 'o') (((List.cons Char) 'p') (((List.cons Char) 'q') (((List.cons Char) 'r') (((List.cons Char) 's') (((List.cons Char) 't') (((List.cons Char) 'u') (((List.cons Char) 'v') (((List.cons Char) 'w') (((List.cons Char) 'x') (((List.cons Char) 'y') (((List.cons Char) 'z') (((List.cons Char) '+') (((List.cons Char) '/') (List.nil Char))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))); (((((Bool.and ((Nat.gtn base) +0)) ((Nat.lte base) +64)) # Char) ((((((List.at Char) m) base64) #c.self Char) '#') #c.value c.value)) '#');
Nat.sub : @(n:Nat) @(m:Nat) Nat = #n #m (((n #n.self Nat) +0) #n.pred (((m #m.self Nat) n) #m.pred ((Nat.sub n.pred) m.pred)));
Nat.sub_rem : @(n:Nat) @(m:Nat) ((Either Nat) Nat) = #n #m (((m #m.self ((Either Nat) Nat)) (((Either.left Nat) Nat) n)) #m.pred (((n #n.self ((Either Nat) Nat)) (((Either.right Nat) Nat) (Nat.succ m.pred))) #n.pred ((Nat.sub_rem n.pred) m.pred)));
Nat.succ : @(pred:Nat) Nat = #pred #P #zero #succ (succ pred);
Nat.to_base : @(base:Nat) @(nat:Nat) (List Nat) = #base #nat (((Nat.to_base.go base) nat) (List.nil Nat));
Nat.to_base.go : @(base:Nat) @(nat:Nat) @(res:(List Nat)) (List Nat) = #base #nat #res ((((Nat.div_mod nat) base) #div_mod.self (List Nat)) #div_mod.fst #div_mod.snd (((div_mod.fst #div_mod.fst.self (List Nat)) (((List.cons Nat) div_mod.snd) res)) #div_mod.fst.pred (((Nat.to_base.go base) div_mod.fst) (((List.cons Nat) div_mod.snd) res))));
Nat.to_bits : @(n:Nat) Bits = #n (((n #n.self Bits) Bits.nil) #n.pred (Bits.inc (Nat.to_bits n.pred)));
Nat.to_string_base : @(base:Nat) @(nat:Nat) String = #base #nat (((((List.fold Nat) ((Nat.to_base base) nat)) String) String.nil) #n #str ((String.cons ((Nat.show_digit base) n)) str));
Nat.to_u16 : @(n:Nat) U16 = #n ((((Nat.apply U16) n) U16.inc) U16.zero);
Nat.zero : Nat = #P #zero #succ zero;
Pair : @(A:*) @(B:*) * = #A #B %Pair.Self(P:@(self:((Pair A) B)) *) @(new:@(fst:A) @(snd:B) (P ((((Pair.new A) B) fst) snd))) (P Pair.Self);
Pair.fst : %(A:*) %(B:*) @(pair:((Pair A) B)) A = #A #B #pair ((pair #pair.self A) #pair.fst #pair.snd pair.fst);
Pair.new : %(A:*) %(B:*) @(fst:A) @(snd:B) ((Pair A) B) = #A #B #fst #snd #P #new ((new fst) snd);
Pair.snd : %(A:*) %(B:*) @(pair:((Pair A) B)) B = #A #B #pair ((pair #pair.self B) #pair.fst #pair.snd pair.snd);
Parser : @(V:*) * = #V @(:String) (Parser.Reply V);
Parser.Reply : @(V:*) * = #V %Parser.Reply.Self(P:@(self:(Parser.Reply V)) *) @(error:@(code:String) @(err:String) (P (((Parser.Reply.error V) code) err))) @(value:@(code:String) @(val:V) (P (((Parser.Reply.value V) code) val))) (P Parser.Reply.Self);
Parser.Reply.error : %(V:*) @(code:String) @(err:String) (Parser.Reply V) = #V #code #err #P #error #value ((error code) err);
Parser.Reply.value : %(V:*) @(code:String) @(val:V) (Parser.Reply V) = #V #code #val #P #error #value ((value code) val);
Parser.bind : %(A:*) %(B:*) @(parse:(Parser A)) @(next:@(:A) (Parser B)) (Parser B) = #A #B #parse #next #code ((((parse code) #reply.self (Parser.Reply B)) #reply.code #reply.err (((Parser.Reply.error B) reply.code) reply.err)) #reply.code #reply.val ((next reply.val) reply.code));
Parser.char_if : @(fun:@(:Char) Bool) (Parser Char) = #fun #code (((code #code.self (Parser.Reply Char)) (((Parser.Reply.error Char) code) "No parse.")) #code.head #code.tail ((((fun code.head) # (Parser.Reply Char)) (((Parser.Reply.value Char) code.tail) code.head)) (((Parser.Reply.error Char) code) "No parse.")));
Parser.digit : (Parser Nat) = #code (((code #code.self (Parser.Reply Nat)) (((Parser.Reply.error Nat) code) "No parse.")) #code.head #code.tail (((((U16.eql code.head) '0') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +0)) (((((U16.eql code.head) '1') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +1)) (((((U16.eql code.head) '2') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +2)) (((((U16.eql code.head) '3') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +3)) (((((U16.eql code.head) '4') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +4)) (((((U16.eql code.head) '5') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +5)) (((((U16.eql code.head) '6') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +6)) (((((U16.eql code.head) '7') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +7)) (((((U16.eql code.head) '8') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +8)) (((((U16.eql code.head) '9') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +9)) (((Parser.Reply.error Nat) code) "No parse."))))))))))));
Parser.first_of : %(A:*) @(pars:(List (Parser A))) (Parser A) = #A #pars #code (((pars #pars.self (Parser.Reply A)) (((Parser.Reply.error A) code) "No parse.")) #pars.head #pars.tail !parsed = (pars.head code); (((parsed #parsed.self (Parser.Reply A)) #parsed.code #parsed.err (((Parser.first_of A) pars.tail) code)) #parsed.code #parsed.val (((Parser.Reply.value A) parsed.code) parsed.val)));
Parser.get_code : (Parser String) = #code (((Parser.Reply.value String) code) code);
Parser.if_not : %(A:*) @(a:(Parser Unit)) @(b:(Parser A)) (Parser A) = #A #a #b #code ((((a code) #self.self (Parser.Reply A)) #self.code #self.err (b code)) #self.code #self.val (((Parser.Reply.error A) code) "Prevented."));
Parser.log : @(str:String) (Parser Unit) = #str #code (((Debug.log (Parser.Reply Unit)) str) #x (((Parser.Reply.value Unit) code) Unit.new));
Parser.log_code : (Parser Unit) = #code (((Debug.log (Parser.Reply Unit)) code) #x (((Parser.Reply.value Unit) code) Unit.new));
Parser.many : %(V:*) @(parser:(Parser V)) (Parser (List V)) = #V #parser (((Parser.many.go V) parser) #x x);
Parser.many1 : %(V:*) @(parser:(Parser V)) (Parser (List V)) = #V #parser ((((((Monad.bind Parser) Parser.monad) V) (List V)) parser) #head ((((((Monad.bind Parser) Parser.monad) (List V)) (List V)) ((Parser.many V) parser)) #tail ((((Monad.pure Parser) Parser.monad) (List V)) (((List.cons V) head) tail))));
Parser.many.go : %(V:*) @(parse:(Parser V)) @(values:@(:(List V)) (List V)) @(code:String) (Parser.Reply (List V)) = #V #parse #values #code ((((parse code) #reply.self (Parser.Reply (List V))) #reply.code #reply.err (((Parser.Reply.value (List V)) code) (values (List.nil V)))) #reply.code #reply.val ((((Parser.many.go V) parse) #xs (values (((List.cons V) reply.val) xs))) reply.code));
Parser.maybe : %(V:*) @(parse:(Parser V)) (Parser (Maybe V)) = #V #parse #code ((((parse code) #reply.self (Parser.Reply (Maybe V))) #reply.code #reply.err (((Parser.Reply.value (Maybe V)) code) (Maybe.none V))) #reply.code #reply.val (((Parser.Reply.value (Maybe V)) reply.code) ((Maybe.some V) reply.val)));
Parser.monad : (Monad Parser) = (((Monad.new Parser) Parser.bind) Parser.pure);
Parser.nat : (Parser Nat) = ((((((Monad.bind Parser) Parser.monad) (List Nat)) Nat) ((Parser.many1 Nat) Parser.digit)) #digits ((((Monad.pure Parser) Parser.monad) Nat) ((Nat.from_base +10) digits)));
Parser.one : (Parser Char) = #code (((code #code.self (Parser.Reply Char)) (((Parser.Reply.error Char) code) "Unexpected end of file.")) #code.head #code.tail (((Parser.Reply.value Char) code.tail) code.head));
Parser.pure : %(V:*) @(value:V) (Parser V) = #V #value #code (((Parser.Reply.value V) code) value);
Parser.spaces : (Parser (List Unit)) = ((Parser.many Unit) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text " ")) (((List.cons (Parser Unit)) (Parser.text "\u{A}")) (List.nil (Parser Unit))))));
Parser.spaces_text : @(text:String) (Parser Unit) = #text ((((((Monad.bind Parser) Parser.monad) (List Unit)) Unit) Parser.spaces) # (Parser.text text));
Parser.text : @(text:String) (Parser Unit) = #text #code (((((Parser.text.go text) code) #reply.self (Parser.Reply Unit)) #reply.code #reply.err (((Parser.Reply.error Unit) code) reply.err)) #reply.code #reply.val (((Parser.Reply.value Unit) reply.code) reply.val));
Parser.text.go : @(text:String) (Parser Unit) = #text #code (((text #text.self (Parser.Reply Unit)) (((Parser.Reply.value Unit) code) Unit.new)) #text.head #text.tail (((code #code.self (Parser.Reply Unit)) !error = (String.flatten (((List.cons String) "Expected \'") (((List.cons String) text) (((List.cons String) "\', found end of file.") (List.nil String))))); (((Parser.Reply.error Unit) code) error)) #code.head #code.tail (((((U16.eql text.head) code.head) # (Parser.Reply Unit)) ((Parser.text text.tail) code.tail)) !error = (String.flatten (((List.cons String) "Expected \'") (((List.cons String) text) (((List.cons String) "\', found \'") (((List.cons String) ((String.cons code.head) String.nil)) (((List.cons String) "\'.") (List.nil String))))))); (((Parser.Reply.error Unit) code) error))));
Parser.until : %(A:*) @(cond:(Parser Unit)) @(parser:(Parser A)) (Parser (List A)) = #A #cond #parser ((Parser.many A) (((Parser.if_not A) cond) parser));
Set : * = (Map Unit);
Set.del : @(key:Bits) @(set:Set) Set = #key #set (((Map.delete Unit) key) set);
Set.has : @(bits:Bits) @(set:Set) Bool = #bits #set ((((((Map.get Unit) bits) set) #self.self Bool) Bool.false) #self.value Bool.true);
Set.new : Set = (Map.new Unit);
Set.set : @(bits:Bits) @(set:Set) Set = #bits #set ((((Map.set Unit) bits) Unit.new) set);
String : * = %String.Self(P:@(self:String) *) @(nil:(P String.nil)) @(cons:@(head:Char) @(tail:String) (P ((String.cons head) tail))) (P String.Self);
StringMap : @(A:*) * = #A %StringMap.Self(P:@(self:(StringMap A)) *) @(nil:(P (StringMap.nil A))) @(cons:@(key:String) @(val:A) @(tail:(StringMap A)) (P ((((StringMap.cons A) key) val) tail))) (P StringMap.Self);
StringMap.cons : %(A:*) @(key:String) @(val:A) @(tail:(StringMap A)) (StringMap A) = #A #key #val #tail #P #nil #cons (((cons key) val) tail);
StringMap.from_list : %(A:*) @(list:(List ((Pair String) A))) (StringMap A) = #A #list (((list #list.self (StringMap A)) (StringMap.nil A)) #list.head #list.tail ((list.head #list.head.self (StringMap A)) #list.head.fst #list.head.snd ((((StringMap.cons A) list.head.fst) list.head.snd) ((StringMap.from_list A) list.tail))));
StringMap.get : %(A:*) @(key:String) @(map:(StringMap A)) (Maybe A) = #A #key #map (((map #map.self (Maybe A)) (Maybe.none A)) #map.key #map.val #map.tail (((((String.eql map.key) key) # (Maybe A)) ((Maybe.some A) map.val)) (((StringMap.get A) key) map.tail)));
StringMap.new : %(A:*) (StringMap A) = #A (StringMap.nil A);
StringMap.nil : %(A:*) (StringMap A) = #A #P #nil #cons nil;
StringMap.set : %(A:*) @(key:String) @(val:A) @(map:(StringMap A)) (StringMap A) = #A #key #val #map (((map #map.self (StringMap A)) ((((StringMap.cons A) key) val) (StringMap.nil A))) #map.key #map.val #map.tail (((((String.eql map.key) key) # (StringMap A)) ((((StringMap.cons A) key) val) map.tail)) ((((StringMap.cons A) map.key) map.val) ((((StringMap.set A) key) val) map.tail))));
StringMap.to_list : %(A:*) @(map:(StringMap A)) (List ((Pair String) A)) = #A #map (((map #map.self (List ((Pair String) A))) (List.nil ((Pair String) A))) #map.key #map.val #map.tail (((List.cons ((Pair String) A)) ((((Pair.new String) A) map.key) map.val)) ((StringMap.to_list A) map.tail)));
String.concat : @(as:String) @(bs:String) String = #as #bs (((as #as.self String) bs) #as.head #as.tail ((String.cons as.head) ((String.concat as.tail) bs)));
String.cons : @(head:Char) @(tail:String) String = #head #tail #P #nil #cons ((cons head) tail);
String.eql : @(a:String) @(b:String) Bool = #a #b (((a #a.self Bool) (((b #b.self Bool) Bool.true) #b.head #b.tail Bool.false)) #a.head #a.tail (((b #b.self Bool) Bool.false) #b.head #b.tail ((Bool.and ((U16.eql a.head) b.head)) ((String.eql a.tail) b.tail))));
String.flatten : @(xs:(List String)) String = #xs ((String.flatten.go xs) "");
String.flatten.go : @(xs:(List String)) @(res:String) String = #xs #res (((xs #xs.self String) res) #xs.head #xs.tail ((String.flatten.go xs.tail) ((String.concat res) xs.head)));
String.is_empty : @(str:String) Bool = #str (((str #str.self Bool) Bool.true) #str.head #str.tail Bool.false);
String.join : @(sep:String) @(list:(List String)) String = #sep #list (((String.join.go sep) list) Bool.true);
String.join.go : @(sep:String) @(list:(List String)) @(fst:Bool) String = #sep #list #fst (((list #list.self String) "") #list.head #list.tail (String.flatten (((List.cons String) (((fst # String) "") sep)) (((List.cons String) list.head) (((List.cons String) (((String.join.go sep) list.tail) Bool.false)) (List.nil String))))));
String.nil : String = #P #nil #cons nil;
Unit : * = %Unit.Self(P:@(self:Unit) *) @(new:(P Unit.new)) (P Unit.Self);
Unit.new : Unit = #P #new new;
U16 : * = %U16.Self(P:@(self:U16) *) @(new:@(value:(Word +16)) (P (U16.new value))) (P U16.Self);
U16.add : @(a:U16) @(b:U16) U16 = #a #b ((a #a.self U16) #a.value ((b #b.self U16) #b.value (U16.new (((Word.add (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value))));
U16.btw : @(a:U16) @(b:U16) @(c:U16) Bool = #a #b #c ((Bool.and ((U16.lte a) b)) ((U16.lte b) c));
U16.eql : @(a:U16) @(b:U16) Bool = #a #b ((a #a.self Bool) #a.value ((b #b.self Bool) #b.value (((Word.eql (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value)));
U16.gte : @(a:U16) @(b:U16) Bool = #a #b ((a #a.self Bool) #a.value ((b #b.self Bool) #b.value (((Word.gte (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value)));
U16.gtn : @(a:U16) @(b:U16) Bool = #a #b ((a #a.self Bool) #a.value ((b #b.self Bool) #b.value (((Word.gtn (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value)));
U16.inc : @(a:U16) U16 = #a ((a #a.self U16) #a.value (U16.new ((Word.inc (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value)));
U16.lte : @(a:U16) @(b:U16) Bool = #a #b ((a #a.self Bool) #a.value ((b #b.self Bool) #b.value (((Word.lte (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value)));
U16.ltn : @(a:U16) @(b:U16) Bool = #a #b ((a #a.self Bool) #a.value ((b #b.self Bool) #b.value (((Word.ltn (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value)));
U16.new : @(value:(Word +16)) U16 = #value #P #new (new value);
U16.show_hex : @(a:U16) String = #a ((a #a.self String) #a.value ((Nat.to_string_base +16) (Bits.to_nat ((Word.to_bits +16) a.value))));
U16.sub : @(a:U16) @(b:U16) U16 = #a #b ((a #a.self U16) #a.value ((b #b.self U16) #b.value (U16.new (((Word.sub (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value))));
U16.to_word : @(a:U16) (Word +16) = #a ((a #a.self (Word (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))))))))))) #a.value a.value);
U16.zero : U16 = (U16.new (Word.zero +16));
Vararg : @(n:Nat) @(A:*) @(B:*) * = #n #A #B (((n #n.self *) B) #n.pred @(x:A) (((Vararg n.pred) A) B));
Vararg.apply : %(A:*) %(B:*) @(idx:Nat) @(fun:(((Vararg idx) A) B)) @(arg:@(:Nat) A) B = #A #B #idx #fun #arg ((((idx #idx.self @(fun:(((Vararg idx.self) A) B)) B) #fun fun) #idx.pred #fun (((((Vararg.apply A) B) idx.pred) (fun (arg idx))) arg)) fun);
Word : @(size:Nat) * = #size %Word.Self(P:@(size:Nat) @(self:(Word size)) *) @(nil:((P Nat.zero) Word.nil)) @(0:%(size:Nat) @(pred:(Word size)) ((P (Nat.succ size)) ((Word.0 size) pred))) @(1:%(size:Nat) @(pred:(Word size)) ((P (Nat.succ size)) ((Word.1 size) pred))) ((P size) Word.Self);
Word.add : %(size:Nat) @(a:(Word size)) @(b:(Word size)) (Word size) = #size #a #b ((((Word.adder size) a) b) Bool.false);
Word.adder : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:Bool) (Word size) = #size #a #b #c (((((a #a.size #a.self @(b:(Word a.size)) (Word a.size)) #b Word.nil) #a.size #a.pred #b (((((b #b.size #b.self @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c.self (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c.self (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false)))) a.pred)) #a.size #a.pred #b (((((b #b.size #b.self @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c.self (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c.self (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true)))) a.pred)) b);
Word.btw : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:(Word size)) Bool = #size #a #b #c ((Bool.and (((Word.lte size) a) b)) (((Word.lte size) b) c));
Word.cmp : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Cmp = #size #a #b ((((Word.cmp.go size) a) b) Cmp.eql);
Word.cmp.go : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:Cmp) Cmp = #size #a #b #c (((((a #a.size #a.self @(b:(Word a.size)) Cmp) #b c) #a.size #a.pred #b (((((b #b.size #b.self @(a.pred:(Word (Nat.pred b.size))) Cmp) #a.pred c) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) c)) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) Cmp.ltn)) a.pred)) #a.size #a.pred #b (((((b #b.size #b.self @(a.pred:(Word (Nat.pred b.size))) Cmp) #a.pred c) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) Cmp.gtn)) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) c)) a.pred)) b);
Word.eql : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Bool = #size #a #b (Cmp.as_eql (((Word.cmp size) a) b));
Word.fold : %(P:@(:Nat) *) %(m:Nat) @(nil:(P Nat.zero)) @(w0:%(n:Nat) @(:(P n)) (P (Nat.succ n))) @(w1:%(n:Nat) @(:(P n)) (P (Nat.succ n))) @(word:(Word m)) (P m) = #P #m #nil #w0 #w1 #word ((((word #word.size #word.self (P word.size)) nil) #word.size #word.pred ((w0 word.size) ((((((Word.fold P) word.size) nil) w0) w1) word.pred))) #word.size #word.pred ((w1 word.size) ((((((Word.fold P) word.size) nil) w0) w1) word.pred)));
Word.foldl : %(P:@(:Nat) *) %(m:Nat) @(nil:(P Nat.zero)) @(w0:%(n:Nat) @(:(P n)) (P (Nat.succ n))) @(w1:%(n:Nat) @(:(P n)) (P (Nat.succ n))) @(word:(Word m)) (P m) = #P #m #nil #w0 #w1 #word ((((word #word.size #word.self (P word.size)) nil) #word.size #word.pred $P = #n (P (Nat.succ n)); $nil = ((w0 Nat.zero) nil); $w0 = #x (w0 (Nat.succ x)); $w1 = #x (w1 (Nat.succ x)); ((((((Word.foldl P) word.size) nil) w0) w1) word.pred)) #word.size #word.pred $P = #n (P (Nat.succ n)); $nil = ((w1 Nat.zero) nil); $w0 = #x (w0 (Nat.succ x)); $w1 = #x (w1 (Nat.succ x)); ((((((Word.foldl P) word.size) nil) w0) w1) word.pred));
Word.from_bits : @(size:Nat) @(bits:Bits) (Word size) = #size #bits (((size #size.self (Word size.self)) Word.nil) #size.pred ((((bits #bits.self (Word (Nat.succ size.pred))) ((Word.0 size.pred) ((Word.from_bits size.pred) Bits.nil))) #bits.pred ((Word.0 size.pred) ((Word.from_bits size.pred) bits.pred))) #bits.pred ((Word.1 size.pred) ((Word.from_bits size.pred) bits.pred))));
Word.gte : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Bool = #size #a #b (Cmp.as_gte (((Word.cmp size) a) b));
Word.gtn : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Bool = #size #a #b (Cmp.as_gtn (((Word.cmp size) a) b));
Word.inc : %(size:Nat) @(word:(Word size)) (Word size) = #size #word ((((word #word.size #word.self (Word word.size)) Word.nil) #word.size #word.pred ((Word.1 word.size) word.pred)) #word.size #word.pred ((Word.0 word.size) ((Word.inc word.size) word.pred)));
Word.lte : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Bool = #size #a #b (Cmp.as_lte (((Word.cmp size) a) b));
Word.ltn : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Bool = #size #a #b (Cmp.as_ltn (((Word.cmp size) a) b));
Word.nil : (Word Nat.zero) = #P #nil #0 #1 nil;
Word.sub : %(size:Nat) @(a:(Word size)) @(b:(Word size)) (Word size) = #size #a #b ((((Word.subber size) a) b) Bool.false);
Word.subber : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:Bool) (Word size) = #size #a #b #c (((((a #a.size #a.self @(b:(Word a.size)) (Word a.size)) #b Word.nil) #a.size #a.pred #b (((((b #b.size #b.self @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c.self (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c.self (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true)))) a.pred)) #a.size #a.pred #b (((((b #b.size #b.self @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c.self (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c.self (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false)))) a.pred)) b);
Word.to_bits : %(size:Nat) @(a:(Word size)) Bits = #size #a ((((a #a.size #a.self Bits) Bits.nil) #a.size #a.pred (Bits.0 ((Word.to_bits a.size) a.pred))) #a.size #a.pred (Bits.1 ((Word.to_bits a.size) a.pred)));
Word.trim : %(size:Nat) @(new_size:Nat) @(word:(Word size)) (Word new_size) = #size #new_size #word (((new_size #new_size.self (Word new_size.self)) Word.nil) #new_size.pred ((((word #word.size #word.self (Word (Nat.succ new_size.pred))) ((Word.0 new_size.pred) (((Word.trim Nat.zero) new_size.pred) Word.nil))) #word.size #word.pred ((Word.0 new_size.pred) (((Word.trim word.size) new_size.pred) word.pred))) #word.size #word.pred ((Word.1 new_size.pred) (((Word.trim word.size) new_size.pred) word.pred))));
Word.zero : @(size:Nat) (Word size) = #size (((size #size.self (Word size.self)) Word.nil) #size.pred ((Word.0 size.pred) (Word.zero size.pred)));
Word.0 : %(size:Nat) @(pred:(Word size)) (Word (Nat.succ size)) = #size #pred #P #nil #0 #1 ((0 size) pred);
Word.1 : %(size:Nat) @(pred:(Word size)) (Word (Nat.succ size)) = #size #pred #P #nil #0 #1 ((1 size) pred);
