Word.1 : %(size:Nat) @(pred:(Word size)) (Word (Nat.succ size)) = #size #pred #P #nil #0 #1 ((1 size) pred);
Word.0 : %(size:Nat) @(pred:(Word size)) (Word (Nat.succ size)) = #size #pred #P #nil #0 #1 ((0 size) pred);
Word.zero : @(size:Nat) (Word size) = #size (((size #size (Word size)) Word.nil) #size.pred ((Word.0 size.pred) (Word.zero size.pred)));
Word.trim : %(size:Nat) @(new_size:Nat) @(word:(Word size)) (Word new_size) = #size #new_size #word (((new_size #new_size (Word new_size)) Word.nil) #new_size.pred ((((word #word.size #word (Word (Nat.succ new_size.pred))) ((Word.0 new_size.pred) (((Word.trim Nat.zero) new_size.pred) Word.nil))) #word.size #word.pred ((Word.0 new_size.pred) (((Word.trim word.size) new_size.pred) word.pred))) #word.size #word.pred ((Word.1 new_size.pred) (((Word.trim word.size) new_size.pred) word.pred))));
Word.to_bits : %(size:Nat) @(a:(Word size)) Bits = #size #a ((((a #a.size #a Bits) Bits.nil) #a.size #a.pred (Bits.0 ((Word.to_bits a.size) a.pred))) #a.size #a.pred (Bits.1 ((Word.to_bits a.size) a.pred)));
Word.subber : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:Bool) (Word size) = #size #a #b #c (((((a #a.size #a @(b:(Word a.size)) (Word a.size)) #b Word.nil) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true)))) a.pred)) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false)))) a.pred)) b);
Word.sub : %(size:Nat) @(a:(Word size)) @(b:(Word size)) (Word size) = #size #a #b ((((Word.subber size) a) b) Bool.false);
Word.nil : (Word Nat.zero) = #P #nil #0 #1 nil;
Word.lte : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Bool = #size #a #b (Cmp.as_lte (((Word.cmp size) a) b));
Word.inc : %(size:Nat) @(word:(Word size)) (Word size) = #size #word ((((word #word.size #word (Word word.size)) Word.nil) #word.size #word.pred ((Word.1 word.size) word.pred)) #word.size #word.pred ((Word.0 word.size) ((Word.inc word.size) word.pred)));
Word.from_bits : @(size:Nat) @(bits:Bits) (Word size) = #size #bits (((size #size (Word size)) Word.nil) #size.pred ((((bits #bits (Word (Nat.succ size.pred))) ((Word.0 size.pred) ((Word.from_bits size.pred) Bits.nil))) #bits.pred ((Word.0 size.pred) ((Word.from_bits size.pred) bits.pred))) #bits.pred ((Word.1 size.pred) ((Word.from_bits size.pred) bits.pred))));
Word.eql : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Bool = #size #a #b (Cmp.as_eql (((Word.cmp size) a) b));
Word.cmp.go : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:Cmp) Cmp = #size #a #b #c (((((a #a.size #a @(b:(Word a.size)) Cmp) #b c) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) Cmp) #a.pred c) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) c)) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) Cmp.ltn)) a.pred)) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) Cmp) #a.pred c) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) Cmp.gtn)) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) c)) a.pred)) b);
Word.cmp : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Cmp = #size #a #b ((((Word.cmp.go size) a) b) Cmp.eql);
Word.adder : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:Bool) (Word size) = #size #a #b #c (((((a #a.size #a @(b:(Word a.size)) (Word a.size)) #b Word.nil) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false)))) a.pred)) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true)))) a.pred)) b);
Word.add : %(size:Nat) @(a:(Word size)) @(b:(Word size)) (Word size) = #size #a #b ((((Word.adder size) a) b) Bool.false);
Word : @(size:Nat) * = #size %Word.Self(P:@(size:Nat) @(:(Word size)) *) @(nil:((P Nat.zero) Word.nil)) @(0:%(size:Nat) @(pred:(Word size)) ((P (Nat.succ size)) ((Word.0 size) pred))) @(1:%(size:Nat) @(pred:(Word size)) ((P (Nat.succ size)) ((Word.1 size) pred))) ((P size) Word.Self);
U16.zero : U16 = (U16.new (Word.zero +16));
U16.to_word : @(a:U16) (Word +16) = #a ((a #a (Word (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))))))))))) #a.value a.value);
U16.sub : @(a:U16) @(b:U16) U16 = #a #b ((a #a U16) #a.value ((b #b U16) #b.value (U16.new (((Word.sub (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value))));
U16.show_hex : @(a:U16) String = #a ((a #a String) #a.value ((Nat.to_string_base +16) (Bits.to_nat ((Word.to_bits +16) a.value))));
U16.new : @(value:(Word +16)) U16 = #value #P #new (new value);
U16.lte : @(a:U16) @(b:U16) Bool = #a #b ((a #a Bool) #a.value ((b #b Bool) #b.value (((Word.lte (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value)));
U16.inc : @(a:U16) U16 = #a ((a #a U16) #a.value (U16.new ((Word.inc (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value)));
U16.eql : @(a:U16) @(b:U16) Bool = #a #b ((a #a Bool) #a.value ((b #b Bool) #b.value (((Word.eql (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value)));
U16.btw : @(a:U16) @(b:U16) @(c:U16) Bool = #a #b #c ((Bool.and ((U16.lte a) b)) ((U16.lte b) c));
U16.add : @(a:U16) @(b:U16) U16 = #a #b ((a #a U16) #a.value ((b #b U16) #b.value (U16.new (((Word.add (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value))));
U16 : * = %U16.Self(P:@(:U16) *) @(new:@(value:(Word +16)) (P (U16.new value))) (P U16.Self);
Unit.new : Unit = #P #new new;
Unit : * = %Unit.Self(P:@(:Unit) *) @(new:(P Unit.new)) (P Unit.Self);
String.reverse.go : @(xs:String) @(res:String) String = #xs #res (((xs #xs String) res) #xs.head #xs.tail ((String.reverse.go xs.tail) ((String.cons xs.head) res)));
String.reverse : @(xs:String) String = #xs ((String.reverse.go xs) String.nil);
String.pad_right : @(size:Nat) @(chr:Char) @(str:String) String = #size #chr #str (((size #size String) str) #size.pred (((str #str String) ((String.cons chr) (((String.pad_right size.pred) chr) ""))) #str.head #str.tail ((String.cons str.head) (((String.pad_right size.pred) chr) str.tail))));
String.pad_left : @(size:Nat) @(chr:Char) @(str:String) String = #size #chr #str (String.reverse (((String.pad_right size) chr) (String.reverse str)));
String.nil : String = #P #nil #cons nil;
String.join.go : @(sep:String) @(list:(List String)) @(fst:Bool) String = #sep #list #fst (((list #list String) "") #list.head #list.tail (String.flatten (((List.cons String) (((fst # String) "") sep)) (((List.cons String) list.head) (((List.cons String) (((String.join.go sep) list.tail) Bool.false)) (List.nil String))))));
String.join : @(sep:String) @(list:(List String)) String = #sep #list (((String.join.go sep) list) Bool.true);
String.is_empty : @(str:String) Bool = #str (((str #str Bool) Bool.true) #str.head #str.tail Bool.false);
String.flatten.go : @(xs:(List String)) @(res:String) String = #xs #res (((xs #xs String) res) #xs.head #xs.tail ((String.flatten.go xs.tail) ((String.concat res) xs.head)));
String.flatten : @(xs:(List String)) String = #xs ((String.flatten.go xs) "");
String.eql : @(a:String) @(b:String) Bool = #a #b (((a #a Bool) (((b #b Bool) Bool.true) #b.head #b.tail Bool.false)) #a.head #a.tail (((b #b Bool) Bool.false) #b.head #b.tail ((Bool.and ((U16.eql a.head) b.head)) ((String.eql a.tail) b.tail))));
String.cons : @(head:Char) @(tail:String) String = #head #tail #P #nil #cons ((cons head) tail);
String.concat : @(as:String) @(bs:String) String = #as #bs (((as #as String) bs) #as.head #as.tail ((String.cons as.head) ((String.concat as.tail) bs)));
String.color : @(col:String) @(str:String) String = #col #str ((String.cons (Nat.to_u16 +27)) ((String.cons '[') ((String.concat col) ((String.cons 'm') ((String.concat str) ((String.cons (Nat.to_u16 +27)) ((String.cons '[') ((String.cons '0') ((String.cons 'm') String.nil)))))))));
String : * = %String.Self(P:@(:String) *) @(nil:(P String.nil)) @(cons:@(head:Char) @(tail:String) (P ((String.cons head) tail))) (P String.Self);
Set.set : @(bits:Bits) @(set:Set) Set = #bits #set ((((Map.set Unit) bits) Unit.new) set);
Set.new : Set = (Map.new Unit);
Set.has : @(bits:Bits) @(set:Set) Bool = #bits #set ((((((Map.get Unit) bits) set) #self Bool) Bool.false) #self.value Bool.true);
Set : * = (Map Unit);
Parser.until.go : %(V:*) @(until:(Parser Unit)) @(parse:(Parser V)) @(values:@(:(List V)) (List V)) @(idx:Nat) @(code:String) (Parser.Reply (List V)) = #V #until #parse #values #idx #code !until_reply = ((until idx) code); (((until_reply #until_reply (Parser.Reply (List V))) #until_reply.idx #until_reply.code #until_reply.err !reply = ((parse idx) code); (((reply #reply (Parser.Reply (List V))) #reply.idx #reply.code #reply.err ((((Parser.Reply.error (List V)) reply.idx) reply.code) reply.err)) #reply.idx #reply.code #reply.val $values = #xs (values (((List.cons V) reply.val) xs)); ((((((Parser.until.go V) until) parse) values) reply.idx) reply.code))) #until_reply.idx #until_reply.code #until_reply.val ((((Parser.Reply.value (List V)) until_reply.idx) until_reply.code) (values (List.nil V))));
Parser.until1 : %(V:*) @(cond:(Parser Unit)) @(parser:(Parser V)) (Parser (List V)) = #V #cond #parser ((((((Monad.bind Parser) Parser.monad) V) (List V)) parser) #head ((((((Monad.bind Parser) Parser.monad) (List V)) (List V)) (((Parser.until V) cond) parser)) #tail ((((Monad.pure Parser) Parser.monad) (List V)) (((List.cons V) head) tail))));
Parser.until : %(V:*) @(until:(Parser Unit)) @(parse:(Parser V)) (Parser (List V)) = #V #until #parse ((((Parser.until.go V) until) parse) #x x);
Parser.text.go : @(text:String) (Parser Unit) = #text #idx #code (((text #text (Parser.Reply Unit)) ((((Parser.Reply.value Unit) idx) code) Unit.new)) #text.head #text.tail (((code #code (Parser.Reply Unit)) !error = (String.flatten (((List.cons String) "Expected \'") (((List.cons String) text) (((List.cons String) "\', found end of file.") (List.nil String))))); ((((Parser.Reply.error Unit) idx) code) error)) #code.head #code.tail (((((U16.eql text.head) code.head) # (Parser.Reply Unit)) (((Parser.text text.tail) (Nat.succ idx)) code.tail)) !error = (String.flatten (((List.cons String) "Expected \'") (((List.cons String) text) (((List.cons String) "\', found \'") (((List.cons String) ((String.cons code.head) String.nil)) (((List.cons String) "\'.") (List.nil String))))))); ((((Parser.Reply.error Unit) idx) code) error))));
Parser.text : @(text:String) (Parser Unit) = #text #idx #code ((((((Parser.text.go text) idx) code) #reply (Parser.Reply Unit)) #reply.idx #reply.code #reply.err ((((Parser.Reply.error Unit) idx) code) reply.err)) #reply.idx #reply.code #reply.val ((((Parser.Reply.value Unit) reply.idx) reply.code) reply.val));
Parser.spaces_text : @(text:String) (Parser Unit) = #text ((((((Monad.bind Parser) Parser.monad) (List Unit)) Unit) Parser.spaces) # (Parser.text text));
Parser.spaces : (Parser (List Unit)) = ((Parser.many Unit) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text " ")) (((List.cons (Parser Unit)) (Parser.text "\u{A}")) (List.nil (Parser Unit))))));
Parser.pure : %(V:*) @(value:V) (Parser V) = #V #value #idx #code ((((Parser.Reply.value V) idx) code) value);
Parser.one : (Parser Char) = #idx #code (((code #code (Parser.Reply Char)) ((((Parser.Reply.error Char) idx) code) "Unexpected end of file.")) #code.head #code.tail ((((Parser.Reply.value Char) (Nat.succ idx)) code.tail) code.head));
Parser.nat : (Parser Nat) = ((((((Monad.bind Parser) Parser.monad) (List Nat)) Nat) ((Parser.many1 Nat) Parser.digit)) #digits ((((Monad.pure Parser) Parser.monad) Nat) ((Nat.from_base +10) digits)));
Parser.monad : (Monad Parser) = (((Monad.new Parser) Parser.bind) Parser.pure);
Parser.maybe : %(V:*) @(parse:(Parser V)) (Parser (Maybe V)) = #V #parse #idx #code (((((parse idx) code) #reply (Parser.Reply (Maybe V))) #reply.idx #reply.code #reply.err ((((Parser.Reply.value (Maybe V)) idx) code) (Maybe.none V))) #reply.idx #reply.code #reply.val ((((Parser.Reply.value (Maybe V)) reply.idx) reply.code) ((Maybe.some V) reply.val)));
Parser.many.go : %(V:*) @(parse:(Parser V)) @(values:@(:(List V)) (List V)) @(idx:Nat) @(code:String) (Parser.Reply (List V)) = #V #parse #values #idx #code (((((parse idx) code) #reply (Parser.Reply (List V))) #reply.idx #reply.code #reply.err ((((Parser.Reply.value (List V)) idx) code) (values (List.nil V)))) #reply.idx #reply.code #reply.val (((((Parser.many.go V) parse) #xs (values (((List.cons V) reply.val) xs))) reply.idx) reply.code));
Parser.many1 : %(V:*) @(parser:(Parser V)) (Parser (List V)) = #V #parser ((((((Monad.bind Parser) Parser.monad) V) (List V)) parser) #head ((((((Monad.bind Parser) Parser.monad) (List V)) (List V)) ((Parser.many V) parser)) #tail ((((Monad.pure Parser) Parser.monad) (List V)) (((List.cons V) head) tail))));
Parser.many : %(V:*) @(parser:(Parser V)) (Parser (List V)) = #V #parser (((Parser.many.go V) parser) #x x);
Parser.is_eof : (Parser Bool) = #idx #code (((code #code (Parser.Reply Bool)) ((((Parser.Reply.value Bool) idx) code) Bool.true)) #code.head #code.tail ((((Parser.Reply.value Bool) idx) code) Bool.false));
Parser.get_index : (Parser Nat) = #idx #code ((((Parser.Reply.value Nat) idx) code) idx);
Parser.first_of.go : %(A:*) @(pars:(List (Parser A))) @(err:(Maybe Parser.ErrorAt)) (Parser A) = #A #pars #err #idx #code (((pars #pars (Parser.Reply A)) (((err #err (Parser.Reply A)) ((((Parser.Reply.error A) idx) code) "No parse.")) #err.value ((err.value #err.value (Parser.Reply A)) #err.value.idx #err.value.code #err.value.err ((((Parser.Reply.error A) err.value.idx) err.value.code) err.value.err)))) #pars.head #pars.tail !parsed = ((pars.head idx) code); (((parsed #parsed (Parser.Reply A)) #parsed.idx #parsed.code #parsed.err !neo = ((Maybe.some Parser.ErrorAt) (((Parser.ErrorAt.new parsed.idx) parsed.code) parsed.err)); !err = ((Parser.ErrorAt.combine neo) err); (((((Parser.first_of.go A) pars.tail) err) idx) code)) #parsed.idx #parsed.code #parsed.val ((((Parser.Reply.value A) parsed.idx) parsed.code) parsed.val)));
Parser.first_of : %(A:*) @(pars:(List (Parser A))) (Parser A) = #A #pars (((Parser.first_of.go A) pars) (Maybe.none Parser.ErrorAt));
Parser.fail : %(V:*) @(error:String) (Parser V) = #V #error #idx #code ((((Parser.Reply.error V) idx) code) error);
Parser.eof : (Parser Unit) = #idx #code (((code #code (Parser.Reply Unit)) ((((Parser.Reply.value Unit) idx) code) Unit.new)) #code.head #code.tail ((((Parser.Reply.error Unit) idx) code) "Expected end-of-file."));
Parser.digit : (Parser Nat) = #idx #code (((code #code (Parser.Reply Nat)) ((((Parser.Reply.error Nat) idx) code) "Not a digit.")) #code.head #code.tail !sidx = (Nat.succ idx); (((((U16.eql code.head) '0') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +0)) (((((U16.eql code.head) '1') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +1)) (((((U16.eql code.head) '2') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +2)) (((((U16.eql code.head) '3') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +3)) (((((U16.eql code.head) '4') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +4)) (((((U16.eql code.head) '5') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +5)) (((((U16.eql code.head) '6') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +6)) (((((U16.eql code.head) '7') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +7)) (((((U16.eql code.head) '8') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +8)) (((((U16.eql code.head) '9') # (Parser.Reply Nat)) ((((Parser.Reply.value Nat) sidx) code.tail) +9)) ((((Parser.Reply.error Nat) idx) code) "Not a digit."))))))))))));
Parser.bind : %(A:*) %(B:*) @(parse:(Parser A)) @(next:@(:A) (Parser B)) (Parser B) = #A #B #parse #next #idx #code (((((parse idx) code) #reply (Parser.Reply B)) #reply.idx #reply.code #reply.err ((((Parser.Reply.error B) reply.idx) reply.code) reply.err)) #reply.idx #reply.code #reply.val (((next reply.val) reply.idx) reply.code));
Parser.Reply.value : %(V:*) @(idx:Nat) @(code:String) @(val:V) (Parser.Reply V) = #V #idx #code #val #P #error #value (((value idx) code) val);
Parser.Reply.error : %(V:*) @(idx:Nat) @(code:String) @(err:String) (Parser.Reply V) = #V #idx #code #err #P #error #value (((error idx) code) err);
Parser.Reply : @(V:*) * = #V %Parser.Reply.Self(P:@(:(Parser.Reply V)) *) @(error:@(idx:Nat) @(code:String) @(err:String) (P ((((Parser.Reply.error V) idx) code) err))) @(value:@(idx:Nat) @(code:String) @(val:V) (P ((((Parser.Reply.value V) idx) code) val))) (P Parser.Reply.Self);
Parser.ErrorAt.new : @(idx:Nat) @(code:String) @(err:String) Parser.ErrorAt = #idx #code #err #P #new (((new idx) code) err);
Parser.ErrorAt.combine : @(a:(Maybe Parser.ErrorAt)) @(b:(Maybe Parser.ErrorAt)) (Maybe Parser.ErrorAt) = #a #b (((a #a (Maybe Parser.ErrorAt)) b) #a.value (((b #b (Maybe Parser.ErrorAt)) a) #b.value ((a.value #a.value (Maybe Parser.ErrorAt)) #a.value.idx #a.value.code #a.value.err ((b.value #b.value (Maybe Parser.ErrorAt)) #b.value.idx #b.value.code #b.value.err (((((Nat.gtn a.value.idx) b.value.idx) # (Maybe Parser.ErrorAt)) a) b)))));
Parser.ErrorAt : * = %Parser.ErrorAt.Self(P:@(:Parser.ErrorAt) *) @(new:@(idx:Nat) @(code:String) @(err:String) (P (((Parser.ErrorAt.new idx) code) err))) (P Parser.ErrorAt.Self);
Parser : @(V:*) * = #V @(:Nat) @(:String) (Parser.Reply V);
Pair.snd : %(A:*) %(B:*) @(pair:((Pair A) B)) B = #A #B #pair ((pair #pair B) #pair.fst #pair.snd pair.snd);
Pair.new : %(A:*) %(B:*) @(fst:A) @(snd:B) ((Pair A) B) = #A #B #fst #snd #P #new ((new fst) snd);
Pair.fst : %(A:*) %(B:*) @(pair:((Pair A) B)) A = #A #B #pair ((pair #pair A) #pair.fst #pair.snd pair.fst);
Pair : @(A:*) @(B:*) * = #A #B %Pair.Self(P:@(:((Pair A) B)) *) @(new:@(fst:A) @(snd:B) (P ((((Pair.new A) B) fst) snd))) (P Pair.Self);
Nat.zero : Nat = #P #zero #succ zero;
Nat.to_u16 : @(n:Nat) U16 = #n ((((Nat.apply U16) n) U16.inc) U16.zero);
Nat.to_string_base : @(base:Nat) @(nat:Nat) String = #base #nat (((((List.fold Nat) ((Nat.to_base base) nat)) String) String.nil) #n #str ((String.cons ((Nat.show_digit base) n)) str));
Nat.to_bits : @(n:Nat) Bits = #n (((n #n Bits) Bits.nil) #n.pred (Bits.inc (Nat.to_bits n.pred)));
Nat.to_base.go : @(base:Nat) @(nat:Nat) @(res:(List Nat)) (List Nat) = #base #nat #res ((((Nat.div_mod nat) base) #div_mod (List Nat)) #div_mod.fst #div_mod.snd (((div_mod.fst #div_mod.fst (List Nat)) (((List.cons Nat) div_mod.snd) res)) #div_mod.fst.pred (((Nat.to_base.go base) div_mod.fst) (((List.cons Nat) div_mod.snd) res))));
Nat.to_base : @(base:Nat) @(nat:Nat) (List Nat) = #base #nat (((Nat.to_base.go base) nat) (List.nil Nat));
Nat.succ : @(pred:Nat) Nat = #pred #P #zero #succ (succ pred);
Nat.sub_rem : @(n:Nat) @(m:Nat) ((Either Nat) Nat) = #n #m (((m #m ((Either Nat) Nat)) (((Either.left Nat) Nat) n)) #m.pred (((n #n ((Either Nat) Nat)) (((Either.right Nat) Nat) (Nat.succ m.pred))) #n.pred ((Nat.sub_rem n.pred) m.pred)));
Nat.sub : @(n:Nat) @(m:Nat) Nat = #n #m (((n #n Nat) +0) #n.pred (((m #m Nat) n) #m.pred ((Nat.sub n.pred) m.pred)));
Nat.show_digit : @(base:Nat) @(n:Nat) Char = #base #n !m = ((Nat.mod n) base); !base64 = (((List.cons Char) '0') (((List.cons Char) '1') (((List.cons Char) '2') (((List.cons Char) '3') (((List.cons Char) '4') (((List.cons Char) '5') (((List.cons Char) '6') (((List.cons Char) '7') (((List.cons Char) '8') (((List.cons Char) '9') (((List.cons Char) 'A') (((List.cons Char) 'B') (((List.cons Char) 'C') (((List.cons Char) 'D') (((List.cons Char) 'E') (((List.cons Char) 'F') (((List.cons Char) 'G') (((List.cons Char) 'H') (((List.cons Char) 'I') (((List.cons Char) 'J') (((List.cons Char) 'K') (((List.cons Char) 'L') (((List.cons Char) 'M') (((List.cons Char) 'N') (((List.cons Char) 'O') (((List.cons Char) 'P') (((List.cons Char) 'Q') (((List.cons Char) 'R') (((List.cons Char) 'S') (((List.cons Char) 'T') (((List.cons Char) 'U') (((List.cons Char) 'V') (((List.cons Char) 'W') (((List.cons Char) 'X') (((List.cons Char) 'Y') (((List.cons Char) 'Z') (((List.cons Char) 'a') (((List.cons Char) 'b') (((List.cons Char) 'c') (((List.cons Char) 'd') (((List.cons Char) 'e') (((List.cons Char) 'f') (((List.cons Char) 'g') (((List.cons Char) 'h') (((List.cons Char) 'i') (((List.cons Char) 'j') (((List.cons Char) 'k') (((List.cons Char) 'l') (((List.cons Char) 'm') (((List.cons Char) 'n') (((List.cons Char) 'o') (((List.cons Char) 'p') (((List.cons Char) 'q') (((List.cons Char) 'r') (((List.cons Char) 's') (((List.cons Char) 't') (((List.cons Char) 'u') (((List.cons Char) 'v') (((List.cons Char) 'w') (((List.cons Char) 'x') (((List.cons Char) 'y') (((List.cons Char) 'z') (((List.cons Char) '+') (((List.cons Char) '/') (List.nil Char))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))); (((((Bool.and ((Nat.gtn base) +0)) ((Nat.lte base) +64)) # Char) ((((((List.at Char) m) base64) #c Char) '#') #c.value c.value)) '#');
Nat.show : @(n:Nat) String = #n ((Nat.to_string_base +10) n);
Nat.pred : @(n:Nat) Nat = #n (((n #n Nat) Nat.zero) #n.pred n.pred);
Nat.mul : @(n:Nat) @(m:Nat) Nat = #n #m (((n #n Nat) Nat.zero) #n.pred ((Nat.add m) ((Nat.mul n.pred) m)));
Nat.mod : @(n:Nat) @(m:Nat) Nat = #n #m (((Pair.snd Nat) Nat) ((Nat.div_mod n) m));
Nat.lte : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_lte ((Nat.cmp n) m));
Nat.is_zero : @(n:Nat) Bool = #n (((n #n Bool) Bool.true) #n.pred Bool.false);
Nat.gtn : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_gtn ((Nat.cmp n) m));
Nat.gte : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_gte ((Nat.cmp n) m));
Nat.from_base.go : @(b:Nat) @(ds:(List Nat)) @(p:Nat) @(res:Nat) Nat = #b #ds #p #res (((ds #ds Nat) res) #ds.head #ds.tail ((((Nat.from_base.go b) ds.tail) ((Nat.mul b) p)) ((Nat.add ((Nat.mul ds.head) p)) res)));
Nat.from_base : @(base:Nat) @(ds:(List Nat)) Nat = #base #ds ((((Nat.from_base.go base) ((List.reverse Nat) ds)) +1) +0);
Nat.eql : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_eql ((Nat.cmp n) m));
Nat.double : @(n:Nat) Nat = #n (((n #n Nat) Nat.zero) #n.pred (Nat.succ (Nat.succ (Nat.double n.pred))));
Nat.div_mod.go : @(n:Nat) @(m:Nat) @(d:Nat) ((Pair Nat) Nat) = #n #m #d (((((Nat.sub_rem n) m) #p ((Pair Nat) Nat)) #p.value (((Nat.div_mod.go p.value) m) (Nat.succ d))) #p.value ((((Pair.new Nat) Nat) d) n));
Nat.div_mod : @(n:Nat) @(m:Nat) ((Pair Nat) Nat) = #n #m (((Nat.div_mod.go n) m) Nat.zero);
Nat.cmp : @(a:Nat) @(b:Nat) Cmp = #a #b (((a #a Cmp) (((b #b Cmp) Cmp.eql) #b.pred Cmp.ltn)) #a.pred (((b #b Cmp) Cmp.gtn) #b.pred ((Nat.cmp a.pred) b.pred)));
Nat.apply : %(A:*) @(n:Nat) @(f:@(x:A) A) @(x:A) A = #A #n #f #x (((n #n A) x) #n.pred ((((Nat.apply A) n.pred) f) (f x)));
Nat.add : @(n:Nat) @(m:Nat) Nat = #n #m (((n #n Nat) m) #n.pred (Nat.succ ((Nat.add n.pred) m)));
Nat : * = %Nat.Self(P:@(:Nat) *) @(zero:(P Nat.zero)) @(succ:@(pred:Nat) (P (Nat.succ pred))) (P Nat.Self);
Monad.pure : %(M:@(:*) *) @(m:(Monad M)) %(A:*) @(:A) (M A) = #M #m ((m #m %(A:*) @(:A) (M A)) #m.bind #m.pure m.pure);
Monad.new : %(M:@(:*) *) @(bind:%(A:*) %(B:*) @(m:(M A)) @(f:@(x:A) (M B)) (M B)) @(pure:%(A:*) @(x:A) (M A)) (Monad M) = #M #bind #pure #P #new ((new bind) pure);
Monad.bind : %(M:@(:*) *) @(m:(Monad M)) %(A:*) %(B:*) @(:(M A)) @(:@(:A) (M B)) (M B) = #M #m ((m #m %(A:*) %(B:*) @(:(M A)) @(:@(:A) (M B)) (M B)) #m.bind #m.pure m.bind);
Monad : @(M:@(:*) *) * = #M %Monad.Self(P:@(:(Monad M)) *) @(new:@(bind:%(A:*) %(B:*) @(m:(M A)) @(f:@(x:A) (M B)) (M B)) @(pure:%(A:*) @(x:A) (M A)) (P (((Monad.new M) bind) pure))) (P Monad.Self);
Maybe.to_bool : %(A:*) @(m:(Maybe A)) Bool = #A #m (((m #m Bool) Bool.false) #m.value Bool.true);
Maybe.some : %(A:*) @(value:A) (Maybe A) = #A #value #P #none #some (some value);
Maybe.or : %(A:*) @(a:(Maybe A)) @(b:(Maybe A)) (Maybe A) = #A #a #b (((a #a (Maybe A)) b) #a.value ((Maybe.some A) a.value));
Maybe.none : %(A:*) (Maybe A) = #A #P #none #some none;
Maybe.monad : (Monad Maybe) = (((Monad.new Maybe) Maybe.bind) Maybe.some);
Maybe.mapped : %(A:*) @(m:(Maybe A)) %(B:*) @(f:@(:A) B) (Maybe B) = #A #m #B #f (((m #m (Maybe B)) (Maybe.none B)) #m.value ((Maybe.some B) (f m.value)));
Maybe.extract : %(A:*) @(m:(Maybe A)) %(B:*) @(a:B) @(f:@(:A) B) B = #A #m #B #a #f (((m #m B) a) #m.value (f m.value));
Maybe.default : %(A:*) @(a:A) @(m:(Maybe A)) A = #A #a #m (((m #m A) a) #m.value m.value);
Maybe.bind : %(A:*) %(B:*) @(m:(Maybe A)) @(f:@(:A) (Maybe B)) (Maybe B) = #A #B #m #f (((m #m (Maybe B)) (Maybe.none B)) #m.value (f m.value));
Maybe : @(A:*) * = #A %Maybe.Self(P:@(:(Maybe A)) *) @(none:(P (Maybe.none A))) @(some:@(value:A) (P ((Maybe.some A) value))) (P Maybe.Self);
Map.values.go : %(A:*) @(xs:(Map A)) @(list:(List A)) (List A) = #A #xs #list (((xs #xs (List A)) list) #xs.val #xs.lft #xs.rgt !list0 = (((xs.val #xs.val (List A)) list) #xs.val.value (((List.cons A) xs.val.value) list)); !list1 = (((Map.values.go A) xs.lft) list0); !list2 = (((Map.values.go A) xs.rgt) list1); list2);
Map.values : %(A:*) @(xs:(Map A)) (List A) = #A #xs (((Map.values.go A) xs) (List.nil A));
Map.to_list.go : %(A:*) @(xs:(Map A)) @(key:Bits) @(list:(List ((Pair Bits) A))) (List ((Pair Bits) A)) = #A #xs #key #list (((xs #xs (List ((Pair Bits) A))) list) #xs.val #xs.lft #xs.rgt !list0 = (((xs.val #xs.val (List ((Pair Bits) A))) list) #xs.val.value (((List.cons ((Pair Bits) A)) ((((Pair.new Bits) A) (Bits.reverse key)) xs.val.value)) list)); !list1 = ((((Map.to_list.go A) xs.lft) (Bits.0 key)) list0); !list2 = ((((Map.to_list.go A) xs.rgt) (Bits.1 key)) list1); list2);
Map.to_list : %(A:*) @(xs:(Map A)) (List ((Pair Bits) A)) = #A #xs ((List.reverse ((Pair Bits) A)) ((((Map.to_list.go A) xs) Bits.nil) (List.nil ((Pair Bits) A))));
Map.tie : %(A:*) @(val:(Maybe A)) @(lft:(Map A)) @(rgt:(Map A)) (Map A) = #A #val #lft #rgt #P #new #tie (((tie val) lft) rgt);
Map.set : %(A:*) @(bits:Bits) @(val:A) @(map:(Map A)) (Map A) = #A #bits #val #map ((((bits #bits (Map A)) (((map #map (Map A)) ((((Map.tie A) ((Maybe.some A) val)) (Map.new A)) (Map.new A))) #map.val #map.lft #map.rgt ((((Map.tie A) ((Maybe.some A) val)) map.lft) map.rgt))) #bits.pred (((map #map (Map A)) ((((Map.tie A) (Maybe.none A)) ((((Map.set A) bits.pred) val) (Map.new A))) (Map.new A))) #map.val #map.lft #map.rgt ((((Map.tie A) map.val) ((((Map.set A) bits.pred) val) map.lft)) map.rgt))) #bits.pred (((map #map (Map A)) ((((Map.tie A) (Maybe.none A)) (Map.new A)) ((((Map.set A) bits.pred) val) (Map.new A)))) #map.val #map.lft #map.rgt ((((Map.tie A) map.val) map.lft) ((((Map.set A) bits.pred) val) map.rgt))));
Map.new : %(A:*) (Map A) = #A #P #new #tie new;
Map.get : %(A:*) @(bits:Bits) @(map:(Map A)) (Maybe A) = #A #bits #map ((((bits #bits (Maybe A)) (((map #map (Maybe A)) (Maybe.none A)) #map.val #map.lft #map.rgt map.val)) #bits.pred (((map #map (Maybe A)) (Maybe.none A)) #map.val #map.lft #map.rgt (((Map.get A) bits.pred) map.lft))) #bits.pred (((map #map (Maybe A)) (Maybe.none A)) #map.val #map.lft #map.rgt (((Map.get A) bits.pred) map.rgt)));
Map.from_list : %(A:*) %(B:*) @(f:@(:A) Bits) @(xs:(List ((Pair A) B))) (Map B) = #A #B #f #xs (((xs #xs (Map B)) (Map.new B)) #xs.head #xs.tail ((xs.head #p (Map B)) #p.fst #p.snd ((((Map.set B) (f p.fst)) p.snd) ((((Map.from_list A) B) f) xs.tail))));
Map : @(A:*) * = #A %Map.Self(P:@(:(Map A)) *) @(new:(P (Map.new A))) @(tie:@(val:(Maybe A)) @(lft:(Map A)) @(rgt:(Map A)) (P ((((Map.tie A) val) lft) rgt))) (P Map.Self);
List.take : %(A:*) @(n:Nat) @(xs:(List A)) (List A) = #A #n #xs (((xs #xs (List A)) (List.nil A)) #xs.head #xs.tail (((n #n (List A)) (List.nil A)) #n.pred (((List.cons A) xs.head) (((List.take A) n.pred) xs.tail))));
List.reverse.go : %(A:*) @(xs:(List A)) @(res:(List A)) (List A) = #A #xs #res (((xs #xs (List A)) res) #xs.head #xs.tail (((List.reverse.go A) xs.tail) (((List.cons A) xs.head) res)));
List.reverse : %(A:*) @(xs:(List A)) (List A) = #A #xs (((List.reverse.go A) xs) (List.nil A));
List.nil : %(A:*) (List A) = #A #P #nil #cons nil;
List.mapped : %(A:*) @(as:(List A)) %(B:*) @(f:@(:A) B) (List B) = #A #as #B #f (((as #as (List B)) (List.nil B)) #as.head #as.tail (((List.cons B) (f as.head)) ((((List.mapped A) as.tail) B) f)));
List.length.go : %(A:*) @(xs:(List A)) @(n:Nat) Nat = #A #xs #n (((xs #xs Nat) n) #xs.head #xs.tail (((List.length.go A) xs.tail) (Nat.succ n)));
List.length : %(A:*) @(xs:(List A)) Nat = #A #xs (((List.length.go A) xs) +0);
List.is_empty : %(A:*) @(list:(List A)) Bool = #A #list (((list #list Bool) Bool.true) #list.head #list.tail Bool.false);
List.for : %(A:*) @(xs:(List A)) %(B:*) @(b:B) @(f:@(:A) @(:B) B) B = #A #xs #B #b #f (((xs #xs B) b) #xs.head #xs.tail (((((List.for A) xs.tail) B) ((f xs.head) b)) f));
List.fold : %(A:*) @(list:(List A)) %(P:*) @(:P) @(:@(:A) @(:P) P) P = #A #list #P #nil #cons (((list #list P) nil) #list.head #list.tail ((cons list.head) (((((List.fold A) list.tail) P) nil) cons)));
List.flatten : %(A:*) @(xs:(List (List A))) (List A) = #A #xs (((xs #xs (List A)) (List.nil A)) #xs.head #xs.tail (((List.concat A) xs.head) ((List.flatten A) xs.tail)));
List.cons : %(A:*) @(head:A) @(tail:(List A)) (List A) = #A #head #tail #P #nil #cons ((cons head) tail);
List.concat : %(A:*) @(as:(List A)) @(bs:(List A)) (List A) = #A #as #bs (((as #as (List A)) bs) #as.head #as.tail (((List.cons A) as.head) (((List.concat A) as.tail) bs)));
List.at_last : %(A:*) @(index:Nat) @(list:(List A)) (Maybe A) = #A #index #list (((List.at A) index) ((List.reverse A) list));
List.at : %(A:*) @(index:Nat) @(list:(List A)) (Maybe A) = #A #index #list (((list #list (Maybe A)) (Maybe.none A)) #list.head #list.tail (((index #index (Maybe A)) ((Maybe.some A) list.head)) #index.pred (((List.at A) index.pred) list.tail)));
List : @(A:*) * = #A %List.Self(P:@(:(List A)) *) @(nil:(P (List.nil A))) @(cons:@(head:A) @(tail:(List A)) (P (((List.cons A) head) tail))) (P List.Self);
Fm.to_core_one : @(code:String) @(name:String) String = #code #name ((Fm.exec #defs (Fm.Defs.core ((Fm.Synth.one name) defs))) code);
Fm.to_core_all : @(code:String) String = #code ((Fm.exec #defs (Fm.Defs.core (Fm.Synth.all defs))) code);
Fm.set : %(A:*) @(name:Fm.Name) @(val:A) @(map:(Map A)) (Map A) = #A #name #val #map ((((Map.set A) (Fm.Name.to_bits name)) val) map);
Fm.highlight.tc : @(code:String) @(ix0:Nat) @(ix1:Nat) @(col:Nat) @(row:Nat) @(lft:(Maybe Nat)) @(lin:String) @(res:(List String)) String = #code #ix0 #ix1 #col #row #lft #lin #res (((code #code String) (((Fm.highlight.end col) row) ((List.reverse String) res))) #code.head #code.tail (((((U16.eql code.head) '\u{A}') # String) !stp = (((((Maybe.extract Nat) lft) Bool) Bool.false) Nat.is_zero); (((stp # String) (((Fm.highlight.end col) row) ((List.reverse String) res))) !spa = +3; !siz = (Nat.succ (Nat.double spa)); !lft = (((ix1 #ix1 (Maybe Nat)) (((lft #lft (Maybe Nat)) ((Maybe.some Nat) spa)) #lft.value ((Maybe.some Nat) (Nat.pred lft.value)))) #ix1.pred lft); !ix0 = (Nat.pred ix0); !ix1 = (Nat.pred ix1); !col = +0; !row = (Nat.succ row); !res = (((List.take String) siz) (((List.cons String) (String.reverse lin)) res)); !lin = (String.reverse (String.flatten (((List.cons String) (((String.pad_left +4) ' ') (Nat.show row))) (((List.cons String) " | ") (List.nil String))))); ((((((((Fm.highlight.tc code.tail) ix0) ix1) col) row) lft) lin) res))) !chr = ((String.cons code.head) String.nil); !chr = (((((Bool.and (Nat.is_zero ix0)) (Bool.not (Nat.is_zero ix1))) # String) (String.reverse ((String.color "31") ((String.color "4") chr)))) chr); !ix0 = (Nat.pred ix0); !ix1 = (Nat.pred ix1); !col = (Nat.succ col); !lin = (String.flatten (((List.cons String) chr) (((List.cons String) lin) (List.nil String)))); ((((((((Fm.highlight.tc code.tail) ix0) ix1) col) row) lft) lin) res)));
Fm.highlight.end : @(col:Nat) @(row:Nat) @(res:(List String)) String = #col #row #res ((String.join "\u{A}") res);
Fm.highlight : @(code:String) @(idx0:Nat) @(idx1:Nat) String = #code #idx0 #idx1 ((((((((Fm.highlight.tc code) idx0) idx1) +0) +1) (Maybe.none Nat)) (String.reverse "   1 | ")) (List.nil String));
Fm.get : %(A:*) @(name:Fm.Name) @(map:(Map A)) (Maybe A) = #A #name #map (((Map.get A) (Fm.Name.to_bits name)) map);
Fm.exports : Unit = !_ = Fm.to_core_all; !_ = Fm.to_core_one; !_ = Fm.check_all; !_ = Fm.check_one; Unit.new;
Fm.exec : @(report:@(:Fm.Defs) String) @(code:String) String = #report #code ((((Fm.Defs.read code) #parsed String) #parsed.value parsed.value) #parsed.value (report parsed.value));
Fm.escape.char : @(chr:Char) String = #chr (((((U16.eql chr) Fm.backslash) # String) ((String.cons Fm.backslash) ((String.cons chr) String.nil))) (((((U16.eql chr) '\"') # String) ((String.cons Fm.backslash) ((String.cons chr) String.nil))) (((((U16.eql chr) '\'') # String) ((String.cons Fm.backslash) ((String.cons chr) String.nil))) ((((((U16.btw ' ') chr) '~') # String) ((String.cons chr) String.nil)) (String.flatten (((List.cons String) ((String.cons Fm.backslash) String.nil)) (((List.cons String) "u{") (((List.cons String) (U16.show_hex chr)) (((List.cons String) "}") (((List.cons String) String.nil) (List.nil String)))))))))));
Fm.escapes : (List ((Pair String) Char)) = (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\b") '\u{8}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\f") '\u{C}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\n") '\u{A}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\r") '\u{D}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\t") '\u{9}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\v") '\u{B}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) ((String.cons Fm.backslash) ((String.cons Fm.backslash) String.nil))) Fm.backslash)) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\\"") '\"')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\0") '\u{0}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\\'") '\'')) (List.nil ((Pair String) Char))))))))))));
Fm.escape : @(str:String) String = #str (((str #str String) String.nil) #str.head #str.tail !head = (Fm.escape.char str.head); !tail = (Fm.escape str.tail); ((String.concat head) tail));
Fm.check_one : @(code:String) @(name:String) String = #code #name ((Fm.exec #defs ((Fm.Defs.report code) ((Fm.Synth.one name) defs))) code);
Fm.check_all : @(code:String) String = #code ((Fm.exec #defs ((Fm.Defs.report code) (Fm.Synth.all defs))) code);
Fm.backslash : Char = (Nat.to_u16 +92);
Fm.Term.xvar : @(:Fm.Name) @(:Nat) Fm.Term = (Fm.Term.var (Maybe.none Fm.Origin));
Fm.Term.xtyp : Fm.Term = (Fm.Term.typ (Maybe.none Fm.Origin));
Fm.Term.xstr : @(:String) Fm.Term = (Fm.Term.str (Maybe.none Fm.Origin));
Fm.Term.xref : @(:Fm.Name) Fm.Term = (Fm.Term.ref (Maybe.none Fm.Origin));
Fm.Term.xnat : @(:Nat) Fm.Term = (Fm.Term.nat (Maybe.none Fm.Origin));
Fm.Term.xlam : @(:Fm.Name) @(:@(:Fm.Term) Fm.Term) Fm.Term = (Fm.Term.lam (Maybe.none Fm.Origin));
Fm.Term.xhol : @(:Bits) Fm.Term = (Fm.Term.hol (Maybe.none Fm.Origin));
Fm.Term.xchr : @(:Char) Fm.Term = (Fm.Term.chr (Maybe.none Fm.Origin));
Fm.Term.xapp : @(:Fm.Term) @(:Fm.Term) Fm.Term = (Fm.Term.app (Maybe.none Fm.Origin));
Fm.Term.xann : @(:Bool) @(:Fm.Term) @(:Fm.Term) Fm.Term = (Fm.Term.ann (Maybe.none Fm.Origin));
Fm.Term.xall : @(:Bool) @(:Fm.Name) @(:Fm.Name) @(:Fm.Term) @(:@(:Fm.Term) @(:Fm.Term) Fm.Term) Fm.Term = (Fm.Term.all (Maybe.none Fm.Origin));
Fm.Term.var : @(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(indx:Nat) Fm.Term = #orig #name #indx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((var orig) name) indx);
Fm.Term.unroll_str : @(strx:String) Fm.Term = #strx (((strx #strx Fm.Term) (Fm.Term.xref (Fm.Name.read "String.nil"))) #strx.head #strx.tail !char = (Fm.Term.xchr strx.head); !term = (Fm.Term.xref (Fm.Name.read "String.cons")); !term = ((Fm.Term.xapp term) char); !term = ((Fm.Term.xapp term) (Fm.Term.xstr strx.tail)); term);
Fm.Term.unroll_nat : @(natx:Nat) Fm.Term = #natx (((natx #natx Fm.Term) (Fm.Term.xref (Fm.Name.read "Nat.zero"))) #natx.pred !func = (Fm.Term.xref (Fm.Name.read "Nat.succ")); !argm = (Fm.Term.xnat natx.pred); ((Fm.Term.xapp func) argm));
Fm.Term.unroll_chr.bits : @(bits:Bits) Fm.Term = #bits ((((bits #bits Fm.Term) (Fm.Term.xref (Fm.Name.read "Bits.nil"))) #bits.pred ((Fm.Term.xapp (Fm.Term.xref (Fm.Name.read "Bits.0"))) (Fm.Term.unroll_chr.bits bits.pred))) #bits.pred ((Fm.Term.xapp (Fm.Term.xref (Fm.Name.read "Bits.1"))) (Fm.Term.unroll_chr.bits bits.pred)));
Fm.Term.unroll_chr : @(chrx:Char) Fm.Term = #chrx ((chrx #chrx Fm.Term) #chrx.value !term = (Fm.Term.xref (Fm.Name.read "Word.from_bits")); !term = ((Fm.Term.xapp term) (Fm.Term.xnat +16)); !term = ((Fm.Term.xapp term) (Fm.Term.unroll_chr.bits ((Word.to_bits +16) chrx.value))); !term = ((Fm.Term.xapp (Fm.Term.xref (Fm.Name.read "U16.new"))) term); term);
Fm.Term.typ : @(orig:(Maybe Fm.Origin)) Fm.Term = #orig #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (typ orig);
Fm.Term.str : @(orig:(Maybe Fm.Origin)) @(strx:String) Fm.Term = #orig #strx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((str orig) strx);
Fm.Term.show.is_ref : @(term:Fm.Term) @(name:Fm.Name) Bool = #term #name ((((((((((((((((term #term Bool) #term.orig #term.name #term.indx Bool.false) #term.orig #term.name ((String.eql name) term.name)) #term.orig Bool.false) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body Bool.false) #term.orig #term.name #term.body Bool.false) #term.orig #term.func #term.argm Bool.false) #term.orig #term.name #term.expr #term.body Bool.false) #term.orig #term.name #term.expr #term.body Bool.false) #term.orig #term.done #term.term #term.type Bool.false) #term.orig #term.name #term.dref #term.verb Bool.false) #term.orig #term.path Bool.false) #term.orig #term.natx Bool.false) #term.orig #term.chrx Bool.false) #term.orig #term.strx Bool.false) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti Bool.false);
Fm.Term.show.go : @(term:Fm.Term) @(path:(Maybe @(:Bits) Bits)) String = #term #path ((((Fm.Term.show.as_nat term) #as_nat String) ((((((((((((((((term #term String) #term.orig #term.name #term.indx (Fm.Name.show term.name)) #term.orig #term.name !name = (Fm.Name.show term.name); (((path #path String) name) #path.value !path_val = ((Bits.concat (Fm.Path.to_bits path.value)) (Bits.1 Bits.nil)); !path_str = (Nat.show (Bits.to_nat path_val)); (String.flatten (((List.cons String) name) (((List.cons String) ((String.color "2") ((String.concat "-") path_str))) (List.nil String)))))) #term.orig "Type") #term.orig #term.eras #term.self #term.name #term.xtyp #term.body !eras = term.eras; !self = (Fm.Name.show term.self); !name = (Fm.Name.show term.name); !type = ((Fm.Term.show.go term.xtyp) (Fm.MPath.0 path)); !open = (((eras # String) "<") "("); !clos = (((eras # String) ">") ")"); !body = ((Fm.Term.show.go ((term.body ((Fm.Term.xvar term.self) +0)) ((Fm.Term.xvar term.name) +0))) (Fm.MPath.1 path)); (String.flatten (((List.cons String) self) (((List.cons String) open) (((List.cons String) name) (((List.cons String) ":") (((List.cons String) type) (((List.cons String) clos) (((List.cons String) " ") (((List.cons String) body) (List.nil String))))))))))) #term.orig #term.name #term.body !name = (Fm.Name.show term.name); !body = ((Fm.Term.show.go (term.body ((Fm.Term.xvar term.name) +0))) (Fm.MPath.0 path)); (String.flatten (((List.cons String) "(") (((List.cons String) name) (((List.cons String) ") ") (((List.cons String) body) (List.nil String))))))) #term.orig #term.func #term.argm (((Fm.Term.show.app term) path) (List.nil String))) #term.orig #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = ((Fm.Term.show.go term.expr) (Fm.MPath.0 path)); !body = ((Fm.Term.show.go (term.body ((Fm.Term.xvar term.name) +0))) (Fm.MPath.1 path)); (String.flatten (((List.cons String) "let ") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.orig #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = ((Fm.Term.show.go term.expr) (Fm.MPath.0 path)); !body = ((Fm.Term.show.go (term.body ((Fm.Term.xvar term.name) +0))) (Fm.MPath.1 path)); (String.flatten (((List.cons String) "def ") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.orig #term.done #term.term #term.type !term = ((Fm.Term.show.go term.term) (Fm.MPath.0 path)); !type = ((Fm.Term.show.go term.type) (Fm.MPath.1 path)); (String.flatten (((List.cons String) term) (((List.cons String) "::") (((List.cons String) type) (List.nil String)))))) #term.orig #term.name #term.dref #term.verb !name = (Fm.Name.show term.name); (String.flatten (((List.cons String) "?") (((List.cons String) name) (List.nil String))))) #term.orig #term.path "_") #term.orig #term.natx (String.flatten (((List.cons String) (Nat.show term.natx)) (List.nil String)))) #term.orig #term.chrx (String.flatten (((List.cons String) "\'") (((List.cons String) (Fm.escape.char term.chrx)) (((List.cons String) "\'") (List.nil String)))))) #term.orig #term.strx (String.flatten (((List.cons String) "\"") (((List.cons String) (Fm.escape term.strx)) (((List.cons String) "\"") (List.nil String)))))) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti !expr = ((Fm.Term.show.go term.expr) (Fm.MPath.0 path)); !name = (Fm.Name.show term.name); !with = ((String.join "") ((((List.mapped Fm.Def) term.with) String) #def ((def #def String) #def.name #def.term #def.type #def.stat !name = (Fm.Name.show def.name); !type = ((Fm.Term.show.go def.type) (Maybe.none @(:Bits) Bits)); !term = ((Fm.Term.show.go def.term) (Maybe.none @(:Bits) Bits)); (String.flatten (((List.cons String) name) (((List.cons String) ": ") (((List.cons String) type) (((List.cons String) " = ") (((List.cons String) term) (((List.cons String) ";") (List.nil String))))))))))); !cses = ((Map.to_list Fm.Term) term.cses); !cses = ((String.join "") ((((List.mapped ((Pair Bits) Fm.Term)) cses) String) #x !name = (Fm.Name.from_bits (((Pair.fst Bits) Fm.Term) x)); !term = ((Fm.Term.show.go (((Pair.snd Bits) Fm.Term) x)) (Maybe.none @(:Bits) Bits)); (String.flatten (((List.cons String) name) (((List.cons String) ": ") (((List.cons String) term) (((List.cons String) "; ") (List.nil String)))))))); !moti = ((Fm.Term.show.go term.moti) (Maybe.none @(:Bits) Bits)); (String.flatten (((List.cons String) "case ") (((List.cons String) expr) (((List.cons String) " as ") (((List.cons String) name) (((List.cons String) with) (((List.cons String) " { ") (((List.cons String) cses) (((List.cons String) "} : ") (((List.cons String) moti) (List.nil String))))))))))))) #as_nat.value as_nat.value);
Fm.Term.show.as_nat.go : @(term:Fm.Term) (Maybe Nat) = #term ((((((((((((((((term #term (Maybe Nat)) #term.orig #term.name #term.indx (Maybe.none Nat)) #term.orig #term.name (((((String.eql term.name) "Nat.zero") # (Maybe Nat)) ((Maybe.some Nat) +0)) (Maybe.none Nat))) #term.orig (Maybe.none Nat)) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body (Maybe.none Nat)) #term.orig #term.name #term.body (Maybe.none Nat)) #term.orig #term.func #term.argm ((((((((((((((((term.func #term.func (Maybe Nat)) #term.func.orig #term.func.name #term.func.indx (Maybe.none Nat)) #term.func.orig #term.func.name (((((String.eql term.func.name) "Nat.succ") # (Maybe Nat)) ((((((Monad.bind Maybe) Maybe.monad) Nat) Nat) (Fm.Term.show.as_nat.go term.argm)) #pred ((((Monad.pure Maybe) Maybe.monad) Nat) (Nat.succ pred)))) (Maybe.none Nat))) #term.func.orig (Maybe.none Nat)) #term.func.orig #term.func.eras #term.func.self #term.func.name #term.func.xtyp #term.func.body (Maybe.none Nat)) #term.func.orig #term.func.name #term.func.body (Maybe.none Nat)) #term.func.orig #term.func.func #term.func.argm (Maybe.none Nat)) #term.func.orig #term.func.name #term.func.expr #term.func.body (Maybe.none Nat)) #term.func.orig #term.func.name #term.func.expr #term.func.body (Maybe.none Nat)) #term.func.orig #term.func.done #term.func.term #term.func.type (Maybe.none Nat)) #term.func.orig #term.func.name #term.func.dref #term.func.verb (Maybe.none Nat)) #term.func.orig #term.func.path (Maybe.none Nat)) #term.func.orig #term.func.natx (Maybe.none Nat)) #term.func.orig #term.func.chrx (Maybe.none Nat)) #term.func.orig #term.func.strx (Maybe.none Nat)) #term.func.orig #term.func.path #term.func.expr #term.func.name #term.func.with #term.func.cses #term.func.moti (Maybe.none Nat))) #term.orig #term.name #term.expr #term.body (Maybe.none Nat)) #term.orig #term.name #term.expr #term.body (Maybe.none Nat)) #term.orig #term.done #term.term #term.type (Maybe.none Nat)) #term.orig #term.name #term.dref #term.verb (Maybe.none Nat)) #term.orig #term.path (Maybe.none Nat)) #term.orig #term.natx (Maybe.none Nat)) #term.orig #term.chrx (Maybe.none Nat)) #term.orig #term.strx (Maybe.none Nat)) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti (Maybe.none Nat));
Fm.Term.show.as_nat : @(term:Fm.Term) (Maybe String) = #term ((((Maybe.mapped Nat) (Fm.Term.show.as_nat.go term)) String) Nat.show);
Fm.Term.show.app : @(term:Fm.Term) @(path:(Maybe @(:Bits) Bits)) @(args:(List String)) String = #term #path #args ((((((((((((((((term #term String) #term.orig #term.name #term.indx !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.name !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.name #term.body !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.func #term.argm !argm = ((Fm.Term.show.go term.argm) (Fm.MPath.1 path)); (((Fm.Term.show.app term.func) (Fm.MPath.0 path)) (((List.cons String) argm) args))) #term.orig #term.name #term.expr #term.body !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.name #term.expr #term.body !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.done #term.term #term.type !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.name #term.dref #term.verb !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.path !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.natx !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.chrx !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.strx !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String))))))));
Fm.Term.show : @(term:Fm.Term) String = #term ((Fm.Term.show.go term) (Maybe.none @(:Bits) Bits));
Fm.Term.serialize.go : @(term:Fm.Term) @(depth:Nat) @(init:Nat) @(x:Bits) Bits = #term #depth #init #x ((((((((((((((((term #term Bits) #term.orig #term.name #term.indx (((((Nat.gte term.indx) init) # Bits) !name = (Bits.concat (Nat.to_bits (Nat.pred ((Nat.sub depth) term.indx)))); (Bits.0 (Bits.0 (Bits.1 (name x))))) !name = (Bits.concat (Nat.to_bits term.indx)); (Bits.0 (Bits.1 (Bits.0 (name x)))))) #term.orig #term.name !name = (Bits.concat (Fm.Name.to_bits term.name)); (Bits.0 (Bits.0 (Bits.0 (name x))))) #term.orig (Bits.0 (Bits.1 (Bits.1 x)))) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body !eras = (((term.eras # @(pred:Bits) Bits) Bits.1) Bits.0); !self = (Bits.concat (Fm.Name.to_bits term.self)); !xtyp = (((Fm.Term.serialize.go term.xtyp) depth) init); !body = (((Fm.Term.serialize.go ((term.body ((Fm.Term.xvar term.self) depth)) ((Fm.Term.xvar term.name) (Nat.succ depth)))) (Nat.succ (Nat.succ depth))) init); (Bits.1 (Bits.0 (Bits.0 (eras (self (xtyp (body x)))))))) #term.orig #term.name #term.body !body = (((Fm.Term.serialize.go (term.body ((Fm.Term.xvar term.name) depth))) (Nat.succ depth)) init); (Bits.1 (Bits.0 (Bits.1 (body x))))) #term.orig #term.func #term.argm !func = (((Fm.Term.serialize.go term.func) depth) init); !argm = (((Fm.Term.serialize.go term.argm) depth) init); (Bits.1 (Bits.1 (Bits.0 (func (argm x)))))) #term.orig #term.name #term.expr #term.body !expr = (((Fm.Term.serialize.go term.expr) depth) init); !body = (((Fm.Term.serialize.go (term.body ((Fm.Term.xvar term.name) depth))) (Nat.succ depth)) init); (Bits.1 (Bits.1 (Bits.1 (expr (body x)))))) #term.orig #term.name #term.expr #term.body ((((Fm.Term.serialize.go (term.body term.expr)) depth) init) x)) #term.orig #term.done #term.term #term.type ((((Fm.Term.serialize.go term.term) depth) init) x)) #term.orig #term.name #term.dref #term.verb !name = (Bits.concat (Fm.Name.to_bits term.name)); (Bits.0 (Bits.0 (Bits.0 (name x))))) #term.orig #term.path x) #term.orig #term.natx (Bits.0 (Bits.0 (Bits.0 ((Bits.concat (Nat.to_bits term.natx)) x))))) #term.orig #term.chrx (Bits.0 (Bits.0 (Bits.0 ((Bits.concat ((Word.to_bits +16) (U16.to_word term.chrx))) x))))) #term.orig #term.strx ((((Fm.Term.serialize.go (Fm.Term.unroll_str term.strx)) depth) init) x)) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti x);
Fm.Term.serialize : @(term:Fm.Term) @(depth:Nat) Bits = #term #depth ((((Fm.Term.serialize.go term) depth) depth) Bits.nil);
Fm.Term.ref : @(orig:(Maybe Fm.Origin)) @(name:Fm.Name) Fm.Term = #orig #name #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((ref orig) name);
Fm.Term.reduce : @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #term #defs ((((((((((((((((term #term Fm.Term) #term.orig #term.name #term.indx term) #term.orig #term.name ((((((Fm.get Fm.Def) term.name) defs) #got Fm.Term) ((Fm.Term.ref term.orig) term.name)) #got.value ((got.value #got.value Fm.Term) #got.value.name #got.value.term #got.value.type #got.value.stat ((Fm.Term.reduce got.value.term) defs)))) #term.orig term) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body term) #term.orig #term.name #term.body term) #term.orig #term.func #term.argm !func = ((Fm.Term.reduce term.func) defs); ((((((((((((((((func #func Fm.Term) #func.orig #func.name #func.indx term) #func.orig #func.name term) #func.orig term) #func.orig #func.eras #func.self #func.name #func.xtyp #func.body term) #func.orig #func.name #func.body ((Fm.Term.reduce (func.body term.argm)) defs)) #func.orig #func.func #func.argm term) #func.orig #func.name #func.expr #func.body term) #func.orig #func.name #func.expr #func.body term) #func.orig #func.done #func.term #func.type term) #func.orig #func.name #func.dref #func.verb term) #func.orig #func.path term) #func.orig #func.natx term) #func.orig #func.chrx term) #func.orig #func.strx term) #func.orig #func.path #func.expr #func.name #func.with #func.cses #func.moti term)) #term.orig #term.name #term.expr #term.body ((Fm.Term.reduce (term.body term.expr)) defs)) #term.orig #term.name #term.expr #term.body ((Fm.Term.reduce (term.body term.expr)) defs)) #term.orig #term.done #term.term #term.type ((Fm.Term.reduce term.term) defs)) #term.orig #term.name #term.dref #term.verb term) #term.orig #term.path term) #term.orig #term.natx ((Fm.Term.reduce (Fm.Term.unroll_nat term.natx)) defs)) #term.orig #term.chrx ((Fm.Term.reduce (Fm.Term.unroll_chr term.chrx)) defs)) #term.orig #term.strx ((Fm.Term.reduce (Fm.Term.unroll_str term.strx)) defs)) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti term);
Fm.Term.patch_at : @(path:Bits) @(term:Fm.Term) @(fn:@(:Fm.Term) Fm.Term) Fm.Term = #path #term #fn ((((((((((((((((term #term Fm.Term) #term.orig #term.name #term.indx ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.orig #term.name ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.orig ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body ((((path #path Fm.Term) (fn term)) #path.pred ((((((Fm.Term.all term.orig) term.eras) term.self) term.name) (((Fm.Term.patch_at path.pred) term.xtyp) fn)) term.body)) #path.pred ((((((Fm.Term.all term.orig) term.eras) term.self) term.name) term.xtyp) #s #x (((Fm.Term.patch_at path.pred) ((term.body s) x)) fn)))) #term.orig #term.name #term.body ((((path #path Fm.Term) (fn term)) #path.pred (((Fm.Term.lam term.orig) term.name) #x (((Fm.Term.patch_at (Bits.tail path)) (term.body x)) fn))) #path.pred (((Fm.Term.lam term.orig) term.name) #x (((Fm.Term.patch_at (Bits.tail path)) (term.body x)) fn)))) #term.orig #term.func #term.argm ((((path #path Fm.Term) (fn term)) #path.pred (((Fm.Term.app term.orig) (((Fm.Term.patch_at path.pred) term.func) fn)) term.argm)) #path.pred (((Fm.Term.app term.orig) term.func) (((Fm.Term.patch_at path.pred) term.argm) fn)))) #term.orig #term.name #term.expr #term.body ((((path #path Fm.Term) (fn term)) #path.pred ((((Fm.Term.let term.orig) term.name) (((Fm.Term.patch_at path.pred) term.expr) fn)) term.body)) #path.pred ((((Fm.Term.let term.orig) term.name) term.expr) #x (((Fm.Term.patch_at path.pred) (term.body x)) fn)))) #term.orig #term.name #term.expr #term.body ((((path #path Fm.Term) (fn term)) #path.pred ((((Fm.Term.def term.orig) term.name) (((Fm.Term.patch_at path.pred) term.expr) fn)) term.body)) #path.pred ((((Fm.Term.def term.orig) term.name) term.expr) #x (((Fm.Term.patch_at path.pred) (term.body x)) fn)))) #term.orig #term.done #term.term #term.type ((((path #path Fm.Term) (fn term)) #path.pred ((((Fm.Term.ann term.orig) term.done) (((Fm.Term.patch_at path) term.term) fn)) term.type)) #path.pred ((((Fm.Term.ann term.orig) term.done) (((Fm.Term.patch_at path) term.term) fn)) term.type))) #term.orig #term.name #term.dref #term.verb ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.orig #term.path ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.orig #term.natx ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.orig #term.chrx ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.orig #term.strx ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term));
Fm.Term.origin : @(term:Fm.Term) (Maybe Fm.Origin) = #term ((((((((((((((((term #term (Maybe Fm.Origin)) #term.orig #term.name #term.indx term.orig) #term.orig #term.name term.orig) #term.orig term.orig) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body term.orig) #term.orig #term.name #term.body term.orig) #term.orig #term.func #term.argm term.orig) #term.orig #term.name #term.expr #term.body term.orig) #term.orig #term.name #term.expr #term.body term.orig) #term.orig #term.done #term.term #term.type term.orig) #term.orig #term.name #term.dref #term.verb term.orig) #term.orig #term.path term.orig) #term.orig #term.natx term.orig) #term.orig #term.chrx term.orig) #term.orig #term.strx term.orig) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti term.orig);
Fm.Term.normalize : @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #term #defs ((((((((((((((((((Fm.Term.reduce term) defs) #term Fm.Term) #term.orig #term.name #term.indx (((Fm.Term.var term.orig) term.name) term.indx)) #term.orig #term.name ((Fm.Term.ref term.orig) term.name)) #term.orig (Fm.Term.typ term.orig)) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body $xtyp = ((Fm.Term.normalize term.xtyp) defs); $body = #s #x ((Fm.Term.normalize ((term.body s) x)) defs); ((((((Fm.Term.all term.orig) term.eras) term.self) term.name) xtyp) body)) #term.orig #term.name #term.body $body = #x ((Fm.Term.normalize (term.body x)) defs); (((Fm.Term.lam term.orig) term.name) body)) #term.orig #term.func #term.argm $func = ((Fm.Term.normalize term.func) defs); $argm = ((Fm.Term.normalize term.argm) defs); (((Fm.Term.app term.orig) func) argm)) #term.orig #term.name #term.expr #term.body $expr = ((Fm.Term.normalize term.expr) defs); $body = #x ((Fm.Term.normalize (term.body x)) defs); ((((Fm.Term.let term.orig) term.name) expr) body)) #term.orig #term.name #term.expr #term.body $expr = ((Fm.Term.normalize term.expr) defs); $body = #x ((Fm.Term.normalize (term.body x)) defs); ((((Fm.Term.def term.orig) term.name) expr) body)) #term.orig #term.done #term.term #term.type $term = ((Fm.Term.normalize term.term) defs); $type = ((Fm.Term.normalize term.type) defs); ((((Fm.Term.ann term.orig) term.done) term) type)) #term.orig #term.name #term.dref #term.verb ((((Fm.Term.gol term.orig) term.name) term.dref) term.verb)) #term.orig #term.path ((Fm.Term.hol term.orig) term.path)) #term.orig #term.natx ((Fm.Term.nat term.orig) term.natx)) #term.orig #term.chrx ((Fm.Term.chr term.orig) term.chrx)) #term.orig #term.strx ((Fm.Term.str term.orig) term.strx)) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti term);
Fm.Term.nat : @(orig:(Maybe Fm.Origin)) @(natx:Nat) Fm.Term = #orig #natx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((nat orig) natx);
Fm.Term.let : @(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) Fm.Term = #orig #name #expr #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((((let orig) name) expr) body);
Fm.Term.lam : @(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(body:@(:Fm.Term) Fm.Term) Fm.Term = #orig #name #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((lam orig) name) body);
Fm.Term.hol : @(orig:(Maybe Fm.Origin)) @(path:Bits) Fm.Term = #orig #path #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((hol orig) path);
Fm.Term.gol : @(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) Fm.Term = #orig #name #dref #verb #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((((gol orig) name) dref) verb);
Fm.Term.expand_ct : @(term:Fm.Term) @(defs:Fm.Defs) @(arity:Nat) Fm.Term = #term #defs #arity ((((((((((((((((term #term Fm.Term) #term.orig #term.name #term.indx (((Fm.Term.var term.orig) term.name) term.indx)) #term.orig #term.name !expand = Bool.false; !expand = ((Bool.or ((Bool.and ((String.eql term.name) "Nat.succ")) ((Nat.gtn arity) +1))) expand); !expand = ((Bool.or ((Bool.and ((String.eql term.name) "Nat.zero")) ((Nat.gtn arity) +0))) expand); !expand = ((Bool.or ((Bool.and ((String.eql term.name) "Bool.true")) ((Nat.gtn arity) +0))) expand); !expand = ((Bool.or ((Bool.and ((String.eql term.name) "Bool.false")) ((Nat.gtn arity) +0))) expand); (((expand # Fm.Term) ((((((Fm.get Fm.Def) term.name) defs) #got Fm.Term) ((Fm.Term.ref term.orig) term.name)) #got.value ((got.value #got.value Fm.Term) #got.value.name #got.value.term #got.value.type #got.value.stat got.value.term))) ((Fm.Term.ref term.orig) term.name))) #term.orig (Fm.Term.typ term.orig)) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body $xtyp = (((Fm.Term.expand_ct term.xtyp) defs) +0); $body = #s #x (((Fm.Term.expand_ct ((term.body s) x)) defs) +0); ((((((Fm.Term.all term.orig) term.eras) term.self) term.name) xtyp) body)) #term.orig #term.name #term.body $body = #x (((Fm.Term.expand_ct (term.body x)) defs) +0); (((Fm.Term.lam term.orig) term.name) body)) #term.orig #term.func #term.argm $func = (((Fm.Term.expand_ct term.func) defs) (Nat.succ arity)); $argm = (((Fm.Term.expand_ct term.argm) defs) +0); (((Fm.Term.app term.orig) func) argm)) #term.orig #term.name #term.expr #term.body $expr = (((Fm.Term.expand_ct term.expr) defs) +0); $body = #x (((Fm.Term.expand_ct (term.body x)) defs) +0); ((((Fm.Term.let term.orig) term.name) expr) body)) #term.orig #term.name #term.expr #term.body $expr = (((Fm.Term.expand_ct term.expr) defs) +0); $body = #x (((Fm.Term.expand_ct (term.body x)) defs) +0); ((((Fm.Term.def term.orig) term.name) expr) body)) #term.orig #term.done #term.term #term.type $term = (((Fm.Term.expand_ct term.term) defs) +0); $type = (((Fm.Term.expand_ct term.type) defs) +0); ((((Fm.Term.ann term.orig) term.done) term) type)) #term.orig #term.name #term.dref #term.verb ((((Fm.Term.gol term.orig) term.name) term.dref) term.verb)) #term.orig #term.path ((Fm.Term.hol term.orig) term.path)) #term.orig #term.natx ((Fm.Term.nat term.orig) term.natx)) #term.orig #term.chrx ((Fm.Term.chr term.orig) term.chrx)) #term.orig #term.strx ((Fm.Term.str term.orig) term.strx)) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti term);
Fm.Term.expand_at : @(path:Bits) @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #path #term #defs (((Fm.Term.patch_at path) term) #term ((((((((((((((((term #term Fm.Term) #term.orig #term.name #term.indx term) #term.orig #term.name ((((((Fm.get Fm.Def) term.name) defs) #got Fm.Term) ((Fm.Term.ref term.orig) term.name)) #got.value ((got.value #got.value Fm.Term) #got.value.name #got.value.term #got.value.type #got.value.stat got.value.term))) #term.orig term) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body term) #term.orig #term.name #term.body term) #term.orig #term.func #term.argm term) #term.orig #term.name #term.expr #term.body term) #term.orig #term.name #term.expr #term.body term) #term.orig #term.done #term.term #term.type term) #term.orig #term.name #term.dref #term.verb term) #term.orig #term.path term) #term.orig #term.natx term) #term.orig #term.chrx term) #term.orig #term.strx term) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti term));
Fm.Term.expand : @(dref:(List Bits)) @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #dref #term #defs !term = ((Fm.Term.normalize term) (Map.new Fm.Def)); !term = (((((List.for Bits) dref) Fm.Term) term) #path #term !term = (((Fm.Term.expand_at path) term) defs); !term = ((Fm.Term.normalize term) (Map.new Fm.Def)); !term = (((Fm.Term.expand_ct term) defs) +0); !term = ((Fm.Term.normalize term) (Map.new Fm.Def)); term); term;
Fm.Term.equal.patch : @(path:Bits) @(term:Fm.Term) (Fm.Check Bool) = #path #term (((Fm.Check.result Bool) ((Maybe.some Bool) Bool.true)) (((List.cons Fm.Error) ((Fm.Error.patch path) ((Fm.Term.normalize term) (Map.new Fm.Def)))) (List.nil Fm.Error)));
Fm.Term.equal : @(a:Fm.Term) @(b:Fm.Term) @(defs:Fm.Defs) @(lv:Nat) @(seen:Set) (Fm.Check Bool) = #a #b #defs #lv #seen !a1 = ((Fm.Term.reduce a) defs); !b1 = ((Fm.Term.reduce b) defs); !ah = ((Fm.Term.serialize a1) lv); !bh = ((Fm.Term.serialize b1) lv); !id = ((Bits.concat ah) bh); (((((Bool.or ((Bits.eql ah) bh)) ((Set.has id) seen)) # (Fm.Check Bool)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.true)) ((((((((((((((((a1 #a1 (Fm.Check Bool)) #a1.orig #a1.name #a1.indx ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.name ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.eras #a1.self #a1.name #a1.xtyp #a1.body ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body !seen = ((Set.set id) seen); !a1_body = ((a1.body ((Fm.Term.xvar a1.self) lv)) ((Fm.Term.xvar a1.name) (Nat.succ lv))); !b1_body = ((b1.body ((Fm.Term.xvar b1.self) lv)) ((Fm.Term.xvar b1.name) (Nat.succ lv))); !eq_self = ((String.eql a1.self) b1.self); !eq_eras = ((Bool.eql a1.eras) b1.eras); (((((Bool.and eq_self) eq_eras) # (Fm.Check Bool)) ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.xtyp) b1.xtyp) defs) lv) seen)) #eq_type ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1_body) b1_body) defs) (Nat.succ (Nat.succ lv))) seen)) #eq_body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) ((Bool.and eq_type) eq_body))))) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.name #a1.body ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body !seen = ((Set.set id) seen); !a1_body = (a1.body ((Fm.Term.xvar a1.name) lv)); !b1_body = (b1.body ((Fm.Term.xvar b1.name) lv)); ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1_body) b1_body) defs) (Nat.succ lv)) seen)) #eq_body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) eq_body))) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.func #a1.argm ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm !seen = ((Set.set id) seen); ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.func) b1.func) defs) lv) seen)) #eq_func ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.argm) b1.argm) defs) lv) seen)) #eq_argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) ((Bool.and eq_func) eq_argm))))) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.name #a1.expr #a1.body ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body !seen = ((Set.set id) seen); !a1_body = (a1.body ((Fm.Term.xvar a1.name) lv)); !b1_body = (b1.body ((Fm.Term.xvar b1.name) lv)); ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.expr) b1.expr) defs) lv) seen)) #eq_expr ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1_body) b1_body) defs) (Nat.succ lv)) seen)) #eq_body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) ((Bool.and eq_expr) eq_body))))) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.name #a1.expr #a1.body ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.done #a1.term #a1.type ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.name #a1.dref #a1.verb ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.path ((Fm.Term.equal.patch a1.path) b)) #a1.orig #a1.natx ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.chrx ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.strx ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.orig #a1.path #a1.expr #a1.name #a1.with #a1.cses #a1.moti ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.orig #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.orig #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.orig #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))));
Fm.Term.desugar_cse.motive : @(wyth:(List Fm.Def)) @(moti:Fm.Term) Fm.Term = #wyth #moti (((wyth #wyth Fm.Term) moti) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $all_name = wyth.head.name; $all_xtyp = wyth.head.type; $all_body = #s #x ((Fm.Term.desugar_cse.motive wyth.tail) moti); (((((Fm.Term.xall Bool.false) "") all_name) all_xtyp) all_body)));
Fm.Term.desugar_cse.cases : @(expr:Fm.Term) @(name:Fm.Name) @(wyth:(List Fm.Def)) @(cses:(Map Fm.Term)) @(type:Fm.Term) @(defs:Fm.Defs) @(ctxt:Fm.Context) Fm.Term = #expr #name #wyth #cses #type #defs #ctxt ((((((((((((((((((Fm.Term.reduce type) defs) #type Fm.Term) #type.orig #type.name #type.indx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.name !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.eras #type.self #type.name #type.xtyp #type.body !got = (((Maybe.or Fm.Term) (((Fm.get Fm.Term) type.name) cses)) (((Fm.get Fm.Term) "_") cses)); (((got #got Fm.Term) !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((def #def Fm.Term) #def.name #def.term #def.type #def.stat ((Fm.Term.xapp expr) def.term))); expr) #got.value !argm = (((((Fm.Term.desugar_cse.argument name) wyth) type.xtyp) got.value) defs); !expr = ((Fm.Term.xapp expr) argm); !type = ((type.body ((Fm.Term.xvar type.self) +0)) ((Fm.Term.xvar type.name) +0)); (((((((Fm.Term.desugar_cse.cases expr) name) wyth) cses) type) defs) ctxt))) #type.orig #type.name #type.body !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.func #type.argm !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.name #type.expr #type.body !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.name #type.expr #type.body !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.done #type.term #type.type !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.name #type.dref #type.verb !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.path !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.natx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.chrx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.strx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.orig #type.path #type.expr #type.name #type.with #type.cses #type.moti !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.xapp expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr);
Fm.Term.desugar_cse.argument : @(name:Fm.Name) @(wyth:(List Fm.Def)) @(type:Fm.Term) @(body:Fm.Term) @(defs:Fm.Defs) Fm.Term = #name #wyth #type #body #defs ((((((((((((((((((Fm.Term.reduce type) defs) #type Fm.Term) #type.orig #type.name #type.indx (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.name (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.eras #type.self #type.name #type.xtyp #type.body $type = ((type.body ((Fm.Term.xvar type.self) +0)) ((Fm.Term.xvar type.name) +0)); $lam_name = ((((String.is_empty type.name) # Fm.Name) name) (String.flatten (((List.cons String) name) (((List.cons String) ".") (((List.cons Fm.Name) type.name) (List.nil Fm.Name)))))); $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)) #type.orig #type.name #type.body (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.func #type.argm (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.name #type.expr #type.body (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.name #type.expr #type.body (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.done #type.term #type.type (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.name #type.dref #type.verb (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.path (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.natx (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.chrx (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.strx (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body)))) #type.orig #type.path #type.expr #type.name #type.with #type.cses #type.moti (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.xlam lam_name) lam_body))));
Fm.Term.desugar_cse : @(expr:Fm.Term) @(name:Fm.Name) @(with:(List Fm.Def)) @(cses:(Map Fm.Term)) @(moti:Fm.Term) @(type:Fm.Term) @(defs:Fm.Defs) @(ctxt:Fm.Context) (Maybe Fm.Term) = #expr #name #with #cses #moti #type #defs #ctxt ((((((((((((((((((Fm.Term.reduce type) defs) #type (Maybe Fm.Term)) #type.orig #type.name #type.indx (Maybe.none Fm.Term)) #type.orig #type.name (Maybe.none Fm.Term)) #type.orig (Maybe.none Fm.Term)) #type.orig #type.eras #type.self #type.name #type.xtyp #type.body !moti = ((Fm.Term.desugar_cse.motive with) moti); !argm = (((((Fm.Term.desugar_cse.argument name) (List.nil Fm.Def)) type.xtyp) moti) defs); !expr = ((Fm.Term.xapp expr) argm); !type = ((type.body ((Fm.Term.xvar type.self) +0)) ((Fm.Term.xvar type.name) +0)); ((Maybe.some Fm.Term) (((((((Fm.Term.desugar_cse.cases expr) name) with) cses) type) defs) ctxt))) #type.orig #type.name #type.body (Maybe.none Fm.Term)) #type.orig #type.func #type.argm (Maybe.none Fm.Term)) #type.orig #type.name #type.expr #type.body (Maybe.none Fm.Term)) #type.orig #type.name #type.expr #type.body (Maybe.none Fm.Term)) #type.orig #type.done #type.term #type.type (Maybe.none Fm.Term)) #type.orig #type.name #type.dref #type.verb (Maybe.none Fm.Term)) #type.orig #type.path (Maybe.none Fm.Term)) #type.orig #type.natx (Maybe.none Fm.Term)) #type.orig #type.chrx (Maybe.none Fm.Term)) #type.orig #type.strx (Maybe.none Fm.Term)) #type.orig #type.path #type.expr #type.name #type.with #type.cses #type.moti (Maybe.none Fm.Term));
Fm.Term.def : @(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) Fm.Term = #orig #name #expr #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((((def orig) name) expr) body);
Fm.Term.cse : @(orig:(Maybe Fm.Origin)) @(path:Bits) @(expr:Fm.Term) @(name:Fm.Name) @(with:(List Fm.Def)) @(cses:(Map Fm.Term)) @(moti:Fm.Term) Fm.Term = #orig #path #expr #name #with #cses #moti #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((((((cse orig) path) expr) name) with) cses) moti);
Fm.Term.core : @(term:Fm.Term) String = #term ((((((((((((((((term #term String) #term.orig #term.name #term.indx (Fm.Name.show term.name)) #term.orig #term.name (Fm.Name.show term.name)) #term.orig "*") #term.orig #term.eras #term.self #term.name #term.xtyp #term.body !eras = term.eras; !init = (((eras # String) "%") "@"); !self = (Fm.Name.show term.self); !name = (Fm.Name.show term.name); !xtyp = (Fm.Term.core term.xtyp); !body = (Fm.Term.core ((term.body ((Fm.Term.xvar term.self) +0)) ((Fm.Term.xvar term.name) +0))); (String.flatten (((List.cons String) init) (((List.cons String) self) (((List.cons String) "(") (((List.cons String) name) (((List.cons String) ":") (((List.cons String) xtyp) (((List.cons String) ") ") (((List.cons String) body) (List.nil String))))))))))) #term.orig #term.name #term.body !name = (Fm.Name.show term.name); !body = (Fm.Term.core (term.body ((Fm.Term.xvar term.name) +0))); (String.flatten (((List.cons String) "#") (((List.cons String) name) (((List.cons String) " ") (((List.cons String) body) (List.nil String))))))) #term.orig #term.func #term.argm !func = (Fm.Term.core term.func); !argm = (Fm.Term.core term.argm); (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) " ") (((List.cons String) argm) (((List.cons String) ")") (List.nil String)))))))) #term.orig #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = (Fm.Term.core term.expr); !body = (Fm.Term.core (term.body ((Fm.Term.xvar term.name) +0))); (String.flatten (((List.cons String) "!") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.orig #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = (Fm.Term.core term.expr); !body = (Fm.Term.core (term.body ((Fm.Term.xvar term.name) +0))); (String.flatten (((List.cons String) "$") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.orig #term.done #term.term #term.type !term = (Fm.Term.core term.term); !type = (Fm.Term.core term.type); (String.flatten (((List.cons String) "{") (((List.cons String) term) (((List.cons String) ":") (((List.cons String) type) (((List.cons String) "}") (List.nil String)))))))) #term.orig #term.name #term.dref #term.verb "<ERROR>") #term.orig #term.path "<ERROR>") #term.orig #term.natx (String.flatten (((List.cons String) "+") (((List.cons String) (Nat.show term.natx)) (List.nil String))))) #term.orig #term.chrx (String.flatten (((List.cons String) "\'") (((List.cons String) (Fm.escape.char term.chrx)) (((List.cons String) "\'") (List.nil String)))))) #term.orig #term.strx (String.flatten (((List.cons String) "\"") (((List.cons String) (Fm.escape term.strx)) (((List.cons String) "\"") (List.nil String)))))) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti "<ERROR>");
Fm.Term.chr : @(orig:(Maybe Fm.Origin)) @(chrx:Char) Fm.Term = #orig #chrx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((chr orig) chrx);
Fm.Term.check : @(term:Fm.Term) @(type:(Maybe Fm.Term)) @(defs:Fm.Defs) @(ctx:Fm.Context) @(path:Fm.MPath) (Fm.Check Fm.Term) = #term #type #defs #ctx #path ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) ((((((((((((((((term #term (Fm.Check Fm.Term)) #term.orig #term.name #term.indx ((((((List.at_last ((Pair Fm.Name) Fm.Term)) term.indx) ctx) #got (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((Fm.Error.undefined_reference term.orig) term.name)) (List.nil Fm.Error)))) #got.value ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) ((got.value #got.value Fm.Term) #got.value.fst #got.value.snd got.value.snd)))) #term.orig #term.name ((((((Fm.get Fm.Def) term.name) defs) #got (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((Fm.Error.undefined_reference term.orig) term.name)) (List.nil Fm.Error)))) #got.value ((got.value #got.value (Fm.Check Fm.Term)) #got.value.name #got.value.term #got.value.type #got.value.stat !ref_name = got.value.name; !ref_type = got.value.type; !ref_term = got.value.term; !ref_stat = got.value.stat; (((((ref_stat #ref_stat (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) ref_type)) (((List.cons Fm.Error) (Fm.Error.waiting ref_name)) (List.nil Fm.Error)))) (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) ref_type)) (List.nil Fm.Error))) (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) ref_type)) (List.nil Fm.Error))) #ref_stat.errors (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) ref_type)) (((List.cons Fm.Error) (Fm.Error.indirect ref_name)) (List.nil Fm.Error))))))) #term.orig ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term.xtyp)) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); !self_var = ((Fm.Term.xvar term.self) ctx_size); !body_var = ((Fm.Term.xvar term.name) (Nat.succ ctx_size)); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) term.xtyp)) (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.self) term)) ctx)); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.xtyp) ((Maybe.some Fm.Term) Fm.Term.xtyp)) defs) ctx) (Fm.MPath.0 path))) # ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check ((term.body self_var) body_var)) ((Maybe.some Fm.Term) Fm.Term.xtyp)) defs) body_ctx) (Fm.MPath.1 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term.xtyp)))) #term.orig #term.name #term.body (((type #type (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.cant_infer term.orig) term) ctx)) (List.nil Fm.Error)))) #type.value !typv = ((Fm.Term.reduce type.value) defs); ((((((((((((((((typv #typv (Fm.Check Fm.Term)) #typv.orig #typv.name #typv.indx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.name !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.eras #typv.self #typv.name #typv.xtyp #typv.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); !self_var = term; !body_var = ((Fm.Term.xvar term.name) ctx_size); !body_typ = ((typv.body self_var) body_var); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) typv.xtyp)) ctx); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check (term.body body_var)) ((Maybe.some Fm.Term) body_typ)) defs) body_ctx) (Fm.MPath.0 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) type.value))) #typv.orig #typv.name #typv.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.func #typv.argm !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.name #typv.expr #typv.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.name #typv.expr #typv.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.done #typv.term #typv.type !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.name #typv.dref #typv.verb !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.path !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.natx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.chrx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.strx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #typv.orig #typv.path #typv.expr #typv.name #typv.with #typv.cses #typv.moti !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))))) #term.orig #term.func #term.argm ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.func) (Maybe.none Fm.Term)) defs) ctx) (Fm.MPath.0 path))) #func_typ !func_typ = ((Fm.Term.reduce func_typ) defs); ((((((((((((((((func_typ #func_typ (Fm.Check Fm.Term)) #func_typ.orig #func_typ.name #func_typ.indx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.name !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.eras #func_typ.self #func_typ.name #func_typ.xtyp #func_typ.body ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.argm) ((Maybe.some Fm.Term) func_typ.xtyp)) defs) ctx) (Fm.MPath.1 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) ((func_typ.body term.func) term.argm)))) #func_typ.orig #func_typ.name #func_typ.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.func #func_typ.argm !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.name #func_typ.expr #func_typ.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.name #func_typ.expr #func_typ.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.done #func_typ.term #func_typ.type !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.name #func_typ.dref #func_typ.verb !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.path !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.natx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.chrx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.strx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.orig #func_typ.path #func_typ.expr #func_typ.name #func_typ.with #func_typ.cses #func_typ.moti !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch term.orig) expected) detected) ctx)) (List.nil Fm.Error)))))) #term.orig #term.name #term.expr #term.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.expr) (Maybe.none Fm.Term)) defs) ctx) (Fm.MPath.0 path))) #expr_typ !body_val = (term.body ((Fm.Term.xvar term.name) ctx_size)); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) expr_typ)) ctx); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check body_val) type) defs) body_ctx) (Fm.MPath.1 path))) #body_typ ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) body_typ)))) #term.orig #term.name #term.expr #term.body (((((Fm.Term.check (term.body term.expr)) type) defs) ctx) path)) #term.orig #term.done #term.term #term.type (((term.done # (Fm.Check Fm.Term)) ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) term.type)) ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.term) ((Maybe.some Fm.Term) term.type)) defs) ctx) (Fm.MPath.0 path))) # ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.type) ((Maybe.some Fm.Term) Fm.Term.xtyp)) defs) ctx) (Fm.MPath.1 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) term.type))))) #term.orig #term.name #term.dref #term.verb (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((((Fm.Error.show_goal term.name) term.dref) term.verb) type) ctx)) (List.nil Fm.Error)))) #term.orig #term.path (((Fm.Check.result Fm.Term) type) (List.nil Fm.Error))) #term.orig #term.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) (Fm.Term.xref "Nat"))) #term.orig #term.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) (Fm.Term.xref "Char"))) #term.orig #term.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) (Fm.Term.xref "String"))) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti !expr = term.expr; ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check expr) (Maybe.none Fm.Term)) defs) ctx) (Fm.MPath.0 path))) #etyp !dsug = ((((((((Fm.Term.desugar_cse term.expr) term.name) term.with) term.cses) term.moti) etyp) defs) ctx); (((dsug #dsug (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.cant_infer term.orig) term) ctx)) (List.nil Fm.Error)))) #dsug.value (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((Fm.Error.patch (Fm.MPath.to_bits path)) dsug.value)) (List.nil Fm.Error))))))) #infr (((type #type (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) infr)) (List.nil Fm.Error))) #type.value ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Fm.Term) (((((Fm.Term.equal type.value) infr) defs) ((List.length ((Pair Fm.Name) Fm.Term)) ctx)) Set.new)) #eqls (((eqls # (Fm.Check Fm.Term)) ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) type.value)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((((Fm.Error.type_mismatch (Fm.Term.origin term)) (((Either.right String) Fm.Term) type.value)) (((Either.right String) Fm.Term) infr)) ctx)) (List.nil Fm.Error)))))));
Fm.Term.bind : @(vars:Fm.Context) @(path:Fm.Path) @(term:Fm.Term) Fm.Term = #vars #path #term ((((((((((((((((term #term Fm.Term) #term.orig #term.name #term.indx ((((((List.at_last ((Pair Fm.Name) Fm.Term)) term.indx) vars) #got Fm.Term) (((Fm.Term.var term.orig) term.name) term.indx)) #got.value (((Pair.snd Fm.Name) Fm.Term) got.value))) #term.orig #term.name (((((Fm.Context.find term.name) vars) #got Fm.Term) ((Fm.Term.ref term.orig) term.name)) #got.value got.value)) #term.orig (Fm.Term.typ term.orig)) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $xtyp = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.xtyp); $body = #s #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.self) s)) vars))) (Fm.Path.1 path)) ((term.body ((Fm.Term.xvar term.self) vlen)) ((Fm.Term.xvar term.name) (Nat.succ vlen)))); ((((((Fm.Term.all term.orig) term.eras) term.self) term.name) xtyp) body)) #term.orig #term.name #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $body = #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) vars)) (Fm.Path.0 path)) (term.body ((Fm.Term.xvar term.name) vlen))); (((Fm.Term.lam term.orig) term.name) body)) #term.orig #term.func #term.argm $func = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.func); $argm = (((Fm.Term.bind vars) (Fm.Path.1 path)) term.argm); (((Fm.Term.app term.orig) func) argm)) #term.orig #term.name #term.expr #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $expr = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.expr); $body = #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) vars)) (Fm.Path.1 path)) (term.body ((Fm.Term.xvar term.name) vlen))); ((((Fm.Term.let term.orig) term.name) expr) body)) #term.orig #term.name #term.expr #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $expr = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.expr); $body = #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) vars)) (Fm.Path.1 path)) (term.body ((Fm.Term.xvar term.name) vlen))); ((((Fm.Term.def term.orig) term.name) expr) body)) #term.orig #term.done #term.term #term.type $term = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.term); $type = (((Fm.Term.bind vars) (Fm.Path.1 path)) term.type); ((((Fm.Term.ann term.orig) term.done) term) type)) #term.orig #term.name #term.dref #term.verb ((((Fm.Term.gol term.orig) term.name) term.dref) term.verb)) #term.orig #term.path ((Fm.Term.hol term.orig) (Fm.Path.to_bits path))) #term.orig #term.natx ((Fm.Term.nat term.orig) term.natx)) #term.orig #term.chrx ((Fm.Term.chr term.orig) term.chrx)) #term.orig #term.strx ((Fm.Term.str term.orig) term.strx)) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti !expr = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.expr); !name = term.name; !with = term.with; !cses = term.cses; !moti = term.moti; (((((((Fm.Term.cse term.orig) (Fm.Path.to_bits path)) expr) name) with) cses) moti));
Fm.Term.app : @(orig:(Maybe Fm.Origin)) @(func:Fm.Term) @(argm:Fm.Term) Fm.Term = #orig #func #argm #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((app orig) func) argm);
Fm.Term.ann : @(orig:(Maybe Fm.Origin)) @(done:Bool) @(term:Fm.Term) @(type:Fm.Term) Fm.Term = #orig #done #term #type #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((((ann orig) done) term) type);
Fm.Term.all : @(orig:(Maybe Fm.Origin)) @(eras:Bool) @(self:Fm.Name) @(name:Fm.Name) @(xtyp:Fm.Term) @(body:@(:Fm.Term) @(:Fm.Term) Fm.Term) Fm.Term = #orig #eras #self #name #xtyp #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((((((all orig) eras) self) name) xtyp) body);
Fm.Term : * = %Fm.Term.Self(P:@(:Fm.Term) *) @(var:@(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(indx:Nat) (P (((Fm.Term.var orig) name) indx))) @(ref:@(orig:(Maybe Fm.Origin)) @(name:Fm.Name) (P ((Fm.Term.ref orig) name))) @(typ:@(orig:(Maybe Fm.Origin)) (P (Fm.Term.typ orig))) @(all:@(orig:(Maybe Fm.Origin)) @(eras:Bool) @(self:Fm.Name) @(name:Fm.Name) @(xtyp:Fm.Term) @(body:@(:Fm.Term) @(:Fm.Term) Fm.Term) (P ((((((Fm.Term.all orig) eras) self) name) xtyp) body))) @(lam:@(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(body:@(:Fm.Term) Fm.Term) (P (((Fm.Term.lam orig) name) body))) @(app:@(orig:(Maybe Fm.Origin)) @(func:Fm.Term) @(argm:Fm.Term) (P (((Fm.Term.app orig) func) argm))) @(let:@(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) (P ((((Fm.Term.let orig) name) expr) body))) @(def:@(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) (P ((((Fm.Term.def orig) name) expr) body))) @(ann:@(orig:(Maybe Fm.Origin)) @(done:Bool) @(term:Fm.Term) @(type:Fm.Term) (P ((((Fm.Term.ann orig) done) term) type))) @(gol:@(orig:(Maybe Fm.Origin)) @(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) (P ((((Fm.Term.gol orig) name) dref) verb))) @(hol:@(orig:(Maybe Fm.Origin)) @(path:Bits) (P ((Fm.Term.hol orig) path))) @(nat:@(orig:(Maybe Fm.Origin)) @(natx:Nat) (P ((Fm.Term.nat orig) natx))) @(chr:@(orig:(Maybe Fm.Origin)) @(chrx:Char) (P ((Fm.Term.chr orig) chrx))) @(str:@(orig:(Maybe Fm.Origin)) @(strx:String) (P ((Fm.Term.str orig) strx))) @(cse:@(orig:(Maybe Fm.Origin)) @(path:Bits) @(expr:Fm.Term) @(name:Fm.Name) @(with:(List Fm.Def)) @(cses:(Map Fm.Term)) @(moti:Fm.Term) (P (((((((Fm.Term.cse orig) path) expr) name) with) cses) moti))) (P Fm.Term.Self);
Fm.Synth.one : @(name:Fm.Name) @(defs:Fm.Defs) Fm.Defs = #name #defs ((((((Fm.get Fm.Def) name) defs) #got Fm.Defs) defs) #got.value ((got.value #got.value Fm.Defs) #got.value.name #got.value.term #got.value.type #got.value.stat !name = got.value.name; !term = got.value.term; !type = got.value.type; !stat = got.value.stat; (((((stat #stat Fm.Defs) !defs = ((((Fm.set Fm.Def) name) ((((Fm.Def.new name) term) type) Fm.Status.wait)) defs); !checked = ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Unit) (((((Fm.Term.check type) ((Maybe.some Fm.Term) Fm.Term.xtyp)) defs) (List.nil ((Pair Fm.Name) Fm.Term))) (Fm.MPath.1 Fm.MPath.nil))) #chk_type ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Unit) (((((Fm.Term.check term) ((Maybe.some Fm.Term) type)) defs) (List.nil ((Pair Fm.Name) Fm.Term))) (Fm.MPath.0 Fm.MPath.nil))) #chk_term ((((Monad.pure Fm.Check) Fm.Check.monad) Unit) Unit.new))); ((checked #checked Fm.Defs) #checked.value #checked.errors (((((List.is_empty Fm.Error) checked.errors) # (Map Fm.Def)) !defs = ((((Fm.set Fm.Def) name) ((((Fm.Def.new name) term) type) Fm.Status.done)) defs); defs) !fixed = ((((((Fm.Synth.fix name) term) type) defs) checked.errors) Bool.false); (((fixed #fixed (Map Fm.Def)) !stat = (Fm.Status.fail checked.errors); !defs = ((((Fm.set Fm.Def) name) ((((Fm.Def.new name) term) type) stat)) defs); defs) #fixed.value ((Fm.Synth.one name) fixed.value))))) defs) defs) #stat.errors defs)));
Fm.Synth.fix : @(name:Fm.Name) @(term:Fm.Term) @(type:Fm.Term) @(defs:Fm.Defs) @(errs:(List Fm.Error)) @(fixd:Bool) (Maybe Fm.Defs) = #name #term #type #defs #errs #fixd (((errs #errs (Maybe Fm.Defs)) (((fixd # (Maybe Fm.Defs)) !type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) type); !term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) term); !defs = ((((Fm.set Fm.Def) name) ((((Fm.Def.new name) term) type) Fm.Status.init)) defs); ((Maybe.some (Map Fm.Def)) defs)) (Maybe.none Fm.Defs))) #errs.head #errs.tail ((((((((errs.head #errs.head (Maybe Fm.Defs)) #errs.head.origin #errs.head.expected #errs.head.detected #errs.head.context ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)) #errs.head.name #errs.head.dref #errs.head.verb #errs.head.goal #errs.head.context ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)) #errs.head.name !defs = ((Fm.Synth.one errs.head.name) defs); ((((((Fm.Synth.fix name) term) type) defs) errs.tail) Bool.true)) #errs.head.name ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)) #errs.head.path #errs.head.term ((((errs.head.path #errs.head.path (Maybe Fm.Defs)) (Maybe.none Fm.Defs)) #errs.head.path.pred !term = (((Fm.Term.patch_at errs.head.path.pred) term) #x errs.head.term); ((((((Fm.Synth.fix name) term) type) defs) errs.tail) Bool.true)) #errs.head.path.pred !type = (((Fm.Term.patch_at errs.head.path.pred) type) #x errs.head.term); ((((((Fm.Synth.fix name) term) type) defs) errs.tail) Bool.true))) #errs.head.origin #errs.head.name ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)) #errs.head.origin #errs.head.term #errs.head.context ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)));
Fm.Synth.all : @(defs:Fm.Defs) Fm.Defs = #defs !defs = (((((List.for Fm.Def) ((Map.values Fm.Def) defs)) Fm.Defs) defs) #def #defs ((def #def Fm.Defs) #def.name #def.term #def.type #def.stat !name = def.name; !term = def.term; !type = def.type; !stat = def.stat; ((Fm.Synth.one name) defs))); defs;
Fm.Status.wait : Fm.Status = #P #init #wait #done #fail wait;
Fm.Status.init : Fm.Status = #P #init #wait #done #fail init;
Fm.Status.fail : @(errors:(List Fm.Error)) Fm.Status = #errors #P #init #wait #done #fail (fail errors);
Fm.Status.done : Fm.Status = #P #init #wait #done #fail done;
Fm.Status : * = %Fm.Status.Self(P:@(:Fm.Status) *) @(init:(P Fm.Status.init)) @(wait:(P Fm.Status.wait)) @(done:(P Fm.Status.done)) @(fail:@(errors:(List Fm.Error)) (P (Fm.Status.fail errors))) (P Fm.Status.Self);
Fm.Path.1 : @(path:Fm.Path) Fm.Path = #path #x (path (Bits.1 x));
Fm.Path.0 : @(path:Fm.Path) Fm.Path = #path #x (path (Bits.0 x));
Fm.Path.to_bits : @(path:Fm.Path) Bits = #path (path Bits.nil);
Fm.Path.nil : Fm.Path = #x x;
Fm.Path : * = @(:Bits) Bits;
Fm.Parser.type : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "Type")) # ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.typ orig)))));
Fm.Parser.text : @(text:String) (Parser Unit) = #text ((((((Monad.bind Parser) Parser.monad) (List Unit)) Unit) Fm.Parser.spaces) # (Parser.text text));
Fm.Parser.term : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) ((Parser.first_of Fm.Term) (((List.cons (Parser Fm.Term)) Fm.Parser.type) (((List.cons (Parser Fm.Term)) Fm.Parser.forall) (((List.cons (Parser Fm.Term)) Fm.Parser.lambda) (((List.cons (Parser Fm.Term)) Fm.Parser.lambda.erased) (((List.cons (Parser Fm.Term)) Fm.Parser.parenthesis) (((List.cons (Parser Fm.Term)) Fm.Parser.letforin) (((List.cons (Parser Fm.Term)) Fm.Parser.let) (((List.cons (Parser Fm.Term)) Fm.Parser.def) (((List.cons (Parser Fm.Term)) Fm.Parser.if) (((List.cons (Parser Fm.Term)) Fm.Parser.char) (((List.cons (Parser Fm.Term)) Fm.Parser.string) (((List.cons (Parser Fm.Term)) Fm.Parser.pair) (((List.cons (Parser Fm.Term)) Fm.Parser.list) (((List.cons (Parser Fm.Term)) Fm.Parser.forin) (((List.cons (Parser Fm.Term)) Fm.Parser.do) (((List.cons (Parser Fm.Term)) Fm.Parser.case) (((List.cons (Parser Fm.Term)) Fm.Parser.goal) (((List.cons (Parser Fm.Term)) Fm.Parser.hole) (((List.cons (Parser Fm.Term)) Fm.Parser.nat) (((List.cons (Parser Fm.Term)) Fm.Parser.reference) (List.nil (Parser Fm.Term)))))))))))))))))))))))) #term (Fm.Parser.suffix term));
Fm.Parser.suffix : @(term:Fm.Term) (Parser Fm.Term) = #term #idx #code !suffix_parser = ((Parser.first_of Fm.Term) (((List.cons (Parser Fm.Term)) (Fm.Parser.application term)) (((List.cons (Parser Fm.Term)) (Fm.Parser.application.erased term)) (((List.cons (Parser Fm.Term)) (Fm.Parser.arrow term)) (((List.cons (Parser Fm.Term)) (Fm.Parser.equality term)) (((List.cons (Parser Fm.Term)) (Fm.Parser.annotation term)) (List.nil (Parser Fm.Term)))))))); (((((suffix_parser idx) code) #suffix_parsed (Parser.Reply Fm.Term)) #suffix_parsed.idx #suffix_parsed.code #suffix_parsed.err ((((Parser.Reply.value Fm.Term) idx) code) term)) #suffix_parsed.idx #suffix_parsed.code #suffix_parsed.val (((Fm.Parser.suffix suffix_parsed.val) suffix_parsed.idx) suffix_parsed.code));
Fm.Parser.string : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init !quot = ((String.cons '\"') String.nil); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text quot)) # ((((((Monad.bind Parser) Parser.monad) (List Char)) Fm.Term) (((Parser.until Char) (Parser.text quot)) Fm.Parser.char.single)) #chrs !strx = (((((List.fold Char) chrs) String) String.nil) String.cons); ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((Fm.Term.str orig) strx))))));
Fm.Parser.stop : @(from:Nat) (Parser (Maybe Fm.Origin)) = #from ((((((Monad.bind Parser) Parser.monad) Nat) (Maybe Fm.Origin)) Parser.get_index) #upto !orig = ((Maybe.some Fm.Origin) (((Fm.Origin.new "") from) upto)); ((((Monad.pure Parser) Parser.monad) (Maybe Fm.Origin)) orig));
Fm.Parser.spaces : (Parser (List Unit)) = ((Parser.many Unit) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text " ")) (((List.cons (Parser Unit)) (Parser.text "\u{A}")) (((List.cons (Parser Unit)) ((((((Monad.bind Parser) Parser.monad) Unit) Unit) (Parser.text "//")) # ((((((Monad.bind Parser) Parser.monad) (List Char)) Unit) (((Parser.until Char) (Parser.text "\u{A}")) Parser.one)) # ((((Monad.pure Parser) Parser.monad) Unit) Unit.new)))) (List.nil (Parser Unit)))))));
Fm.Parser.reference : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name (((((String.eql name) "case") # (Parser Fm.Term)) ((Parser.fail Fm.Term) "Reserved keyword.")) ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((Fm.Term.ref orig) name))))));
Fm.Parser.parenthesis : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "(")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #term ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ")")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) term))));
Fm.Parser.pair : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "{")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #val0 ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ",")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #val1 ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "}")) # ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !term = (Fm.Term.xref "Pair.new"); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) val0); !term = (((Fm.Term.app orig) term) val1); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))));
Fm.Parser.nat : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Parser.nat) #natx ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((Fm.Term.nat orig) natx))))));
Fm.Parser.name_term : (Parser ((Pair Fm.Name) Fm.Term)) = ((((((Monad.bind Parser) Parser.monad) Fm.Name) ((Pair Fm.Name) Fm.Term)) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) Unit) ((Pair Fm.Name) Fm.Term)) (Fm.Parser.text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) ((Pair Fm.Name) Fm.Term)) Fm.Parser.term) #type ((((Monad.pure Parser) Parser.monad) ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) name) type)))));
Fm.Parser.name1 : (Parser Fm.Name) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Name) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) (List Char)) Fm.Name) ((Parser.many1 Fm.Letter) Fm.Parser.letter)) #chrs ((((Monad.pure Parser) Parser.monad) String) (((((List.fold Char) chrs) String) String.nil) String.cons))));
Fm.Parser.name : (Parser Fm.Name) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Name) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) (List Char)) Fm.Name) ((Parser.many Fm.Letter) Fm.Parser.letter)) #chrs ((((Monad.pure Parser) Parser.monad) String) (((((List.fold Char) chrs) String) String.nil) String.cons))));
Fm.Parser.make_lambda : @(orig:(Maybe Fm.Origin)) @(names:(List Fm.Name)) @(body:Fm.Term) Fm.Term = #orig #names #body (((names #names Fm.Term) body) #names.head #names.tail (((Fm.Term.lam orig) names.head) #x (((Fm.Parser.make_lambda orig) names.tail) body)));
Fm.Parser.make_forall : @(binds:(List Fm.Binder)) @(body:Fm.Term) Fm.Term = #binds #body (((binds #binds Fm.Term) body) #binds.head #binds.tail ((binds.head #binds.head Fm.Term) #binds.head.eras #binds.head.name #binds.head.term $all_eras = binds.head.eras; $all_self = ""; $all_name = binds.head.name; $all_xtyp = binds.head.term; $all_body = #s #x ((Fm.Parser.make_forall binds.tail) body); (((((Fm.Term.xall all_eras) all_self) all_name) all_xtyp) all_body)));
Fm.Parser.list : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "[")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Term)) Fm.Term) (((Parser.until Fm.Term) (Fm.Parser.text "]")) ((Fm.Parser.item Fm.Term) Fm.Parser.term))) #vals ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) (((((List.fold Fm.Term) vals) Fm.Term) ((Fm.Term.xapp (Fm.Term.xref (Fm.Name.read "List.nil"))) (Fm.Term.xhol Bits.nil))) #x #xs !term = (Fm.Term.xref (Fm.Name.read "List.cons")); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) x); !term = (((Fm.Term.app orig) term) xs); term))))));
Fm.Parser.letter : (Parser Fm.Letter) = #idx #code (((code #code (Parser.Reply Fm.Letter)) ((((Parser.Reply.error Fm.Letter) idx) code) "Unexpected eof.")) #code.head #code.tail ((((Fm.Name.is_letter code.head) # (Parser.Reply Fm.Letter)) ((((Parser.Reply.value Char) (Nat.succ idx)) code.tail) code.head)) ((((Parser.Reply.error Fm.Letter) idx) code) "Expected letter.")));
Fm.Parser.letforin : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "let ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "=")) # ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "for ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #elem ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "in")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #list ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #loop ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !term = (Fm.Term.xref "List.for"); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) list); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) (Fm.Term.xref name)); !lamb = ((Fm.Term.xlam elem) #i ((Fm.Term.xlam name) #x loop)); !term = ((Fm.Term.xapp term) lamb); !term = ((((Fm.Term.let orig) name) term) #x body); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))))))))));
Fm.Parser.let : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "let ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Fm.Term) ((Parser.maybe Unit) (Fm.Parser.text ";"))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((Fm.Term.let orig) name) expr) #x body))))))))));
Fm.Parser.lambda.erased : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "<")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Name)) Fm.Term) (((Parser.until1 Fm.Name) (Fm.Parser.text ">")) ((Fm.Parser.item Fm.Name) Fm.Parser.name1))) #name ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !expr = (((Fm.Parser.make_lambda orig) name) body); ((((Monad.pure Parser) Parser.monad) Fm.Term) expr))))));
Fm.Parser.lambda : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "(")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Name)) Fm.Term) (((Parser.until1 Fm.Name) (Fm.Parser.text ")")) ((Fm.Parser.item Fm.Name) Fm.Parser.name1))) #name ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !expr = (((Fm.Parser.make_lambda orig) name) body); ((((Monad.pure Parser) Parser.monad) Fm.Term) expr))))));
Fm.Parser.item : %(V:*) @(parser:(Parser V)) (Parser V) = #V #parser ((((((Monad.bind Parser) Parser.monad) (List Unit)) V) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) V) V) parser) #value ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) V) ((Parser.maybe Unit) (Fm.Parser.text ","))) # ((((Monad.pure Parser) Parser.monad) V) value))));
Fm.Parser.init : (Parser Nat) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Nat) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Nat) Nat) Parser.get_index) #from ((((Monad.pure Parser) Parser.monad) Nat) from)));
Fm.Parser.if : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "if ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #cond ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "then")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #tcse ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "else")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #fcse ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !term = cond; !term = ((Fm.Term.xapp term) ((Fm.Term.xlam "") #x (Fm.Term.xhol Bits.nil))); !term = ((Fm.Term.xapp term) tcse); !term = (((Fm.Term.app orig) term) fcse); ((((Monad.pure Parser) Parser.monad) Fm.Term) term)))))))));
Fm.Parser.hole : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "_")) # ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((Fm.Term.hol orig) Bits.nil)))));
Fm.Parser.goal : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "?")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) (List Bits)) Fm.Term) ((Parser.many Bits) ((((((Monad.bind Parser) Parser.monad) Unit) Bits) (Fm.Parser.text "-")) # ((((((Monad.bind Parser) Parser.monad) Nat) Bits) Parser.nat) #nat !bits = (Bits.reverse (Bits.tail (Bits.reverse (Nat.to_bits nat)))); ((((Monad.pure Parser) Parser.monad) Bits) bits))))) #dref ((((((Monad.bind Parser) Parser.monad) Bool) Fm.Term) ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Bool) ((Parser.maybe Unit) (Parser.text "-"))) #verb ((((Monad.pure Parser) Parser.monad) Bool) ((Maybe.to_bool Unit) verb)))) #verb ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((Fm.Term.gol orig) name) dref) verb))))))));
Fm.Parser.forin : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "for ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #elem ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "in")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #list ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "with")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #loop ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !term = (Fm.Term.xref "List.for"); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) list); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) (Fm.Term.xref name)); !lamb = ((Fm.Term.xlam elem) #i ((Fm.Term.xlam name) #x loop)); !term = ((Fm.Term.xapp term) lamb); !term = ((((Fm.Term.let orig) name) term) #x (Fm.Term.xref name)); ((((Monad.pure Parser) Parser.monad) Fm.Term) term)))))))))));
Fm.Parser.forall : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #self ((((((Monad.bind Parser) Parser.monad) (List Fm.Binder)) Fm.Term) Fm.Parser.binder) #bind ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Fm.Term) ((Parser.maybe Unit) (Fm.Parser.text "->"))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body !term = (((((List.fold Fm.Binder) bind) Fm.Term) body) #x #t ((x #x Fm.Term) #x.eras #x.name #x.term (((((Fm.Term.xall x.eras) "") x.name) x.term) #s #x t))); ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((((((((((((((term #term Fm.Term) #term.orig #term.name #term.indx term) #term.orig #term.name term) #term.orig term) #term.orig #term.eras #term.self #term.name #term.xtyp #term.body ((((((Fm.Term.all orig) term.eras) self) term.name) term.xtyp) term.body)) #term.orig #term.name #term.body term) #term.orig #term.func #term.argm term) #term.orig #term.name #term.expr #term.body term) #term.orig #term.name #term.expr #term.body term) #term.orig #term.done #term.term #term.type term) #term.orig #term.name #term.dref #term.verb term) #term.orig #term.path term) #term.orig #term.natx term) #term.orig #term.chrx term) #term.orig #term.strx term) #term.orig #term.path #term.expr #term.name #term.with #term.cses #term.moti term))))))));
Fm.Parser.file.go : @(defs:Fm.Defs) (Parser Fm.Defs) = #defs ((((((Monad.bind Parser) Parser.monad) Bool) Fm.Defs) Parser.is_eof) #stop (((stop # (Parser Fm.Defs)) ((((Monad.pure Parser) Parser.monad) Fm.Defs) defs)) ((((((Monad.bind Parser) Parser.monad) Fm.Defs) Fm.Defs) ((Parser.first_of Fm.Defs) (((List.cons (Parser Fm.Defs)) (Fm.Parser.file.def defs)) (((List.cons (Parser Fm.Defs)) (Fm.Parser.file.adt defs)) (((List.cons (Parser Fm.Defs)) (Fm.Parser.file.end defs)) (List.nil (Parser Fm.Defs))))))) #defs (Fm.Parser.file.go defs))));
Fm.Parser.file.end : @(defs:Fm.Defs) (Parser Fm.Defs) = #defs ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Defs) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Defs) Parser.eof) # ((((Monad.pure Parser) Parser.monad) Fm.Defs) defs)));
Fm.Parser.file.def : @(defs:Fm.Defs) (Parser Fm.Defs) = #defs ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Defs) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) (List (List Fm.Binder))) Fm.Defs) ((Parser.many (List Fm.Binder)) Fm.Parser.binder)) #args !args = ((List.flatten Fm.Binder) args); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Defs) (Fm.Parser.text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) (Map Fm.Def)) Fm.Parser.term) #type ((((((Monad.bind Parser) Parser.monad) Fm.Term) (Map Fm.Def)) Fm.Parser.term) #term !type = ((Fm.Parser.make_forall args) type); !term = (((Fm.Parser.make_lambda (Maybe.none Fm.Origin)) ((((List.mapped Fm.Binder) args) Fm.Name) #x ((x #x Fm.Name) #x.eras #x.name #x.term x.name))) term); !type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) type); !term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) term); !defs = ((((Fm.set Fm.Def) name) ((((Fm.Def.new name) term) type) Fm.Status.init)) defs); ((((Monad.pure Parser) Parser.monad) (Map Fm.Def)) defs))))));
Fm.Parser.file.adt : @(defs:Fm.Defs) (Parser Fm.Defs) = #defs ((((((Monad.bind Parser) Parser.monad) Fm.Datatype) Fm.Defs) Fm.Parser.datatype) #adt ((adt #adt (Parser Fm.Defs)) #adt.name #adt.pars #adt.inds #adt.ctrs !term = (Fm.Datatype.build_term adt); !term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) term); !type = (Fm.Datatype.build_type adt); !type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) type); !defs = ((((Fm.set Fm.Def) adt.name) ((((Fm.Def.new adt.name) term) type) Fm.Status.init)) defs); !defs = (((((List.fold Fm.Constructor) adt.ctrs) (Map Fm.Def)) defs) #ctr #defs !typ_name = adt.name; !ctr_name = (String.flatten (((List.cons String) typ_name) (((List.cons Fm.Name) (Fm.Name.read ".")) (((List.cons Fm.Name) ((ctr #ctr Fm.Name) #ctr.name #ctr.args #ctr.inds ctr.name)) (List.nil Fm.Name))))); !ctr_term = ((Fm.Constructor.build_term adt) ctr); !ctr_term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) ctr_term); !ctr_type = ((Fm.Constructor.build_type adt) ctr); !ctr_type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) ctr_type); ((((Fm.set Fm.Def) ctr_name) ((((Fm.Def.new ctr_name) ctr_term) ctr_type) Fm.Status.init)) defs)); ((((Monad.pure Parser) Parser.monad) Fm.Defs) defs)));
Fm.Parser.file : (Parser Fm.Defs) = (Fm.Parser.file.go (Map.new Fm.Def));
Fm.Parser.equality : @(val0:Fm.Term) (Parser Fm.Term) = #val0 ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "==")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #val1 ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !term = (Fm.Term.xref "Equal"); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) val0); !term = (((Fm.Term.app orig) term) val1); ((((Monad.pure Parser) Parser.monad) Fm.Term) term)))));
Fm.Parser.do.statements : @(monad_name:Fm.Name) (Parser Fm.Term) = #monad_name ((Parser.first_of Fm.Term) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "var ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements monad_name)) #body ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !term = ((Fm.Term.xapp (Fm.Term.xref "Monad.bind")) (Fm.Term.xref monad_name)); !term = ((Fm.Term.xapp term) (Fm.Term.xref ((String.concat monad_name) ".monad"))); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) expr); !term = (((Fm.Term.app orig) term) ((Fm.Term.xlam name) #x body)); ((((Monad.pure Parser) Parser.monad) Fm.Term) term)))))))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "let ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements monad_name)) #body ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((Fm.Term.let orig) name) expr) #x body))))))))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "return ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ";")) # ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !term = ((Fm.Term.xapp (Fm.Term.xref "Monad.pure")) (Fm.Term.xref monad_name)); !term = ((Fm.Term.xapp term) (Fm.Term.xref ((String.concat monad_name) ".monad"))); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = (((Fm.Term.app orig) term) expr); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements monad_name)) #body ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !term = ((Fm.Term.xapp (Fm.Term.xref "Monad.bind")) (Fm.Term.xref monad_name)); !term = ((Fm.Term.xapp term) (Fm.Term.xref ((String.concat monad_name) ".monad"))); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) (Fm.Term.xhol Bits.nil)); !term = ((Fm.Term.xapp term) expr); !term = (((Fm.Term.app orig) term) ((Fm.Term.xlam "") #x body)); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ";")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) expr)))) (List.nil (Parser Fm.Term))))))));
Fm.Parser.do : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "do ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "{")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements name)) #term ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "}")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))));
Fm.Parser.def : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "def ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Fm.Term) ((Parser.maybe Unit) (Fm.Parser.text ";"))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((Fm.Term.def orig) name) expr) #x body))))))))));
Fm.Parser.datatype : (Parser Fm.Datatype) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Datatype) (Fm.Parser.text "type ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Datatype) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Datatype) ((Parser.maybe (List Fm.Binder)) Fm.Parser.binder)) #pars ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Datatype) ((Parser.maybe (List Fm.Binder)) ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.text "~")) # Fm.Parser.binder))) #inds !pars = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) pars); !inds = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) inds); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Datatype) (Fm.Parser.text "{")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Constructor)) Fm.Datatype) (((Parser.until Fm.Constructor) (Fm.Parser.text "}")) ((Fm.Parser.item Fm.Constructor) (Fm.Parser.constructor name)))) #ctrs ((((Monad.pure Parser) Parser.monad) Fm.Datatype) ((((Fm.Datatype.new name) pars) inds) ctrs))))))));
Fm.Parser.constructor : @(namespace:Fm.Name) (Parser Fm.Constructor) = #namespace ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Constructor) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Constructor) ((Parser.maybe (List Fm.Binder)) Fm.Parser.binder)) #args ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Constructor) ((Parser.maybe (List Fm.Binder)) ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.text "~")) # Fm.Parser.binder))) #inds !args = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) args); !inds = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) inds); ((((Monad.pure Parser) Parser.monad) Fm.Constructor) (((Fm.Constructor.new name) args) inds)))));
Fm.Parser.char.single : (Parser Char) = ((Parser.first_of Char) (((List.cons (Parser Char)) ((Parser.first_of Char) ((((List.mapped ((Pair String) Char)) Fm.escapes) (Parser Char)) #esc ((esc #esc (Parser Char)) #esc.fst #esc.snd ((((((Monad.bind Parser) Parser.monad) Unit) Char) (Parser.text esc.fst)) # ((((Monad.pure Parser) Parser.monad) Char) esc.snd)))))) (((List.cons (Parser Char)) Parser.one) (List.nil (Parser Char)))));
Fm.Parser.char : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "\'")) # ((((((Monad.bind Parser) Parser.monad) Char) Fm.Term) Fm.Parser.char.single) #chrx ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.text "\'")) # ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((Fm.Term.chr orig) chrx)))))));
Fm.Parser.case.with : (Parser Fm.Def) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.text "with")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Def) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #type ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #term ((((Monad.pure Parser) Parser.monad) Fm.Def) ((((Fm.Def.new name) term) type) Fm.Status.init))))))));
Fm.Parser.case.case : (Parser ((Pair Fm.Name) Fm.Term)) = ((((((Monad.bind Parser) Parser.monad) Fm.Name) ((Pair Fm.Name) Fm.Term)) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) ((Pair Fm.Name) Fm.Term)) (Fm.Parser.text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) ((Pair Fm.Name) Fm.Term)) Fm.Parser.term) #term ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) ((Pair Fm.Name) Fm.Term)) ((Parser.maybe Unit) (Fm.Parser.text ","))) # ((((Monad.pure Parser) Parser.monad) ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) name) term))))));
Fm.Parser.case : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "case ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Name)) Fm.Term) ((Parser.maybe Fm.Name) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Name) (Fm.Parser.text "as")) # Fm.Parser.name1))) #name !name = (((name #name Fm.Name) ((((((((((((((((expr #expr Fm.Name) #expr.orig #expr.name #expr.indx expr.name) #expr.orig #expr.name expr.name) #expr.orig (Fm.Name.read "self")) #expr.orig #expr.eras #expr.self #expr.name #expr.xtyp #expr.body (Fm.Name.read "self")) #expr.orig #expr.name #expr.body (Fm.Name.read "self")) #expr.orig #expr.func #expr.argm (Fm.Name.read "self")) #expr.orig #expr.name #expr.expr #expr.body (Fm.Name.read "self")) #expr.orig #expr.name #expr.expr #expr.body (Fm.Name.read "self")) #expr.orig #expr.done #expr.term #expr.type (Fm.Name.read "self")) #expr.orig #expr.name #expr.dref #expr.verb (Fm.Name.read "self")) #expr.orig #expr.path (Fm.Name.read "self")) #expr.orig #expr.natx (Fm.Name.read "self")) #expr.orig #expr.chrx (Fm.Name.read "self")) #expr.orig #expr.strx (Fm.Name.read "self")) #expr.orig #expr.path #expr.expr #expr.name #expr.with #expr.cses #expr.moti (Fm.Name.read "self"))) #name.value name.value); ((((((Monad.bind Parser) Parser.monad) (List Fm.Def)) Fm.Term) ((Parser.many Fm.Def) Fm.Parser.case.with)) #with ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "{")) # ((((((Monad.bind Parser) Parser.monad) (List ((Pair Fm.Name) Fm.Term))) Fm.Term) (((Parser.until ((Pair Fm.Name) Fm.Term)) (Fm.Parser.text "}")) Fm.Parser.case.case)) #cses !cses = ((((Map.from_list Fm.Name) Fm.Term) Fm.Name.to_bits) cses); ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Term)) Fm.Term) ((Parser.maybe Fm.Term) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text ":")) # Fm.Parser.term))) #moti ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !moti = (((moti #moti Fm.Term) (Fm.Term.xhol Bits.nil)) #moti.value moti.value); ((((Monad.pure Parser) Parser.monad) Fm.Term) (((((((Fm.Term.cse orig) Bits.nil) expr) name) with) cses) moti))))))))))));
Fm.Parser.binder.homo : @(eras:Bool) (Parser (List Fm.Binder)) = #eras ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.text (((eras # String) "<") "("))) # ((((((Monad.bind Parser) Parser.monad) (List ((Pair Fm.Name) Fm.Term))) (List Fm.Binder)) (((Parser.until1 ((Pair Fm.Name) Fm.Term)) (Fm.Parser.text (((eras # String) ">") ")"))) ((Fm.Parser.item ((Pair Fm.Name) Fm.Term)) Fm.Parser.name_term))) #bind ((((Monad.pure Parser) Parser.monad) (List Fm.Binder)) ((((List.mapped ((Pair Fm.Name) Fm.Term)) bind) Fm.Binder) #pair ((pair #pair Fm.Binder) #pair.fst #pair.snd (((Fm.Binder.new eras) pair.fst) pair.snd))))));
Fm.Parser.binder : (Parser (List Fm.Binder)) = ((((((Monad.bind Parser) Parser.monad) (List (List Fm.Binder))) (List Fm.Binder)) ((Parser.many1 (List Fm.Binder)) ((Parser.first_of (List Fm.Binder)) (((List.cons (Parser (List Fm.Binder))) (Fm.Parser.binder.homo Bool.true)) (((List.cons (Parser (List Fm.Binder))) (Fm.Parser.binder.homo Bool.false)) (List.nil (Parser (List Fm.Binder)))))))) #lists ((((Monad.pure Parser) Parser.monad) (List Fm.Binder)) ((List.flatten Fm.Binder) lists)));
Fm.Parser.arrow : @(xtyp:Fm.Term) (Parser Fm.Term) = #xtyp ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Fm.Parser.init) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "->")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((((Fm.Term.all orig) Bool.false) "") "") xtyp) #s #x body))))));
Fm.Parser.application.erased : @(func:Fm.Term) (Parser Fm.Term) = #func ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Parser.get_index) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.text "<")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Term)) Fm.Term) (((Parser.until1 Fm.Term) (Parser.spaces_text ">")) ((Fm.Parser.item Fm.Term) Fm.Parser.term))) #args ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !expr = (((((List.for Fm.Term) args) Fm.Term) func) #x #f (((Fm.Term.app orig) f) x)); ((((Monad.pure Parser) Parser.monad) Fm.Term) expr)))));
Fm.Parser.application : @(func:Fm.Term) (Parser Fm.Term) = #func ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Parser.get_index) #init ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.text "(")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Term)) Fm.Term) (((Parser.until1 Fm.Term) (Fm.Parser.text ")")) ((Fm.Parser.item Fm.Term) Fm.Parser.term))) #args ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Origin)) Fm.Term) (Fm.Parser.stop init)) #orig !expr = (((((List.for Fm.Term) args) Fm.Term) func) #x #f (((Fm.Term.app orig) f) x)); ((((Monad.pure Parser) Parser.monad) Fm.Term) expr)))));
Fm.Parser.annotation : @(term:Fm.Term) (Parser Fm.Term) = #term ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.text "::")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #type ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.xann Bool.false) term) type))));
Fm.Origin.new : @(file:String) @(from:Nat) @(upto:Nat) Fm.Origin = #file #from #upto #P #new (((new file) from) upto);
Fm.Origin : * = %Fm.Origin.Self(P:@(:Fm.Origin) *) @(new:@(file:String) @(from:Nat) @(upto:Nat) (P (((Fm.Origin.new file) from) upto))) (P Fm.Origin.Self);
Fm.Name.to_bits : @(name:Fm.Name) Bits = #name (((name #name Bits) Bits.nil) #name.head #name.tail !chr = name.head; !u16 = ((((((U16.btw 'A') chr) 'Z') # U16) ((U16.sub chr) (Nat.to_u16 +65))) ((((((U16.btw 'a') chr) 'z') # U16) ((U16.sub chr) (Nat.to_u16 +71))) ((((((U16.btw '0') chr) '9') # U16) ((U16.add chr) (Nat.to_u16 +4))) (((((U16.eql '.') chr) # U16) (Nat.to_u16 +62)) (((((U16.eql '_') chr) # U16) (Nat.to_u16 +63)) (Nat.to_u16 +0)))))); !bts = ((u16 #u16 Bits) #u16.value ((Word.to_bits +6) (((Word.trim +16) +6) u16.value))); ((Bits.concat (Bits.reverse bts)) (Fm.Name.to_bits name.tail)));
Fm.Name.show : @(name:Fm.Name) String = #name name;
Fm.Name.read : @(str:String) Fm.Name = #str str;
Fm.Name.is_letter : @(chr:Char) Bool = #chr ((((((U16.btw 'A') chr) 'Z') # Bool) Bool.true) ((((((U16.btw 'a') chr) 'z') # Bool) Bool.true) ((((((U16.btw '0') chr) '9') # Bool) Bool.true) (((((U16.eql '.') chr) # Bool) Bool.true) (((((U16.eql '_') chr) # Bool) Bool.true) Bool.false)))));
Fm.Name.from_bits : @(bits:Bits) Fm.Name = #bits !list = ((Bits.chunks_of +6) bits); !name = (((((List.fold Bits) list) Fm.Name) String.nil) #bts #name !u16 = (U16.new ((Word.from_bits +16) (Bits.reverse bts))); !chr = ((((((U16.btw (Nat.to_u16 +0)) u16) (Nat.to_u16 +25)) # Char) ((U16.add u16) (Nat.to_u16 +65))) ((((((U16.btw (Nat.to_u16 +26)) u16) (Nat.to_u16 +51)) # U16) ((U16.add u16) (Nat.to_u16 +71))) ((((((U16.btw (Nat.to_u16 +52)) u16) (Nat.to_u16 +61)) # U16) ((U16.sub u16) (Nat.to_u16 +4))) (((((U16.eql (Nat.to_u16 +62)) u16) # U16) (Nat.to_u16 +46)) (Nat.to_u16 +95))))); ((String.cons chr) name)); name;
Fm.Name.eql : @(a:Fm.Name) @(b:Fm.Name) Bool = #a #b ((String.eql a) b);
Fm.Name : * = String;
Fm.MPath.1 : @(path:(Maybe Fm.Path)) (Maybe Fm.Path) = #path ((((Maybe.mapped Fm.Path) path) Fm.Path) Fm.Path.1);
Fm.MPath.0 : @(path:(Maybe Fm.Path)) (Maybe Fm.Path) = #path ((((Maybe.mapped Fm.Path) path) Fm.Path) Fm.Path.0);
Fm.MPath.to_bits : @(path:(Maybe Fm.Path)) Bits = #path (((path #path Bits) Bits.nil) #path.value (path.value Bits.nil));
Fm.MPath.nil : (Maybe Fm.Path) = ((Maybe.some Fm.Path) Fm.Path.nil);
Fm.MPath : * = (Maybe Fm.Path);
Fm.Letter : * = Char;
Fm.Error.waiting : @(name:Fm.Name) Fm.Error = #name #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer (waiting name);
Fm.Error.undefined_reference : @(origin:(Maybe Fm.Origin)) @(name:Fm.Name) Fm.Error = #origin #name #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer ((undefined_reference origin) name);
Fm.Error.type_mismatch : @(origin:(Maybe Fm.Origin)) @(expected:((Either String) Fm.Term)) @(detected:((Either String) Fm.Term)) @(context:Fm.Context) Fm.Error = #origin #expected #detected #context #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer ((((type_mismatch origin) expected) detected) context);
Fm.Error.show_goal : @(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) @(goal:(Maybe Fm.Term)) @(context:Fm.Context) Fm.Error = #name #dref #verb #goal #context #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer (((((show_goal name) dref) verb) goal) context);
Fm.Error.show : @(error:Fm.Error) @(defs:Fm.Defs) String = #error #defs ((((((((error #error String) #error.origin #error.expected #error.detected #error.context !expected = (((error.expected #error.expected String) #error.expected.value error.expected.value) #error.expected.value (Fm.Term.show ((Fm.Term.normalize error.expected.value) (Map.new Fm.Def)))); !detected = (((error.detected #error.detected String) #error.detected.value error.detected.value) #error.detected.value (Fm.Term.show ((Fm.Term.normalize error.detected.value) (Map.new Fm.Def)))); (String.flatten (((List.cons String) "Type mismatch.\u{A}") (((List.cons String) "- Expected: ") (((List.cons String) expected) (((List.cons String) "\u{A}") (((List.cons String) "- Detected: ") (((List.cons String) detected) (((List.cons String) "\u{A}") (((List.cons String) (((error.context #error.context String) "") #error.context.head #error.context.tail (String.flatten (((List.cons String) "With context:\u{A}") (((List.cons String) (Fm.Context.show error.context)) (List.nil String)))))) (List.nil String))))))))))) #error.name #error.dref #error.verb #error.goal #error.context !goal_name = (String.flatten (((List.cons String) "Goal ?") (((List.cons String) (Fm.Name.show error.name)) (((List.cons String) ":\u{A}") (List.nil String))))); !with_type = (((error.goal #error.goal String) "") #error.goal.value !goal = (((Fm.Term.expand error.dref) error.goal.value) defs); (String.flatten (((List.cons String) "With type: ") (((List.cons String) (((error.verb # String) ((Fm.Term.show.go goal) ((Maybe.some @(:Bits) Bits) #x x))) (Fm.Term.show goal))) (((List.cons String) "\u{A}") (List.nil String)))))); !with_ctxt = (((error.context #error.context String) "") #error.context.head #error.context.tail (String.flatten (((List.cons String) "With ctxt:\u{A}") (((List.cons String) (Fm.Context.show error.context)) (List.nil String))))); (String.flatten (((List.cons String) goal_name) (((List.cons String) with_type) (((List.cons String) with_ctxt) (List.nil String)))))) #error.name (String.flatten (((List.cons String) "Waiting for \'") (((List.cons Fm.Name) error.name) (((List.cons String) "\'.") (List.nil String)))))) #error.name (String.flatten (((List.cons String) "Error on dependency \'") (((List.cons Fm.Name) error.name) (((List.cons String) "\'.") (List.nil String)))))) #error.path #error.term (String.flatten (((List.cons String) "Patching: ") (((List.cons String) (Fm.Term.show error.term)) (List.nil String))))) #error.origin #error.name (String.flatten (((List.cons String) "Undefined reference: ") (((List.cons String) (Fm.Name.show error.name)) (((List.cons String) "\u{A}") (List.nil String)))))) #error.origin #error.term #error.context !term = (Fm.Term.show error.term); !context = (Fm.Context.show error.context); (String.flatten (((List.cons String) "Can\'t infer type of: ") (((List.cons String) term) (((List.cons String) "\u{A}") (((List.cons String) "With ctxt:\u{A}") (((List.cons String) context) (List.nil String))))))));
Fm.Error.relevant : @(errors:(List Fm.Error)) @(got:Bool) (List Fm.Error) = #errors #got (((errors #errors (List Fm.Error)) (List.nil Fm.Error)) #errors.head #errors.tail !keep = ((((((((errors.head #errors.head Bool) #errors.head.origin #errors.head.expected #errors.head.detected #errors.head.context (Bool.not got)) #errors.head.name #errors.head.dref #errors.head.verb #errors.head.goal #errors.head.context Bool.true) #errors.head.name Bool.false) #errors.head.name Bool.false) #errors.head.path #errors.head.term Bool.false) #errors.head.origin #errors.head.name (Bool.not got)) #errors.head.origin #errors.head.term #errors.head.context (Bool.not got)); !got = ((((((((errors.head #errors.head Bool) #errors.head.origin #errors.head.expected #errors.head.detected #errors.head.context Bool.true) #errors.head.name #errors.head.dref #errors.head.verb #errors.head.goal #errors.head.context got) #errors.head.name got) #errors.head.name got) #errors.head.path #errors.head.term got) #errors.head.origin #errors.head.name Bool.true) #errors.head.origin #errors.head.term #errors.head.context got); !tail = ((Fm.Error.relevant errors.tail) got); (((keep # (List Fm.Error)) (((List.cons Fm.Error) errors.head) tail)) tail));
Fm.Error.patch : @(path:Bits) @(term:Fm.Term) Fm.Error = #path #term #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer ((patch path) term);
Fm.Error.origin : @(error:Fm.Error) (Maybe Fm.Origin) = #error ((((((((error #error (Maybe Fm.Origin)) #error.origin #error.expected #error.detected #error.context error.origin) #error.name #error.dref #error.verb #error.goal #error.context (Maybe.none Fm.Origin)) #error.name (Maybe.none Fm.Origin)) #error.name (Maybe.none Fm.Origin)) #error.path #error.term (Maybe.none Fm.Origin)) #error.origin #error.name error.origin) #error.origin #error.term #error.context error.origin);
Fm.Error.indirect : @(name:Fm.Name) Fm.Error = #name #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer (indirect name);
Fm.Error.cant_infer : @(origin:(Maybe Fm.Origin)) @(term:Fm.Term) @(context:Fm.Context) Fm.Error = #origin #term #context #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer (((cant_infer origin) term) context);
Fm.Error : * = %Fm.Error.Self(P:@(:Fm.Error) *) @(type_mismatch:@(origin:(Maybe Fm.Origin)) @(expected:((Either String) Fm.Term)) @(detected:((Either String) Fm.Term)) @(context:Fm.Context) (P ((((Fm.Error.type_mismatch origin) expected) detected) context))) @(show_goal:@(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) @(goal:(Maybe Fm.Term)) @(context:Fm.Context) (P (((((Fm.Error.show_goal name) dref) verb) goal) context))) @(waiting:@(name:Fm.Name) (P (Fm.Error.waiting name))) @(indirect:@(name:Fm.Name) (P (Fm.Error.indirect name))) @(patch:@(path:Bits) @(term:Fm.Term) (P ((Fm.Error.patch path) term))) @(undefined_reference:@(origin:(Maybe Fm.Origin)) @(name:Fm.Name) (P ((Fm.Error.undefined_reference origin) name))) @(cant_infer:@(origin:(Maybe Fm.Origin)) @(term:Fm.Term) @(context:Fm.Context) (P (((Fm.Error.cant_infer origin) term) context))) (P Fm.Error.Self);
Fm.Def.new : @(name:Fm.Name) @(term:Fm.Term) @(type:Fm.Term) @(stat:Fm.Status) Fm.Def = #name #term #type #stat #P #new ((((new name) term) type) stat);
Fm.Defs.report : @(code:String) @(defs:Fm.Defs) String = #code #defs !result = ""; !result = (((((List.for Fm.Def) ((Map.values Fm.Def) defs)) String) result) #def #result ((def #def String) #def.name #def.term #def.type #def.stat !name = def.name; !term = def.term; !type = def.type; !stat = def.stat; (((((stat #stat String) result) result) result) #stat.errors (((stat.errors #stat.errors String) result) #stat.errors.head #stat.errors.tail !name_str = (Fm.Name.show name); !type_str = "<error>"; !errors = ((Fm.Error.relevant stat.errors) Bool.false); !result = (((((List.for Fm.Error) errors) String) result) #error #result (String.flatten (((List.cons String) result) (((List.cons String) "On ") (((List.cons String) name_str) (((List.cons String) ":\u{A}") (((List.cons String) ((Fm.Error.show error) defs)) (((List.cons String) ((((Fm.Error.origin error) #origin String) "") #origin.value ((origin.value #origin.value String) #origin.value.file #origin.value.from #origin.value.upto !highlighted = (((Fm.highlight code) origin.value.from) origin.value.upto); (String.flatten (((List.cons String) "On code:\u{A}") (((List.cons String) highlighted) (((List.cons String) "\u{A}") (List.nil String)))))))) (((List.cons String) "\u{A}") (List.nil String)))))))))); result)))); (((result #result String) "All terms check.") #result.head #result.tail result);
Fm.Defs.read : @(code:String) ((Either String) Fm.Defs) = #code (((((Fm.Parser.file +0) code) #parsed ((Either String) Fm.Defs)) #parsed.idx #parsed.code #parsed.err !err = parsed.err; !hig = (((Fm.highlight code) parsed.idx) (Nat.succ parsed.idx)); !str = (String.flatten (((List.cons String) err) (((List.cons String) "\u{A}") (((List.cons String) hig) (List.nil String))))); (((Either.left String) Fm.Defs) str)) #parsed.idx #parsed.code #parsed.val (((Either.right String) Fm.Defs) parsed.val));
Fm.Defs.core : @(defs:Fm.Defs) String = #defs !result = ""; !result = (((((List.for Fm.Def) ((Map.values Fm.Def) defs)) String) result) #def #result ((def #def String) #def.name #def.term #def.type #def.stat (((((def.stat #def.stat String) result) result) !name = def.name; !term = (Fm.Term.core def.term); !type = (Fm.Term.core def.type); (String.flatten (((List.cons String) result) (((List.cons Fm.Name) name) (((List.cons String) " : ") (((List.cons String) type) (((List.cons String) " = ") (((List.cons String) term) (((List.cons String) ";\u{A}") (List.nil String)))))))))) #def.stat.errors result))); result;
Fm.Defs : * = (Map Fm.Def);
Fm.Def : * = %Fm.Def.Self(P:@(:Fm.Def) *) @(new:@(name:Fm.Name) @(term:Fm.Term) @(type:Fm.Term) @(stat:Fm.Status) (P ((((Fm.Def.new name) term) type) stat))) (P Fm.Def.Self);
Fm.Datatype.new : @(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) @(ctrs:(List Fm.Constructor)) Fm.Datatype = #name #pars #inds #ctrs #P #new ((((new name) pars) inds) ctrs);
Fm.Datatype.build_type.go : @(type:Fm.Datatype) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) Fm.Term = #type #name #pars #inds (((pars #pars Fm.Term) (((inds #inds Fm.Term) Fm.Term.xtyp) #inds.head #inds.tail ((inds.head #inds.head Fm.Term) #inds.head.eras #inds.head.name #inds.head.term $ind_eras = inds.head.eras; $ind_name = inds.head.name; $ind_xtyp = inds.head.term; $ind_body = #s #x ((((Fm.Datatype.build_type.go type) name) pars) inds.tail); (((((Fm.Term.xall Bool.false) "") ind_name) ind_xtyp) ind_body)))) #pars.head #pars.tail ((pars.head #pars.head Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $par_eras = pars.head.eras; $par_name = pars.head.name; $par_xtyp = pars.head.term; $par_body = #s #x ((((Fm.Datatype.build_type.go type) name) pars.tail) inds); (((((Fm.Term.xall Bool.false) "") par_name) par_xtyp) par_body)));
Fm.Datatype.build_type : @(type:Fm.Datatype) Fm.Term = #type ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((((Fm.Datatype.build_type.go type) type.name) type.pars) type.inds));
Fm.Datatype.build_term.motive.go : @(type:Fm.Datatype) @(name:Fm.Name) @(inds:(List Fm.Binder)) Fm.Term = #type #name #inds (((inds #inds Fm.Term) ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs !slf = (Fm.Term.xref name); !slf = (((((List.for Fm.Binder) type.pars) Fm.Term) slf) #var #slf ((Fm.Term.xapp slf) (Fm.Term.xref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); !slf = (((((List.for Fm.Binder) type.inds) Fm.Term) slf) #var #slf ((Fm.Term.xapp slf) (Fm.Term.xref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); (((((Fm.Term.xall Bool.false) "") "") slf) #s #x Fm.Term.xtyp))) #inds.head #inds.tail ((inds.head #inds.head Fm.Term) #inds.head.eras #inds.head.name #inds.head.term $ind_eras = inds.head.eras; $ind_name = inds.head.name; $ind_xtyp = inds.head.term; $ind_body = #s #x (((Fm.Datatype.build_term.motive.go type) name) inds.tail); (((((Fm.Term.xall ind_eras) "") ind_name) ind_xtyp) ind_body)));
Fm.Datatype.build_term.motive : @(type:Fm.Datatype) Fm.Term = #type ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs (((Fm.Datatype.build_term.motive.go type) type.name) type.inds));
Fm.Datatype.build_term.go : @(type:Fm.Datatype) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) Fm.Term = #type #name #pars #inds (((pars #pars Fm.Term) (((inds #inds Fm.Term) $moti = (Fm.Datatype.build_term.motive type); $body = #s #x (Fm.Datatype.build_term.constructors type); (((((Fm.Term.xall Bool.true) ((String.concat name) ".Self")) (Fm.Name.read "P")) moti) body)) #inds.head #inds.tail ((inds.head #inds.head Fm.Term) #inds.head.eras #inds.head.name #inds.head.term $ind_name = inds.head.name; $ind_body = #x ((((Fm.Datatype.build_term.go type) name) pars) inds.tail); ((Fm.Term.xlam ind_name) ind_body)))) #pars.head #pars.tail ((pars.head #pars.head Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $par_name = pars.head.name; $par_body = #x ((((Fm.Datatype.build_term.go type) name) pars.tail) inds); ((Fm.Term.xlam par_name) par_body)));
Fm.Datatype.build_term.constructor.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(args:(List Fm.Binder)) Fm.Term = #type #ctor #args (((args #args Fm.Term) ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds !ret = (Fm.Term.xref (Fm.Name.read "P")); !ret = (((((List.for Fm.Binder) ctor.inds) Fm.Term) ret) #var #ret ((Fm.Term.xapp ret) ((var #var Fm.Term) #var.eras #var.name #var.term var.term))); !ctr = (String.flatten (((List.cons String) type.name) (((List.cons Fm.Name) (Fm.Name.read ".")) (((List.cons Fm.Name) ctor.name) (List.nil Fm.Name))))); !slf = (Fm.Term.xref ctr); !slf = (((((List.for Fm.Binder) type.pars) Fm.Term) slf) #var #slf ((Fm.Term.xapp slf) (Fm.Term.xref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); !slf = (((((List.for Fm.Binder) ctor.args) Fm.Term) slf) #var #slf ((Fm.Term.xapp slf) (Fm.Term.xref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); ((Fm.Term.xapp ret) slf)))) #args.head #args.tail ((args.head #args.head Fm.Term) #args.head.eras #args.head.name #args.head.term !eras = args.head.eras; !name = args.head.name; !xtyp = args.head.term; !body = (((Fm.Datatype.build_term.constructor.go type) ctor) args.tail); (((((Fm.Term.xall eras) "") name) xtyp) #s #x body)));
Fm.Datatype.build_term.constructors.go : @(type:Fm.Datatype) @(name:Fm.Name) @(ctrs:(List Fm.Constructor)) Fm.Term = #type #name #ctrs (((ctrs #ctrs Fm.Term) ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs !ret = (Fm.Term.xref (Fm.Name.read "P")); !ret = (((((List.for Fm.Binder) type.inds) Fm.Term) ret) #var #ret ((Fm.Term.xapp ret) (Fm.Term.xref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); ((Fm.Term.xapp ret) (Fm.Term.xref ((String.concat name) ".Self"))))) #ctrs.head #ctrs.tail ((ctrs.head #ctrs.head Fm.Term) #ctrs.head.name #ctrs.head.args #ctrs.head.inds (((((Fm.Term.xall Bool.false) "") ctrs.head.name) ((Fm.Datatype.build_term.constructor type) ctrs.head)) #s #x (((Fm.Datatype.build_term.constructors.go type) name) ctrs.tail))));
Fm.Datatype.build_term.constructors : @(type:Fm.Datatype) Fm.Term = #type ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs (((Fm.Datatype.build_term.constructors.go type) type.name) type.ctrs));
Fm.Datatype.build_term.constructor : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds (((Fm.Datatype.build_term.constructor.go type) ctor) ctor.args));
Fm.Datatype.build_term : @(type:Fm.Datatype) Fm.Term = #type ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((((Fm.Datatype.build_term.go type) type.name) type.pars) type.inds));
Fm.Datatype : * = %Fm.Datatype.Self(P:@(:Fm.Datatype) *) @(new:@(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) @(ctrs:(List Fm.Constructor)) (P ((((Fm.Datatype.new name) pars) inds) ctrs))) (P Fm.Datatype.Self);
Fm.Context.show : @(context:Fm.Context) String = #context (((context #context String) "") #context.head #context.tail ((context.head #context.head String) #context.head.fst #context.head.snd !name = (Fm.Name.show context.head.fst); !type = (Fm.Term.show context.head.snd); !rest = (Fm.Context.show context.tail); (String.flatten (((List.cons String) rest) (((List.cons String) "- ") (((List.cons String) name) (((List.cons String) ": ") (((List.cons String) type) (((List.cons String) "\u{A}") (List.nil String))))))))));
Fm.Context.find : @(name:Fm.Name) @(ctx:Fm.Context) (Maybe Fm.Term) = #name #ctx (((ctx #ctx (Maybe Fm.Term)) (Maybe.none Fm.Term)) #ctx.head #ctx.tail ((ctx.head #ctx.head (Maybe Fm.Term)) #ctx.head.fst #ctx.head.snd (((((Fm.Name.eql name) ctx.head.fst) # (Maybe Fm.Term)) ((Maybe.some Fm.Term) ctx.head.snd)) ((Fm.Context.find name) ctx.tail))));
Fm.Context : * = (List ((Pair Fm.Name) Fm.Term));
Fm.Constructor.new : @(name:Fm.Name) @(args:(List Fm.Binder)) @(inds:(List Fm.Binder)) Fm.Constructor = #name #args #inds #P #new (((new name) args) inds);
Fm.Constructor.build_type.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(args:(List Fm.Binder)) Fm.Term = #type #ctor #name #pars #args (((pars #pars Fm.Term) (((args #args Fm.Term) ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds !type = (Fm.Term.xref name); !type = (((((List.for Fm.Binder) type.pars) Fm.Term) type) #var #type ((Fm.Term.xapp type) (Fm.Term.xref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); !type = (((((List.for Fm.Binder) ctor.inds) Fm.Term) type) #var #type ((Fm.Term.xapp type) ((var #var Fm.Term) #var.eras #var.name #var.term var.term))); type))) #args.head #args.tail ((args.head #args.head Fm.Term) #args.head.eras #args.head.name #args.head.term $ctr_eras = args.head.eras; $ctr_name = args.head.name; $ctr_xtyp = args.head.term; $ctr_body = #s #x (((((Fm.Constructor.build_type.go type) ctor) name) pars) args.tail); (((((Fm.Term.xall ctr_eras) "") ctr_name) ctr_xtyp) ctr_body)))) #pars.head #pars.tail ((pars.head #pars.head Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $pars_eras = pars.head.eras; $pars_name = pars.head.name; $pars_xtyp = pars.head.term; $pars_body = #s #x (((((Fm.Constructor.build_type.go type) ctor) name) pars.tail) args); (((((Fm.Term.xall pars_eras) "") pars_name) pars_xtyp) pars_body)));
Fm.Constructor.build_type : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds (((((Fm.Constructor.build_type.go type) ctor) type.name) type.pars) ctor.args)));
Fm.Constructor.build_term.opt.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(ctrs:(List Fm.Constructor)) Fm.Term = #type #ctor #ctrs (((ctrs #ctrs Fm.Term) ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds !ret = (Fm.Term.xref ctor.name); !ret = (((((List.for Fm.Binder) ctor.args) Fm.Term) ret) #arg #ret ((Fm.Term.xapp ret) (Fm.Term.xref ((arg #arg Fm.Name) #arg.eras #arg.name #arg.term arg.name)))); ret)) #ctrs.head #ctrs.tail ((ctrs.head #ctrs.head Fm.Term) #ctrs.head.name #ctrs.head.args #ctrs.head.inds $name = ctrs.head.name; $body = #x (((Fm.Constructor.build_term.opt.go type) ctor) ctrs.tail); ((Fm.Term.xlam name) body)));
Fm.Constructor.build_term.opt : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs (((Fm.Constructor.build_term.opt.go type) ctor) type.ctrs));
Fm.Constructor.build_term.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(args:(List Fm.Binder)) Fm.Term = #type #ctor #name #pars #args (((pars #pars Fm.Term) (((args #args Fm.Term) $lam_name = (Fm.Name.read "P"); $lam_body = #x ((Fm.Constructor.build_term.opt type) ctor); ((Fm.Term.xlam lam_name) lam_body)) #args.head #args.tail ((args.head #args.head Fm.Term) #args.head.eras #args.head.name #args.head.term $ctr_name = args.head.name; $ctr_body = #x (((((Fm.Constructor.build_term.go type) ctor) name) pars) args.tail); ((Fm.Term.xlam ctr_name) ctr_body)))) #pars.head #pars.tail ((pars.head #pars.head Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $par_name = pars.head.name; $par_body = #x (((((Fm.Constructor.build_term.go type) ctor) name) pars.tail) args); ((Fm.Term.xlam par_name) par_body)));
Fm.Constructor.build_term : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds (((((Fm.Constructor.build_term.go type) ctor) type.name) type.pars) ctor.args)));
Fm.Constructor : * = %Fm.Constructor.Self(P:@(:Fm.Constructor) *) @(new:@(name:Fm.Name) @(args:(List Fm.Binder)) @(inds:(List Fm.Binder)) (P (((Fm.Constructor.new name) args) inds))) (P Fm.Constructor.Self);
Fm.Check.result : %(V:*) @(value:(Maybe V)) @(errors:(List Fm.Error)) (Fm.Check V) = #V #value #errors #P #result ((result value) errors);
Fm.Check.pure : %(V:*) @(value:V) (Fm.Check V) = #V #value (((Fm.Check.result V) ((Maybe.some V) value)) (List.nil Fm.Error));
Fm.Check.monad : (Monad Fm.Check) = (((Monad.new Fm.Check) Fm.Check.bind) Fm.Check.pure);
Fm.Check.bind : %(A:*) %(B:*) @(a:(Fm.Check A)) @(f:@(:A) (Fm.Check B)) (Fm.Check B) = #A #B #a #f ((a #a (Fm.Check B)) #a.value #a.errors (((a.value #got (Fm.Check B)) (((Fm.Check.result B) (Maybe.none B)) a.errors)) #got.value (((f got.value) #b (Fm.Check B)) #b.value #b.errors (((Fm.Check.result B) b.value) (((List.concat Fm.Error) a.errors) b.errors)))));
Fm.Check : @(V:*) * = #V %Fm.Check.Self(P:@(:(Fm.Check V)) *) @(result:@(value:(Maybe V)) @(errors:(List Fm.Error)) (P (((Fm.Check.result V) value) errors))) (P Fm.Check.Self);
Fm.Binder.new : @(eras:Bool) @(name:Fm.Name) @(term:Fm.Term) Fm.Binder = #eras #name #term #P #new (((new eras) name) term);
Fm.Binder : * = %Fm.Binder.Self(P:@(:Fm.Binder) *) @(new:@(eras:Bool) @(name:Fm.Name) @(term:Fm.Term) (P (((Fm.Binder.new eras) name) term))) (P Fm.Binder.Self);
Either.right : %(A:*) %(B:*) @(value:B) ((Either A) B) = #A #B #value #P #left #right (right value);
Either.left : %(A:*) %(B:*) @(value:A) ((Either A) B) = #A #B #value #P #left #right (left value);
Either : @(A:*) @(B:*) * = #A #B %Either.Self(P:@(:((Either A) B)) *) @(left:@(value:A) (P (((Either.left A) B) value))) @(right:@(value:B) (P (((Either.right A) B) value))) (P Either.Self);
Cmp.ltn : Cmp = #P #ltn #eql #gtn ltn;
Cmp.gtn : Cmp = #P #ltn #eql #gtn gtn;
Cmp.eql : Cmp = #P #ltn #eql #gtn eql;
Cmp.as_lte : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp Bool) Bool.true) Bool.true) Bool.false);
Cmp.as_gtn : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp Bool) Bool.false) Bool.false) Bool.true);
Cmp.as_gte : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp Bool) Bool.false) Bool.true) Bool.true);
Cmp.as_eql : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp Bool) Bool.false) Bool.true) Bool.false);
Cmp : * = %Cmp.Self(P:@(:Cmp) *) @(ltn:(P Cmp.ltn)) @(eql:(P Cmp.eql)) @(gtn:(P Cmp.gtn)) (P Cmp.Self);
Char : * = U16;
Bool.true : Bool = #P #true #false true;
Bool.or : @(a:Bool) @(b:Bool) Bool = #a #b (((a #a Bool) Bool.true) b);
Bool.not : @(a:Bool) Bool = #a (((a #a Bool) Bool.false) Bool.true);
Bool.false : Bool = #P #true #false false;
Bool.eql : @(a:Bool) @(b:Bool) Bool = #a #b (((a #a Bool) b) (Bool.not b));
Bool.and : @(a:Bool) @(b:Bool) Bool = #a #b (((a #a Bool) b) Bool.false);
Bool : * = %Bool.Self(P:@(:Bool) *) @(true:(P Bool.true)) @(false:(P Bool.false)) (P Bool.Self);
Bits.1 : @(pred:Bits) Bits = #pred #P #nil #0 #1 (1 pred);
Bits.0 : @(pred:Bits) Bits = #pred #P #nil #0 #1 (0 pred);
Bits.to_nat : @(b:Bits) Nat = #b ((((b #b Nat) +0) #b.pred ((Nat.mul +2) (Bits.to_nat b.pred))) #b.pred (Nat.succ ((Nat.mul +2) (Bits.to_nat b.pred))));
Bits.tail : @(a:Bits) Bits = #a ((((a #a Bits) Bits.nil) #a.pred a.pred) #a.pred a.pred);
Bits.reverse.tco : @(a:Bits) @(r:Bits) Bits = #a #r ((((a #a Bits) r) #a.pred ((Bits.reverse.tco a.pred) (Bits.0 r))) #a.pred ((Bits.reverse.tco a.pred) (Bits.1 r)));
Bits.reverse : @(a:Bits) Bits = #a ((Bits.reverse.tco a) Bits.nil);
Bits.nil : Bits = #P #nil #0 #1 nil;
Bits.inc : @(a:Bits) Bits = #a ((((a #a Bits) (Bits.1 Bits.nil)) #a.pred (Bits.1 a.pred)) #a.pred (Bits.0 (Bits.inc a.pred)));
Bits.eql : @(a:Bits) @(b:Bits) Bool = #a #b ((((a #a Bool) ((((b #b Bool) Bool.true) #b.pred Bool.false) #b.pred Bool.false)) #a.pred ((((b #b Bool) Bool.false) #b.pred ((Bits.eql a.pred) b.pred)) #b.pred Bool.false)) #a.pred ((((b #b Bool) Bool.false) #b.pred Bool.false) #b.pred ((Bits.eql a.pred) b.pred)));
Bits.concat : @(a:Bits) @(b:Bits) Bits = #a #b ((((a #a Bits) b) #a.pred (Bits.0 ((Bits.concat a.pred) b))) #a.pred (Bits.1 ((Bits.concat a.pred) b)));
Bits.chunks_of.go : @(len:Nat) @(bits:Bits) @(need:Nat) @(chunk:Bits) (List Bits) = #len #bits #need #chunk ((((bits #bits (List Bits)) (((List.cons Bits) (Bits.reverse chunk)) (List.nil Bits))) #bits.pred (((need #need (List Bits)) !head = (Bits.reverse chunk); !tail = ((((Bits.chunks_of.go len) bits) len) Bits.nil); (((List.cons Bits) head) tail)) #need.pred !chunk = (Bits.0 chunk); ((((Bits.chunks_of.go len) bits.pred) need.pred) chunk))) #bits.pred (((need #need (List Bits)) !head = (Bits.reverse chunk); !tail = ((((Bits.chunks_of.go len) bits) len) Bits.nil); (((List.cons Bits) head) tail)) #need.pred !chunk = (Bits.1 chunk); ((((Bits.chunks_of.go len) bits.pred) need.pred) chunk)));
Bits.chunks_of : @(len:Nat) @(bits:Bits) (List Bits) = #len #bits ((((Bits.chunks_of.go len) bits) len) Bits.nil);
Bits : * = %Bits.Self(P:@(:Bits) *) @(nil:(P Bits.nil)) @(0:@(pred:Bits) (P (Bits.0 pred))) @(1:@(pred:Bits) (P (Bits.1 pred))) (P Bits.Self);
