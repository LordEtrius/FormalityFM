Word.1 : %(size:Nat) @(pred:(Word size)) (Word (Nat.succ size)) = #size #pred #P #nil #0 #1 ((1 size) pred);
Word.0 : %(size:Nat) @(pred:(Word size)) (Word (Nat.succ size)) = #size #pred #P #nil #0 #1 ((0 size) pred);
Word.zero : @(size:Nat) (Word size) = #size (((size #size (Word size)) Word.nil) #size.pred ((Word.0 size.pred) (Word.zero size.pred)));
Word.trim : %(size:Nat) @(new_size:Nat) @(word:(Word size)) (Word new_size) = #size #new_size #word (((new_size #new_size (Word new_size)) Word.nil) #new_size.pred ((((word #word.size #word (Word (Nat.succ new_size.pred))) ((Word.0 new_size.pred) (((Word.trim Nat.zero) new_size.pred) Word.nil))) #word.size #word.pred ((Word.0 new_size.pred) (((Word.trim word.size) new_size.pred) word.pred))) #word.size #word.pred ((Word.1 new_size.pred) (((Word.trim word.size) new_size.pred) word.pred))));
Word.to_bits : %(size:Nat) @(a:(Word size)) Bits = #size #a ((((a #a.size #a Bits) Bits.nil) #a.size #a.pred (Bits.0 ((Word.to_bits a.size) a.pred))) #a.size #a.pred (Bits.1 ((Word.to_bits a.size) a.pred)));
Word.subber : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:Bool) (Word size) = #size #a #b #c (((((a #a.size #a @(b:(Word a.size)) (Word a.size)) #b Word.nil) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true)))) a.pred)) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.true))) ((Word.0 b.size) ((((Word.subber b.size) a.pred) b.pred) Bool.false)))) a.pred)) b);
Word.sub : %(size:Nat) @(a:(Word size)) @(b:(Word size)) (Word size) = #size #a #b ((((Word.subber size) a) b) Bool.false);
Word.nil : (Word Nat.zero) = #P #nil #0 #1 nil;
Word.lte : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Bool = #size #a #b (Cmp.as_lte (((Word.cmp size) a) b));
Word.inc : %(size:Nat) @(word:(Word size)) (Word size) = #size #word ((((word #word.size #word (Word word.size)) Word.nil) #word.size #word.pred ((Word.1 word.size) word.pred)) #word.size #word.pred ((Word.0 word.size) ((Word.inc word.size) word.pred)));
Word.from_bits : @(size:Nat) @(bits:Bits) (Word size) = #size #bits (((size #size (Word size)) Word.nil) #size.pred ((((bits #bits (Word (Nat.succ size.pred))) ((Word.0 size.pred) ((Word.from_bits size.pred) Bits.nil))) #bits.pred ((Word.0 size.pred) ((Word.from_bits size.pred) bits.pred))) #bits.pred ((Word.1 size.pred) ((Word.from_bits size.pred) bits.pred))));
Word.eql : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Bool = #size #a #b (Cmp.as_eql (((Word.cmp size) a) b));
Word.cmp.go : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:Cmp) Cmp = #size #a #b #c (((((a #a.size #a @(b:(Word a.size)) Cmp) #b c) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) Cmp) #a.pred c) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) c)) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) Cmp.ltn)) a.pred)) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) Cmp) #a.pred c) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) Cmp.gtn)) #b.size #b.pred #a.pred ((((Word.cmp.go b.size) a.pred) b.pred) c)) a.pred)) b);
Word.cmp : %(size:Nat) @(a:(Word size)) @(b:(Word size)) Cmp = #size #a #b ((((Word.cmp.go size) a) b) Cmp.eql);
Word.adder : %(size:Nat) @(a:(Word size)) @(b:(Word size)) @(c:Bool) (Word size) = #size #a #b #c (((((a #a.size #a @(b:(Word a.size)) (Word a.size)) #b Word.nil) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false)))) a.pred)) #a.size #a.pred #b (((((b #b.size #b @(a.pred:(Word (Nat.pred b.size))) (Word b.size)) #a.pred Word.nil) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.false)))) #b.size #b.pred #a.pred (((c #c (Word (Nat.succ b.size))) ((Word.1 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true))) ((Word.0 b.size) ((((Word.adder b.size) a.pred) b.pred) Bool.true)))) a.pred)) b);
Word.add : %(size:Nat) @(a:(Word size)) @(b:(Word size)) (Word size) = #size #a #b ((((Word.adder size) a) b) Bool.false);
Word : @(size:Nat) * = #size %Word.Self(P:@(size:Nat) @(:(Word size)) *) @(nil:((P Nat.zero) Word.nil)) @(0:%(size:Nat) @(pred:(Word size)) ((P (Nat.succ size)) ((Word.0 size) pred))) @(1:%(size:Nat) @(pred:(Word size)) ((P (Nat.succ size)) ((Word.1 size) pred))) ((P size) Word.Self);
U16.zero : U16 = (U16.new (Word.zero +16));
U16.to_word : @(a:U16) (Word +16) = #a ((a #a (Word (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))))))))))))))) #a.value a.value);
U16.sub : @(a:U16) @(b:U16) U16 = #a #b ((a #a U16) #a.value ((b #b U16) #b.value (U16.new (((Word.sub (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value))));
U16.show_hex : @(a:U16) String = #a ((a #a String) #a.value ((Nat.to_string_base +16) (Bits.to_nat ((Word.to_bits +16) a.value))));
U16.new : @(value:(Word +16)) U16 = #value #P #new (new value);
U16.lte : @(a:U16) @(b:U16) Bool = #a #b ((a #a Bool) #a.value ((b #b Bool) #b.value (((Word.lte (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value)));
U16.inc : @(a:U16) U16 = #a ((a #a U16) #a.value (U16.new ((Word.inc (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value)));
U16.eql : @(a:U16) @(b:U16) Bool = #a #b ((a #a Bool) #a.value ((b #b Bool) #b.value (((Word.eql (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value)));
U16.btw : @(a:U16) @(b:U16) @(c:U16) Bool = #a #b #c ((Bool.and ((U16.lte a) b)) ((U16.lte b) c));
U16.add : @(a:U16) @(b:U16) U16 = #a #b ((a #a U16) #a.value ((b #b U16) #b.value (U16.new (((Word.add (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))))))))))))) a.value) b.value))));
U16 : * = %U16.Self(P:@(:U16) *) @(new:@(value:(Word +16)) (P (U16.new value))) (P U16.Self);
Unit.new : Unit = #P #new new;
Unit : * = %Unit.Self(P:@(:Unit) *) @(new:(P Unit.new)) (P Unit.Self);
String.nil : String = #P #nil #cons nil;
String.join.go : @(sep:String) @(list:(List String)) @(fst:Bool) String = #sep #list #fst (((list #list String) "") #list.head #list.tail (String.flatten (((List.cons String) (((fst # String) "") sep)) (((List.cons String) list.head) (((List.cons String) (((String.join.go sep) list.tail) Bool.false)) (List.nil String))))));
String.join : @(sep:String) @(list:(List String)) String = #sep #list (((String.join.go sep) list) Bool.true);
String.is_empty : @(str:String) Bool = #str (((str #str Bool) Bool.true) #str.head #str.tail Bool.false);
String.flatten.go : @(xs:(List String)) @(res:String) String = #xs #res (((xs #xs String) res) #xs.head #xs.tail ((String.flatten.go xs.tail) ((String.concat res) xs.head)));
String.flatten : @(xs:(List String)) String = #xs ((String.flatten.go xs) "");
String.eql : @(a:String) @(b:String) Bool = #a #b (((a #a Bool) (((b #b Bool) Bool.true) #b.head #b.tail Bool.false)) #a.head #a.tail (((b #b Bool) Bool.false) #b.head #b.tail ((Bool.and ((U16.eql a.head) b.head)) ((String.eql a.tail) b.tail))));
String.cons : @(head:Char) @(tail:String) String = #head #tail #P #nil #cons ((cons head) tail);
String.concat : @(as:String) @(bs:String) String = #as #bs (((as #as String) bs) #as.head #as.tail ((String.cons as.head) ((String.concat as.tail) bs)));
String : * = %String.Self(P:@(:String) *) @(nil:(P String.nil)) @(cons:@(head:Char) @(tail:String) (P ((String.cons head) tail))) (P String.Self);
Set.set : @(bits:Bits) @(set:Set) Set = #bits #set ((((Map.set Unit) bits) Unit.new) set);
Set.new : Set = (Map.new Unit);
Set.has : @(bits:Bits) @(set:Set) Bool = #bits #set ((((((Map.get Unit) bits) set) #self Bool) Bool.false) #self.value Bool.true);
Set : * = (Map Unit);
Parser.until : %(A:*) @(cond:(Parser Unit)) @(parser:(Parser A)) (Parser (List A)) = #A #cond #parser ((Parser.many A) (((Parser.if_not A) cond) parser));
Parser.text.go : @(text:String) (Parser Unit) = #text #code (((text #text (Parser.Reply Unit)) (((Parser.Reply.value Unit) code) Unit.new)) #text.head #text.tail (((code #code (Parser.Reply Unit)) !error = (String.flatten (((List.cons String) "Expected \'") (((List.cons String) text) (((List.cons String) "\', found end of file.") (List.nil String))))); (((Parser.Reply.error Unit) code) error)) #code.head #code.tail (((((U16.eql text.head) code.head) # (Parser.Reply Unit)) ((Parser.text text.tail) code.tail)) !error = (String.flatten (((List.cons String) "Expected \'") (((List.cons String) text) (((List.cons String) "\', found \'") (((List.cons String) ((String.cons code.head) String.nil)) (((List.cons String) "\'.") (List.nil String))))))); (((Parser.Reply.error Unit) code) error))));
Parser.text : @(text:String) (Parser Unit) = #text #code (((((Parser.text.go text) code) #reply (Parser.Reply Unit)) #reply.code #reply.err (((Parser.Reply.error Unit) code) reply.err)) #reply.code #reply.val (((Parser.Reply.value Unit) reply.code) reply.val));
Parser.spaces_text : @(text:String) (Parser Unit) = #text ((((((Monad.bind Parser) Parser.monad) (List Unit)) Unit) Parser.spaces) # (Parser.text text));
Parser.spaces : (Parser (List Unit)) = ((Parser.many Unit) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text " ")) (((List.cons (Parser Unit)) (Parser.text "\u{A}")) (List.nil (Parser Unit))))));
Parser.pure : %(V:*) @(value:V) (Parser V) = #V #value #code (((Parser.Reply.value V) code) value);
Parser.one : (Parser Char) = #code (((code #code (Parser.Reply Char)) (((Parser.Reply.error Char) code) "Unexpected end of file.")) #code.head #code.tail (((Parser.Reply.value Char) code.tail) code.head));
Parser.nat : (Parser Nat) = ((((((Monad.bind Parser) Parser.monad) (List Nat)) Nat) ((Parser.many1 Nat) Parser.digit)) #digits ((((Monad.pure Parser) Parser.monad) Nat) ((Nat.from_base +10) digits)));
Parser.monad : (Monad Parser) = (((Monad.new Parser) Parser.bind) Parser.pure);
Parser.maybe : %(V:*) @(parse:(Parser V)) (Parser (Maybe V)) = #V #parse #code ((((parse code) #reply (Parser.Reply (Maybe V))) #reply.code #reply.err (((Parser.Reply.value (Maybe V)) code) (Maybe.none V))) #reply.code #reply.val (((Parser.Reply.value (Maybe V)) reply.code) ((Maybe.some V) reply.val)));
Parser.many.go : %(V:*) @(parse:(Parser V)) @(values:@(:(List V)) (List V)) @(code:String) (Parser.Reply (List V)) = #V #parse #values #code ((((parse code) #reply (Parser.Reply (List V))) #reply.code #reply.err (((Parser.Reply.value (List V)) code) (values (List.nil V)))) #reply.code #reply.val ((((Parser.many.go V) parse) #xs (values (((List.cons V) reply.val) xs))) reply.code));
Parser.many1 : %(V:*) @(parser:(Parser V)) (Parser (List V)) = #V #parser ((((((Monad.bind Parser) Parser.monad) V) (List V)) parser) #head ((((((Monad.bind Parser) Parser.monad) (List V)) (List V)) ((Parser.many V) parser)) #tail ((((Monad.pure Parser) Parser.monad) (List V)) (((List.cons V) head) tail))));
Parser.many : %(V:*) @(parser:(Parser V)) (Parser (List V)) = #V #parser (((Parser.many.go V) parser) #x x);
Parser.if_not : %(A:*) @(a:(Parser Unit)) @(b:(Parser A)) (Parser A) = #A #a #b #code ((((a code) #self (Parser.Reply A)) #self.code #self.err (b code)) #self.code #self.val (((Parser.Reply.error A) code) "Prevented."));
Parser.first_of : %(A:*) @(pars:(List (Parser A))) (Parser A) = #A #pars #code (((pars #pars (Parser.Reply A)) (((Parser.Reply.error A) code) "No parse.")) #pars.head #pars.tail !parsed = (pars.head code); (((parsed #parsed (Parser.Reply A)) #parsed.code #parsed.err (((Parser.first_of A) pars.tail) code)) #parsed.code #parsed.val (((Parser.Reply.value A) parsed.code) parsed.val)));
Parser.digit : (Parser Nat) = #code (((code #code (Parser.Reply Nat)) (((Parser.Reply.error Nat) code) "No parse.")) #code.head #code.tail (((((U16.eql code.head) '0') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +0)) (((((U16.eql code.head) '1') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +1)) (((((U16.eql code.head) '2') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +2)) (((((U16.eql code.head) '3') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +3)) (((((U16.eql code.head) '4') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +4)) (((((U16.eql code.head) '5') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +5)) (((((U16.eql code.head) '6') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +6)) (((((U16.eql code.head) '7') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +7)) (((((U16.eql code.head) '8') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +8)) (((((U16.eql code.head) '9') # (Parser.Reply Nat)) (((Parser.Reply.value Nat) code.tail) +9)) (((Parser.Reply.error Nat) code) "No parse."))))))))))));
Parser.char_if : @(fun:@(:Char) Bool) (Parser Char) = #fun #code (((code #code (Parser.Reply Char)) (((Parser.Reply.error Char) code) "No parse.")) #code.head #code.tail ((((fun code.head) # (Parser.Reply Char)) (((Parser.Reply.value Char) code.tail) code.head)) (((Parser.Reply.error Char) code) "No parse.")));
Parser.bind : %(A:*) %(B:*) @(parse:(Parser A)) @(next:@(:A) (Parser B)) (Parser B) = #A #B #parse #next #code ((((parse code) #reply (Parser.Reply B)) #reply.code #reply.err (((Parser.Reply.error B) reply.code) reply.err)) #reply.code #reply.val ((next reply.val) reply.code));
Parser.Reply.value : %(V:*) @(code:String) @(val:V) (Parser.Reply V) = #V #code #val #P #error #value ((value code) val);
Parser.Reply.error : %(V:*) @(code:String) @(err:String) (Parser.Reply V) = #V #code #err #P #error #value ((error code) err);
Parser.Reply : @(V:*) * = #V %Parser.Reply.Self(P:@(:(Parser.Reply V)) *) @(error:@(code:String) @(err:String) (P (((Parser.Reply.error V) code) err))) @(value:@(code:String) @(val:V) (P (((Parser.Reply.value V) code) val))) (P Parser.Reply.Self);
Parser : @(V:*) * = #V @(:String) (Parser.Reply V);
Pair.snd : %(A:*) %(B:*) @(pair:((Pair A) B)) B = #A #B #pair ((pair #pair B) #pair.fst #pair.snd pair.snd);
Pair.new : %(A:*) %(B:*) @(fst:A) @(snd:B) ((Pair A) B) = #A #B #fst #snd #P #new ((new fst) snd);
Pair.fst : %(A:*) %(B:*) @(pair:((Pair A) B)) A = #A #B #pair ((pair #pair A) #pair.fst #pair.snd pair.fst);
Pair : @(A:*) @(B:*) * = #A #B %Pair.Self(P:@(:((Pair A) B)) *) @(new:@(fst:A) @(snd:B) (P ((((Pair.new A) B) fst) snd))) (P Pair.Self);
Nat.zero : Nat = #P #zero #succ zero;
Nat.to_u16 : @(n:Nat) U16 = #n ((((Nat.apply U16) n) U16.inc) U16.zero);
Nat.to_string_base : @(base:Nat) @(nat:Nat) String = #base #nat (((((List.fold Nat) ((Nat.to_base base) nat)) String) String.nil) #n #str ((String.cons ((Nat.show_digit base) n)) str));
Nat.to_bits : @(n:Nat) Bits = #n (((n #n Bits) Bits.nil) #n.pred (Bits.inc (Nat.to_bits n.pred)));
Nat.to_base.go : @(base:Nat) @(nat:Nat) @(res:(List Nat)) (List Nat) = #base #nat #res ((((Nat.div_mod nat) base) #div_mod (List Nat)) #div_mod.fst #div_mod.snd (((div_mod.fst #div_mod.fst (List Nat)) (((List.cons Nat) div_mod.snd) res)) #div_mod.fst.pred (((Nat.to_base.go base) div_mod.fst) (((List.cons Nat) div_mod.snd) res))));
Nat.to_base : @(base:Nat) @(nat:Nat) (List Nat) = #base #nat (((Nat.to_base.go base) nat) (List.nil Nat));
Nat.succ : @(pred:Nat) Nat = #pred #P #zero #succ (succ pred);
Nat.sub_rem : @(n:Nat) @(m:Nat) ((Either Nat) Nat) = #n #m (((m #m ((Either Nat) Nat)) (((Either.left Nat) Nat) n)) #m.pred (((n #n ((Either Nat) Nat)) (((Either.right Nat) Nat) (Nat.succ m.pred))) #n.pred ((Nat.sub_rem n.pred) m.pred)));
Nat.sub : @(n:Nat) @(m:Nat) Nat = #n #m (((n #n Nat) +0) #n.pred (((m #m Nat) n) #m.pred ((Nat.sub n.pred) m.pred)));
Nat.show_digit : @(base:Nat) @(n:Nat) Char = #base #n !m = ((Nat.mod n) base); !base64 = (((List.cons Char) '0') (((List.cons Char) '1') (((List.cons Char) '2') (((List.cons Char) '3') (((List.cons Char) '4') (((List.cons Char) '5') (((List.cons Char) '6') (((List.cons Char) '7') (((List.cons Char) '8') (((List.cons Char) '9') (((List.cons Char) 'A') (((List.cons Char) 'B') (((List.cons Char) 'C') (((List.cons Char) 'D') (((List.cons Char) 'E') (((List.cons Char) 'F') (((List.cons Char) 'G') (((List.cons Char) 'H') (((List.cons Char) 'I') (((List.cons Char) 'J') (((List.cons Char) 'K') (((List.cons Char) 'L') (((List.cons Char) 'M') (((List.cons Char) 'N') (((List.cons Char) 'O') (((List.cons Char) 'P') (((List.cons Char) 'Q') (((List.cons Char) 'R') (((List.cons Char) 'S') (((List.cons Char) 'T') (((List.cons Char) 'U') (((List.cons Char) 'V') (((List.cons Char) 'W') (((List.cons Char) 'X') (((List.cons Char) 'Y') (((List.cons Char) 'Z') (((List.cons Char) 'a') (((List.cons Char) 'b') (((List.cons Char) 'c') (((List.cons Char) 'd') (((List.cons Char) 'e') (((List.cons Char) 'f') (((List.cons Char) 'g') (((List.cons Char) 'h') (((List.cons Char) 'i') (((List.cons Char) 'j') (((List.cons Char) 'k') (((List.cons Char) 'l') (((List.cons Char) 'm') (((List.cons Char) 'n') (((List.cons Char) 'o') (((List.cons Char) 'p') (((List.cons Char) 'q') (((List.cons Char) 'r') (((List.cons Char) 's') (((List.cons Char) 't') (((List.cons Char) 'u') (((List.cons Char) 'v') (((List.cons Char) 'w') (((List.cons Char) 'x') (((List.cons Char) 'y') (((List.cons Char) 'z') (((List.cons Char) '+') (((List.cons Char) '/') (List.nil Char))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))); (((((Bool.and ((Nat.gtn base) +0)) ((Nat.lte base) +64)) # Char) ((((((List.at Char) m) base64) #c Char) '#') #c.value c.value)) '#');
Nat.show : @(n:Nat) String = #n ((Nat.to_string_base +10) n);
Nat.pred : @(n:Nat) Nat = #n (((n #n Nat) Nat.zero) #n.pred n.pred);
Nat.mul : @(n:Nat) @(m:Nat) Nat = #n #m (((n #n Nat) Nat.zero) #n.pred ((Nat.add m) ((Nat.mul n.pred) m)));
Nat.mod : @(n:Nat) @(m:Nat) Nat = #n #m (((Pair.snd Nat) Nat) ((Nat.div_mod n) m));
Nat.lte : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_lte ((Nat.cmp n) m));
Nat.gtn : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_gtn ((Nat.cmp n) m));
Nat.gte : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_gte ((Nat.cmp n) m));
Nat.from_base.go : @(b:Nat) @(ds:(List Nat)) @(p:Nat) @(res:Nat) Nat = #b #ds #p #res (((ds #ds Nat) res) #ds.head #ds.tail ((((Nat.from_base.go b) ds.tail) ((Nat.mul b) p)) ((Nat.add ((Nat.mul ds.head) p)) res)));
Nat.from_base : @(base:Nat) @(ds:(List Nat)) Nat = #base #ds ((((Nat.from_base.go base) ((List.reverse Nat) ds)) +1) +0);
Nat.eql : @(n:Nat) @(m:Nat) Bool = #n #m (Cmp.as_eql ((Nat.cmp n) m));
Nat.div_mod.go : @(n:Nat) @(m:Nat) @(d:Nat) ((Pair Nat) Nat) = #n #m #d (((((Nat.sub_rem n) m) #p ((Pair Nat) Nat)) #p.value (((Nat.div_mod.go p.value) m) (Nat.succ d))) #p.value ((((Pair.new Nat) Nat) d) n));
Nat.div_mod : @(n:Nat) @(m:Nat) ((Pair Nat) Nat) = #n #m (((Nat.div_mod.go n) m) Nat.zero);
Nat.cmp : @(a:Nat) @(b:Nat) Cmp = #a #b (((a #a Cmp) (((b #b Cmp) Cmp.eql) #b.pred Cmp.ltn)) #a.pred (((b #b Cmp) Cmp.gtn) #b.pred ((Nat.cmp a.pred) b.pred)));
Nat.apply : %(A:*) @(n:Nat) @(f:@(x:A) A) @(x:A) A = #A #n #f #x (((n #n A) x) #n.pred ((((Nat.apply A) n.pred) f) (f x)));
Nat.add : @(n:Nat) @(m:Nat) Nat = #n #m (((n #n Nat) m) #n.pred (Nat.succ ((Nat.add n.pred) m)));
Nat : * = %Nat.Self(P:@(:Nat) *) @(zero:(P Nat.zero)) @(succ:@(pred:Nat) (P (Nat.succ pred))) (P Nat.Self);
Monad.pure : %(M:@(:*) *) @(m:(Monad M)) %(A:*) @(:A) (M A) = #M #m ((m #m %(A:*) @(:A) (M A)) #m.bind #m.pure m.pure);
Monad.new : %(M:@(:*) *) @(bind:%(A:*) %(B:*) @(m:(M A)) @(f:@(x:A) (M B)) (M B)) @(pure:%(A:*) @(x:A) (M A)) (Monad M) = #M #bind #pure #P #new ((new bind) pure);
Monad.bind : %(M:@(:*) *) @(m:(Monad M)) %(A:*) %(B:*) @(:(M A)) @(:@(:A) (M B)) (M B) = #M #m ((m #m %(A:*) %(B:*) @(:(M A)) @(:@(:A) (M B)) (M B)) #m.bind #m.pure m.bind);
Monad : @(M:@(:*) *) * = #M %Monad.Self(P:@(:(Monad M)) *) @(new:@(bind:%(A:*) %(B:*) @(m:(M A)) @(f:@(x:A) (M B)) (M B)) @(pure:%(A:*) @(x:A) (M A)) (P (((Monad.new M) bind) pure))) (P Monad.Self);
Maybe.to_bool : %(A:*) @(m:(Maybe A)) Bool = #A #m (((m #m Bool) Bool.false) #m.value Bool.true);
Maybe.some : %(A:*) @(value:A) (Maybe A) = #A #value #P #none #some (some value);
Maybe.or : %(A:*) @(a:(Maybe A)) @(b:(Maybe A)) (Maybe A) = #A #a #b (((a #a (Maybe A)) b) #a.value ((Maybe.some A) a.value));
Maybe.none : %(A:*) (Maybe A) = #A #P #none #some none;
Maybe.monad : (Monad Maybe) = (((Monad.new Maybe) Maybe.bind) Maybe.some);
Maybe.mapped : %(A:*) @(m:(Maybe A)) %(B:*) @(f:@(:A) B) (Maybe B) = #A #m #B #f (((m #m (Maybe B)) (Maybe.none B)) #m.value ((Maybe.some B) (f m.value)));
Maybe.default : %(A:*) @(a:A) @(m:(Maybe A)) A = #A #a #m (((m #m A) a) #m.value m.value);
Maybe.bind : %(A:*) %(B:*) @(m:(Maybe A)) @(f:@(:A) (Maybe B)) (Maybe B) = #A #B #m #f (((m #m (Maybe B)) (Maybe.none B)) #m.value (f m.value));
Maybe : @(A:*) * = #A %Maybe.Self(P:@(:(Maybe A)) *) @(none:(P (Maybe.none A))) @(some:@(value:A) (P ((Maybe.some A) value))) (P Maybe.Self);
Map.values.go : %(A:*) @(xs:(Map A)) @(list:(List A)) (List A) = #A #xs #list (((xs #xs (List A)) list) #xs.val #xs.lft #xs.rgt !list0 = (((xs.val #xs.val (List A)) list) #xs.val.value (((List.cons A) xs.val.value) list)); !list1 = (((Map.values.go A) xs.lft) list0); !list2 = (((Map.values.go A) xs.rgt) list1); list2);
Map.values : %(A:*) @(xs:(Map A)) (List A) = #A #xs (((Map.values.go A) xs) (List.nil A));
Map.to_list.go : %(A:*) @(xs:(Map A)) @(key:Bits) @(list:(List ((Pair Bits) A))) (List ((Pair Bits) A)) = #A #xs #key #list (((xs #xs (List ((Pair Bits) A))) list) #xs.val #xs.lft #xs.rgt !list0 = (((xs.val #xs.val (List ((Pair Bits) A))) list) #xs.val.value (((List.cons ((Pair Bits) A)) ((((Pair.new Bits) A) (Bits.reverse key)) xs.val.value)) list)); !list1 = ((((Map.to_list.go A) xs.lft) (Bits.0 key)) list0); !list2 = ((((Map.to_list.go A) xs.rgt) (Bits.1 key)) list1); list2);
Map.to_list : %(A:*) @(xs:(Map A)) (List ((Pair Bits) A)) = #A #xs ((List.reverse ((Pair Bits) A)) ((((Map.to_list.go A) xs) Bits.nil) (List.nil ((Pair Bits) A))));
Map.tie : %(A:*) @(val:(Maybe A)) @(lft:(Map A)) @(rgt:(Map A)) (Map A) = #A #val #lft #rgt #P #new #tie (((tie val) lft) rgt);
Map.set : %(A:*) @(bits:Bits) @(val:A) @(map:(Map A)) (Map A) = #A #bits #val #map ((((bits #bits (Map A)) (((map #map (Map A)) ((((Map.tie A) ((Maybe.some A) val)) (Map.new A)) (Map.new A))) #map.val #map.lft #map.rgt ((((Map.tie A) ((Maybe.some A) val)) map.lft) map.rgt))) #bits.pred (((map #map (Map A)) ((((Map.tie A) (Maybe.none A)) ((((Map.set A) bits.pred) val) (Map.new A))) (Map.new A))) #map.val #map.lft #map.rgt ((((Map.tie A) map.val) ((((Map.set A) bits.pred) val) map.lft)) map.rgt))) #bits.pred (((map #map (Map A)) ((((Map.tie A) (Maybe.none A)) (Map.new A)) ((((Map.set A) bits.pred) val) (Map.new A)))) #map.val #map.lft #map.rgt ((((Map.tie A) map.val) map.lft) ((((Map.set A) bits.pred) val) map.rgt))));
Map.new : %(A:*) (Map A) = #A #P #new #tie new;
Map.get : %(A:*) @(bits:Bits) @(map:(Map A)) (Maybe A) = #A #bits #map ((((bits #bits (Maybe A)) (((map #map (Maybe A)) (Maybe.none A)) #map.val #map.lft #map.rgt map.val)) #bits.pred (((map #map (Maybe A)) (Maybe.none A)) #map.val #map.lft #map.rgt (((Map.get A) bits.pred) map.lft))) #bits.pred (((map #map (Maybe A)) (Maybe.none A)) #map.val #map.lft #map.rgt (((Map.get A) bits.pred) map.rgt)));
Map.from_list : %(A:*) %(B:*) @(f:@(:A) Bits) @(xs:(List ((Pair A) B))) (Map B) = #A #B #f #xs (((xs #xs (Map B)) (Map.new B)) #xs.head #xs.tail ((xs.head #p (Map B)) #p.fst #p.snd ((((Map.set B) (f p.fst)) p.snd) ((((Map.from_list A) B) f) xs.tail))));
Map : @(A:*) * = #A %Map.Self(P:@(:(Map A)) *) @(new:(P (Map.new A))) @(tie:@(val:(Maybe A)) @(lft:(Map A)) @(rgt:(Map A)) (P ((((Map.tie A) val) lft) rgt))) (P Map.Self);
List.reverse.go : %(A:*) @(xs:(List A)) @(res:(List A)) (List A) = #A #xs #res (((xs #xs (List A)) res) #xs.head #xs.tail (((List.reverse.go A) xs.tail) (((List.cons A) xs.head) res)));
List.reverse : %(A:*) @(xs:(List A)) (List A) = #A #xs (((List.reverse.go A) xs) (List.nil A));
List.nil : %(A:*) (List A) = #A #P #nil #cons nil;
List.mapped : %(A:*) @(as:(List A)) %(B:*) @(f:@(:A) B) (List B) = #A #as #B #f (((as #as (List B)) (List.nil B)) #as.head #as.tail (((List.cons B) (f as.head)) ((((List.mapped A) as.tail) B) f)));
List.length.go : %(A:*) @(xs:(List A)) @(n:Nat) Nat = #A #xs #n (((xs #xs Nat) n) #xs.head #xs.tail (((List.length.go A) xs.tail) (Nat.succ n)));
List.length : %(A:*) @(xs:(List A)) Nat = #A #xs (((List.length.go A) xs) +0);
List.is_empty : %(A:*) @(list:(List A)) Bool = #A #list (((list #list Bool) Bool.true) #list.head #list.tail Bool.false);
List.for : %(A:*) @(xs:(List A)) %(B:*) @(b:B) @(f:@(:A) @(:B) B) B = #A #xs #B #b #f (((xs #xs B) b) #xs.head #xs.tail (((((List.for A) xs.tail) B) ((f xs.head) b)) f));
List.fold : %(A:*) @(list:(List A)) %(P:*) @(:P) @(:@(:A) @(:P) P) P = #A #list #P #nil #cons (((list #list P) nil) #list.head #list.tail ((cons list.head) (((((List.fold A) list.tail) P) nil) cons)));
List.flatten : %(A:*) @(xs:(List (List A))) (List A) = #A #xs (((xs #xs (List A)) (List.nil A)) #xs.head #xs.tail (((List.concat A) xs.head) ((List.flatten A) xs.tail)));
List.cons : %(A:*) @(head:A) @(tail:(List A)) (List A) = #A #head #tail #P #nil #cons ((cons head) tail);
List.concat : %(A:*) @(as:(List A)) @(bs:(List A)) (List A) = #A #as #bs (((as #as (List A)) bs) #as.head #as.tail (((List.cons A) as.head) (((List.concat A) as.tail) bs)));
List.at_last : %(A:*) @(index:Nat) @(list:(List A)) (Maybe A) = #A #index #list (((List.at A) index) ((List.reverse A) list));
List.at : %(A:*) @(index:Nat) @(list:(List A)) (Maybe A) = #A #index #list (((list #list (Maybe A)) (Maybe.none A)) #list.head #list.tail (((index #index (Maybe A)) ((Maybe.some A) list.head)) #index.pred (((List.at A) index.pred) list.tail)));
List : @(A:*) * = #A %List.Self(P:@(:(List A)) *) @(nil:(P (List.nil A))) @(cons:@(head:A) @(tail:(List A)) (P (((List.cons A) head) tail))) (P List.Self);
Fm.to_core_one : @(code:String) @(name:String) String = #code #name !defs = (((Maybe.default Fm.Defs) (Map.new Fm.Def)) (Fm.Defs.read code)); !defs = ((Fm.Synth.one name) defs); (Fm.Defs.core defs);
Fm.to_core_all : @(code:String) String = #code !defs = (((Maybe.default Fm.Defs) (Map.new Fm.Def)) (Fm.Defs.read code)); !defs = (Fm.Synth.all defs); (Fm.Defs.core defs);
Fm.set : %(A:*) @(name:Fm.Name) @(val:A) @(map:(Map A)) (Map A) = #A #name #val #map ((((Map.set A) (Fm.Name.to_bits name)) val) map);
Fm.get : %(A:*) @(name:Fm.Name) @(map:(Map A)) (Maybe A) = #A #name #map (((Map.get A) (Fm.Name.to_bits name)) map);
Fm.exports : Unit = !_ = Fm.to_core_all; !_ = Fm.to_core_one; !_ = Fm.check_all; !_ = Fm.check_one; Unit.new;
Fm.escape.char : @(chr:Char) String = #chr (((((U16.eql chr) Fm.backslash) # String) ((String.cons Fm.backslash) ((String.cons chr) String.nil))) (((((U16.eql chr) '\"') # String) ((String.cons Fm.backslash) ((String.cons chr) String.nil))) (((((U16.eql chr) '\'') # String) ((String.cons Fm.backslash) ((String.cons chr) String.nil))) ((((((U16.btw ' ') chr) '~') # String) ((String.cons chr) String.nil)) (String.flatten (((List.cons String) ((String.cons Fm.backslash) String.nil)) (((List.cons String) "u{") (((List.cons String) (U16.show_hex chr)) (((List.cons String) "}") (((List.cons String) String.nil) (List.nil String)))))))))));
Fm.escapes : (List ((Pair String) Char)) = (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\b") '\u{8}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\f") '\u{C}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\n") '\u{A}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\r") '\u{D}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\t") '\u{9}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\v") '\u{B}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) ((String.cons Fm.backslash) ((String.cons Fm.backslash) String.nil))) Fm.backslash)) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\\"") '\"')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\0") '\u{0}')) (((List.cons ((Pair String) Char)) ((((Pair.new String) Char) "\\\'") '\'')) (List.nil ((Pair String) Char))))))))))));
Fm.escape : @(str:String) String = #str (((str #str String) String.nil) #str.head #str.tail !head = (Fm.escape.char str.head); !tail = (Fm.escape str.tail); ((String.concat head) tail));
Fm.check_one : @(code:String) @(name:String) String = #code #name !defs = (((Maybe.default Fm.Defs) (Map.new Fm.Def)) (Fm.Defs.read code)); !defs = ((Fm.Synth.one name) defs); (Fm.Defs.report defs);
Fm.check_all : @(code:String) String = #code !defs = (((Maybe.default Fm.Defs) (Map.new Fm.Def)) (Fm.Defs.read code)); !defs = (Fm.Synth.all defs); (Fm.Defs.report defs);
Fm.backslash : Char = (Nat.to_u16 +92);
Fm.Term.var : @(name:Fm.Name) @(indx:Nat) Fm.Term = #name #indx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((var name) indx);
Fm.Term.unroll_str : @(strx:String) Fm.Term = #strx (((strx #strx Fm.Term) (Fm.Term.ref (Fm.Name.read "String.nil"))) #strx.head #strx.tail !char = (Fm.Term.chr strx.head); !term = (Fm.Term.ref (Fm.Name.read "String.cons")); !term = ((Fm.Term.app term) char); !term = ((Fm.Term.app term) (Fm.Term.str strx.tail)); term);
Fm.Term.unroll_nat : @(natx:Nat) Fm.Term = #natx (((natx #natx Fm.Term) (Fm.Term.ref (Fm.Name.read "Nat.zero"))) #natx.pred !func = (Fm.Term.ref (Fm.Name.read "Nat.succ")); !argm = (Fm.Term.nat natx.pred); ((Fm.Term.app func) argm));
Fm.Term.unroll_chr.bits : @(bits:Bits) Fm.Term = #bits ((((bits #bits Fm.Term) (Fm.Term.ref (Fm.Name.read "Bits.nil"))) #bits.pred ((Fm.Term.app (Fm.Term.ref (Fm.Name.read "Bits.0"))) (Fm.Term.unroll_chr.bits bits.pred))) #bits.pred ((Fm.Term.app (Fm.Term.ref (Fm.Name.read "Bits.1"))) (Fm.Term.unroll_chr.bits bits.pred)));
Fm.Term.unroll_chr : @(chrx:Char) Fm.Term = #chrx ((chrx #chrx Fm.Term) #chrx.value !term = (Fm.Term.ref (Fm.Name.read "Word.from_bits")); !term = ((Fm.Term.app term) (Fm.Term.nat +16)); !term = ((Fm.Term.app term) (Fm.Term.unroll_chr.bits ((Word.to_bits +16) chrx.value))); !term = ((Fm.Term.app (Fm.Term.ref (Fm.Name.read "U16.new"))) term); term);
Fm.Term.typ : Fm.Term = #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse typ;
Fm.Term.str : @(strx:String) Fm.Term = #strx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (str strx);
Fm.Term.show.is_ref : @(term:Fm.Term) @(name:Fm.Name) Bool = #term #name ((((((((((((((((term #term Bool) #term.name #term.indx Bool.false) #term.name ((String.eql name) term.name)) Bool.false) #term.eras #term.self #term.name #term.xtyp #term.body Bool.false) #term.name #term.body Bool.false) #term.func #term.argm Bool.false) #term.name #term.expr #term.body Bool.false) #term.name #term.expr #term.body Bool.false) #term.done #term.term #term.type Bool.false) #term.name #term.dref #term.verb Bool.false) #term.path Bool.false) #term.natx Bool.false) #term.chrx Bool.false) #term.strx Bool.false) #term.path #term.expr #term.name #term.with #term.cses #term.moti Bool.false);
Fm.Term.show.go : @(term:Fm.Term) @(path:(Maybe @(:Bits) Bits)) String = #term #path ((((Fm.Term.show.as_nat term) #as_nat String) ((((((((((((((((term #term String) #term.name #term.indx (Fm.Name.show term.name)) #term.name !name = (Fm.Name.show term.name); (((path #path String) name) #path.value !path_val = ((Bits.concat (Fm.Path.to_bits path.value)) (Bits.1 Bits.nil)); !path_str = (Nat.show (Bits.to_nat path_val)); (String.flatten (((List.cons String) name) (((List.cons String) (Fm.Term.show.color '2')) (((List.cons String) "-") (((List.cons String) path_str) (((List.cons String) (Fm.Term.show.color '0')) (List.nil String))))))))) "Type") #term.eras #term.self #term.name #term.xtyp #term.body !eras = term.eras; !self = (Fm.Name.show term.self); !name = (Fm.Name.show term.name); !type = ((Fm.Term.show.go term.xtyp) (Fm.MPath.0 path)); !open = (((eras # String) "<") "("); !clos = (((eras # String) ">") ")"); !body = ((Fm.Term.show.go ((term.body ((Fm.Term.var term.self) +0)) ((Fm.Term.var term.name) +0))) (Fm.MPath.1 path)); (String.flatten (((List.cons String) self) (((List.cons String) open) (((List.cons String) name) (((List.cons String) ":") (((List.cons String) type) (((List.cons String) clos) (((List.cons String) " ") (((List.cons String) body) (List.nil String))))))))))) #term.name #term.body !name = (Fm.Name.show term.name); !body = ((Fm.Term.show.go (term.body ((Fm.Term.var term.name) +0))) (Fm.MPath.0 path)); (String.flatten (((List.cons String) "(") (((List.cons String) name) (((List.cons String) ") ") (((List.cons String) body) (List.nil String))))))) #term.func #term.argm (((Fm.Term.show.app term) path) (List.nil String))) #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = ((Fm.Term.show.go term.expr) (Fm.MPath.0 path)); !body = ((Fm.Term.show.go (term.body ((Fm.Term.var term.name) +0))) (Fm.MPath.1 path)); (String.flatten (((List.cons String) "let ") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = ((Fm.Term.show.go term.expr) (Fm.MPath.0 path)); !body = ((Fm.Term.show.go (term.body ((Fm.Term.var term.name) +0))) (Fm.MPath.1 path)); (String.flatten (((List.cons String) "def ") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.done #term.term #term.type !term = ((Fm.Term.show.go term.term) (Fm.MPath.0 path)); !type = ((Fm.Term.show.go term.type) (Fm.MPath.1 path)); (String.flatten (((List.cons String) term) (((List.cons String) "::") (((List.cons String) type) (List.nil String)))))) #term.name #term.dref #term.verb !name = (Fm.Name.show term.name); (String.flatten (((List.cons String) "?") (((List.cons String) name) (List.nil String))))) #term.path "_") #term.natx (String.flatten (((List.cons String) (Nat.show term.natx)) (List.nil String)))) #term.chrx (String.flatten (((List.cons String) "\'") (((List.cons String) (Fm.escape.char term.chrx)) (((List.cons String) "\'") (List.nil String)))))) #term.strx (String.flatten (((List.cons String) "\"") (((List.cons String) (Fm.escape term.strx)) (((List.cons String) "\"") (List.nil String)))))) #term.path #term.expr #term.name #term.with #term.cses #term.moti !expr = ((Fm.Term.show.go term.expr) (Fm.MPath.0 path)); !name = (Fm.Name.show term.name); !with = ((String.join "") ((((List.mapped Fm.Def) term.with) String) #def ((def #def String) #def.name #def.term #def.type #def.stat !name = (Fm.Name.show def.name); !type = ((Fm.Term.show.go def.type) (Maybe.none @(:Bits) Bits)); !term = ((Fm.Term.show.go def.term) (Maybe.none @(:Bits) Bits)); (String.flatten (((List.cons String) name) (((List.cons String) ": ") (((List.cons String) type) (((List.cons String) " = ") (((List.cons String) term) (((List.cons String) ";") (List.nil String))))))))))); !cses = ((Map.to_list Fm.Term) term.cses); !cses = ((String.join "") ((((List.mapped ((Pair Bits) Fm.Term)) cses) String) #x !name = (Fm.Name.from_bits (((Pair.fst Bits) Fm.Term) x)); !term = ((Fm.Term.show.go (((Pair.snd Bits) Fm.Term) x)) (Maybe.none @(:Bits) Bits)); (String.flatten (((List.cons String) name) (((List.cons String) ": ") (((List.cons String) term) (((List.cons String) "; ") (List.nil String)))))))); !moti = ((Fm.Term.show.go term.moti) (Maybe.none @(:Bits) Bits)); (String.flatten (((List.cons String) "case ") (((List.cons String) expr) (((List.cons String) " as ") (((List.cons String) name) (((List.cons String) with) (((List.cons String) " { ") (((List.cons String) cses) (((List.cons String) "} : ") (((List.cons String) moti) (List.nil String))))))))))))) #as_nat.value as_nat.value);
Fm.Term.show.color : @(chr:Char) String = #chr ((String.cons (Nat.to_u16 +27)) ((String.cons '[') ((String.cons chr) ((String.cons 'm') String.nil))));
Fm.Term.show.as_nat.go : @(term:Fm.Term) (Maybe Nat) = #term ((((((((((((((((term #term (Maybe Nat)) #term.name #term.indx (Maybe.none Nat)) #term.name (((((String.eql term.name) "Nat.zero") # (Maybe Nat)) ((Maybe.some Nat) +0)) (Maybe.none Nat))) (Maybe.none Nat)) #term.eras #term.self #term.name #term.xtyp #term.body (Maybe.none Nat)) #term.name #term.body (Maybe.none Nat)) #term.func #term.argm ((((((((((((((((term.func #term.func (Maybe Nat)) #term.func.name #term.func.indx (Maybe.none Nat)) #term.func.name (((((String.eql term.func.name) "Nat.succ") # (Maybe Nat)) ((((((Monad.bind Maybe) Maybe.monad) Nat) Nat) (Fm.Term.show.as_nat.go term.argm)) #pred ((((Monad.pure Maybe) Maybe.monad) Nat) (Nat.succ pred)))) (Maybe.none Nat))) (Maybe.none Nat)) #term.func.eras #term.func.self #term.func.name #term.func.xtyp #term.func.body (Maybe.none Nat)) #term.func.name #term.func.body (Maybe.none Nat)) #term.func.func #term.func.argm (Maybe.none Nat)) #term.func.name #term.func.expr #term.func.body (Maybe.none Nat)) #term.func.name #term.func.expr #term.func.body (Maybe.none Nat)) #term.func.done #term.func.term #term.func.type (Maybe.none Nat)) #term.func.name #term.func.dref #term.func.verb (Maybe.none Nat)) #term.func.path (Maybe.none Nat)) #term.func.natx (Maybe.none Nat)) #term.func.chrx (Maybe.none Nat)) #term.func.strx (Maybe.none Nat)) #term.func.path #term.func.expr #term.func.name #term.func.with #term.func.cses #term.func.moti (Maybe.none Nat))) #term.name #term.expr #term.body (Maybe.none Nat)) #term.name #term.expr #term.body (Maybe.none Nat)) #term.done #term.term #term.type (Maybe.none Nat)) #term.name #term.dref #term.verb (Maybe.none Nat)) #term.path (Maybe.none Nat)) #term.natx (Maybe.none Nat)) #term.chrx (Maybe.none Nat)) #term.strx (Maybe.none Nat)) #term.path #term.expr #term.name #term.with #term.cses #term.moti (Maybe.none Nat));
Fm.Term.show.as_nat : @(term:Fm.Term) (Maybe String) = #term ((((Maybe.mapped Nat) (Fm.Term.show.as_nat.go term)) String) Nat.show);
Fm.Term.show.app : @(term:Fm.Term) @(path:(Maybe @(:Bits) Bits)) @(args:(List String)) String = #term #path #args ((((((((((((((((term #term String) #term.name #term.indx !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.name !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.eras #term.self #term.name #term.xtyp #term.body !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.name #term.body !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.func #term.argm !argm = ((Fm.Term.show.go term.argm) (Fm.MPath.1 path)); (((Fm.Term.show.app term.func) (Fm.MPath.0 path)) (((List.cons String) argm) args))) #term.name #term.expr #term.body !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.name #term.expr #term.body !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.done #term.term #term.type !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.name #term.dref #term.verb !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.path !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.natx !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.chrx !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.strx !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String)))))))) #term.path #term.expr #term.name #term.with #term.cses #term.moti !arity = ((List.length String) args); (((((Bool.and ((Fm.Term.show.is_ref term) "Equal")) ((Nat.eql arity) +3)) # String) !func = ((Fm.Term.show.go term) path); !eq_lft = (((Maybe.default String) "?") (((List.at String) +1) args)); !eq_rgt = (((Maybe.default String) "?") (((List.at String) +2) args)); (String.flatten (((List.cons String) eq_lft) (((List.cons String) " == ") (((List.cons String) eq_rgt) (List.nil String)))))) !func = ((Fm.Term.show.go term) path); !wrap = (((func #func Bool) Bool.false) #func.head #func.tail ((U16.eql func.head) '(')); !args = ((String.join ",") args); !func = (((wrap # String) (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) ")") (List.nil String)))))) func); (String.flatten (((List.cons String) func) (((List.cons String) "(") (((List.cons String) args) (((List.cons String) ")") (List.nil String))))))));
Fm.Term.show : @(term:Fm.Term) String = #term ((Fm.Term.show.go term) (Maybe.none @(:Bits) Bits));
Fm.Term.serialize.go : @(term:Fm.Term) @(depth:Nat) @(init:Nat) @(x:Bits) Bits = #term #depth #init #x ((((((((((((((((term #term Bits) #term.name #term.indx (((((Nat.gte term.indx) init) # Bits) !name = (Bits.concat (Nat.to_bits (Nat.pred ((Nat.sub depth) term.indx)))); (Bits.0 (Bits.0 (Bits.1 (name x))))) !name = (Bits.concat (Nat.to_bits term.indx)); (Bits.0 (Bits.1 (Bits.0 (name x)))))) #term.name !name = (Bits.concat (Fm.Name.to_bits term.name)); (Bits.0 (Bits.0 (Bits.0 (name x))))) (Bits.0 (Bits.1 (Bits.1 x)))) #term.eras #term.self #term.name #term.xtyp #term.body !eras = (((term.eras # @(pred:Bits) Bits) Bits.1) Bits.0); !self = (Bits.concat (Fm.Name.to_bits term.self)); !xtyp = (((Fm.Term.serialize.go term.xtyp) depth) init); !body = (((Fm.Term.serialize.go ((term.body ((Fm.Term.var term.self) depth)) ((Fm.Term.var term.name) (Nat.succ depth)))) (Nat.succ (Nat.succ depth))) init); (Bits.1 (Bits.0 (Bits.0 (eras (self (xtyp (body x)))))))) #term.name #term.body !body = (((Fm.Term.serialize.go (term.body ((Fm.Term.var term.name) depth))) (Nat.succ depth)) init); (Bits.1 (Bits.0 (Bits.1 (body x))))) #term.func #term.argm !func = (((Fm.Term.serialize.go term.func) depth) init); !argm = (((Fm.Term.serialize.go term.argm) depth) init); (Bits.1 (Bits.1 (Bits.0 (func (argm x)))))) #term.name #term.expr #term.body !expr = (((Fm.Term.serialize.go term.expr) depth) init); !body = (((Fm.Term.serialize.go (term.body ((Fm.Term.var term.name) depth))) (Nat.succ depth)) init); (Bits.1 (Bits.1 (Bits.1 (expr (body x)))))) #term.name #term.expr #term.body ((((Fm.Term.serialize.go (term.body term.expr)) depth) init) x)) #term.done #term.term #term.type ((((Fm.Term.serialize.go term.term) depth) init) x)) #term.name #term.dref #term.verb !name = (Bits.concat (Fm.Name.to_bits term.name)); (Bits.0 (Bits.0 (Bits.0 (name x))))) #term.path x) #term.natx (Bits.0 (Bits.0 (Bits.0 ((Bits.concat (Nat.to_bits term.natx)) x))))) #term.chrx (Bits.0 (Bits.0 (Bits.0 ((Bits.concat ((Word.to_bits +16) (U16.to_word term.chrx))) x))))) #term.strx ((((Fm.Term.serialize.go (Fm.Term.unroll_str term.strx)) depth) init) x)) #term.path #term.expr #term.name #term.with #term.cses #term.moti x);
Fm.Term.serialize : @(term:Fm.Term) @(depth:Nat) Bits = #term #depth ((((Fm.Term.serialize.go term) depth) depth) Bits.nil);
Fm.Term.ref : @(name:Fm.Name) Fm.Term = #name #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (ref name);
Fm.Term.reduce : @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #term #defs ((((((((((((((((term #term Fm.Term) #term.name #term.indx term) #term.name ((((((Fm.get Fm.Def) term.name) defs) #got Fm.Term) (Fm.Term.ref term.name)) #got.value ((got.value #got.value Fm.Term) #got.value.name #got.value.term #got.value.type #got.value.stat ((Fm.Term.reduce got.value.term) defs)))) term) #term.eras #term.self #term.name #term.xtyp #term.body term) #term.name #term.body term) #term.func #term.argm !func = ((Fm.Term.reduce term.func) defs); ((((((((((((((((func #func Fm.Term) #func.name #func.indx term) #func.name term) term) #func.eras #func.self #func.name #func.xtyp #func.body term) #func.name #func.body ((Fm.Term.reduce (func.body term.argm)) defs)) #func.func #func.argm term) #func.name #func.expr #func.body term) #func.name #func.expr #func.body term) #func.done #func.term #func.type term) #func.name #func.dref #func.verb term) #func.path term) #func.natx term) #func.chrx term) #func.strx term) #func.path #func.expr #func.name #func.with #func.cses #func.moti term)) #term.name #term.expr #term.body ((Fm.Term.reduce (term.body term.expr)) defs)) #term.name #term.expr #term.body ((Fm.Term.reduce (term.body term.expr)) defs)) #term.done #term.term #term.type ((Fm.Term.reduce term.term) defs)) #term.name #term.dref #term.verb term) #term.path term) #term.natx ((Fm.Term.reduce (Fm.Term.unroll_nat term.natx)) defs)) #term.chrx ((Fm.Term.reduce (Fm.Term.unroll_chr term.chrx)) defs)) #term.strx ((Fm.Term.reduce (Fm.Term.unroll_str term.strx)) defs)) #term.path #term.expr #term.name #term.with #term.cses #term.moti term);
Fm.Term.patch_at : @(path:Bits) @(term:Fm.Term) @(fn:@(:Fm.Term) Fm.Term) Fm.Term = #path #term #fn ((((((((((((((((term #term Fm.Term) #term.name #term.indx ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.name ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.eras #term.self #term.name #term.xtyp #term.body ((((path #path Fm.Term) (fn term)) #path.pred (((((Fm.Term.all term.eras) term.self) term.name) (((Fm.Term.patch_at path.pred) term.xtyp) fn)) term.body)) #path.pred (((((Fm.Term.all term.eras) term.self) term.name) term.xtyp) #s #x (((Fm.Term.patch_at path.pred) ((term.body s) x)) fn)))) #term.name #term.body ((((path #path Fm.Term) (fn term)) #path.pred ((Fm.Term.lam term.name) #x (((Fm.Term.patch_at (Bits.tail path)) (term.body x)) fn))) #path.pred ((Fm.Term.lam term.name) #x (((Fm.Term.patch_at (Bits.tail path)) (term.body x)) fn)))) #term.func #term.argm ((((path #path Fm.Term) (fn term)) #path.pred ((Fm.Term.app (((Fm.Term.patch_at path.pred) term.func) fn)) term.argm)) #path.pred ((Fm.Term.app term.func) (((Fm.Term.patch_at path.pred) term.argm) fn)))) #term.name #term.expr #term.body ((((path #path Fm.Term) (fn term)) #path.pred (((Fm.Term.let term.name) (((Fm.Term.patch_at path.pred) term.expr) fn)) term.body)) #path.pred (((Fm.Term.let term.name) term.expr) #x (((Fm.Term.patch_at path.pred) (term.body x)) fn)))) #term.name #term.expr #term.body ((((path #path Fm.Term) (fn term)) #path.pred (((Fm.Term.def term.name) (((Fm.Term.patch_at path.pred) term.expr) fn)) term.body)) #path.pred (((Fm.Term.def term.name) term.expr) #x (((Fm.Term.patch_at path.pred) (term.body x)) fn)))) #term.done #term.term #term.type ((((path #path Fm.Term) (fn term)) #path.pred (((Fm.Term.ann term.done) (((Fm.Term.patch_at path) term.term) fn)) term.type)) #path.pred (((Fm.Term.ann term.done) (((Fm.Term.patch_at path) term.term) fn)) term.type))) #term.name #term.dref #term.verb ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.path ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.natx ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.chrx ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.strx ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term)) #term.path #term.expr #term.name #term.with #term.cses #term.moti ((((path #path Fm.Term) (fn term)) #path.pred term) #path.pred term));
Fm.Term.normalize : @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #term #defs ((((((((((((((((((Fm.Term.reduce term) defs) #term Fm.Term) #term.name #term.indx ((Fm.Term.var term.name) term.indx)) #term.name (Fm.Term.ref term.name)) Fm.Term.typ) #term.eras #term.self #term.name #term.xtyp #term.body $xtyp = ((Fm.Term.normalize term.xtyp) defs); $body = #s #x ((Fm.Term.normalize ((term.body s) x)) defs); (((((Fm.Term.all term.eras) term.self) term.name) xtyp) body)) #term.name #term.body $body = #x ((Fm.Term.normalize (term.body x)) defs); ((Fm.Term.lam term.name) body)) #term.func #term.argm $func = ((Fm.Term.normalize term.func) defs); $argm = ((Fm.Term.normalize term.argm) defs); ((Fm.Term.app func) argm)) #term.name #term.expr #term.body $expr = ((Fm.Term.normalize term.expr) defs); $body = #x ((Fm.Term.normalize (term.body x)) defs); (((Fm.Term.let term.name) expr) body)) #term.name #term.expr #term.body $expr = ((Fm.Term.normalize term.expr) defs); $body = #x ((Fm.Term.normalize (term.body x)) defs); (((Fm.Term.def term.name) expr) body)) #term.done #term.term #term.type $term = ((Fm.Term.normalize term.term) defs); $type = ((Fm.Term.normalize term.type) defs); (((Fm.Term.ann term.done) term) type)) #term.name #term.dref #term.verb (((Fm.Term.gol term.name) term.dref) term.verb)) #term.path (Fm.Term.hol term.path)) #term.natx (Fm.Term.nat term.natx)) #term.chrx (Fm.Term.chr term.chrx)) #term.strx (Fm.Term.str term.strx)) #term.path #term.expr #term.name #term.with #term.cses #term.moti term);
Fm.Term.nat : @(natx:Nat) Fm.Term = #natx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (nat natx);
Fm.Term.let : @(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) Fm.Term = #name #expr #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((let name) expr) body);
Fm.Term.lam : @(name:Fm.Name) @(body:@(:Fm.Term) Fm.Term) Fm.Term = #name #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((lam name) body);
Fm.Term.hol : @(path:Bits) Fm.Term = #path #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (hol path);
Fm.Term.gol : @(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) Fm.Term = #name #dref #verb #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((gol name) dref) verb);
Fm.Term.expand_ct : @(term:Fm.Term) @(defs:Fm.Defs) @(arity:Nat) Fm.Term = #term #defs #arity ((((((((((((((((term #term Fm.Term) #term.name #term.indx ((Fm.Term.var term.name) term.indx)) #term.name !expand = Bool.false; !expand = ((Bool.or ((Bool.and ((String.eql term.name) "Nat.succ")) ((Nat.gtn arity) +1))) expand); !expand = ((Bool.or ((Bool.and ((String.eql term.name) "Nat.zero")) ((Nat.gtn arity) +0))) expand); !expand = ((Bool.or ((Bool.and ((String.eql term.name) "Bool.true")) ((Nat.gtn arity) +0))) expand); !expand = ((Bool.or ((Bool.and ((String.eql term.name) "Bool.false")) ((Nat.gtn arity) +0))) expand); (((expand # Fm.Term) ((((((Fm.get Fm.Def) term.name) defs) #got Fm.Term) (Fm.Term.ref term.name)) #got.value ((got.value #got.value Fm.Term) #got.value.name #got.value.term #got.value.type #got.value.stat got.value.term))) (Fm.Term.ref term.name))) Fm.Term.typ) #term.eras #term.self #term.name #term.xtyp #term.body $xtyp = (((Fm.Term.expand_ct term.xtyp) defs) +0); $body = #s #x (((Fm.Term.expand_ct ((term.body s) x)) defs) +0); (((((Fm.Term.all term.eras) term.self) term.name) xtyp) body)) #term.name #term.body $body = #x (((Fm.Term.expand_ct (term.body x)) defs) +0); ((Fm.Term.lam term.name) body)) #term.func #term.argm $func = (((Fm.Term.expand_ct term.func) defs) (Nat.succ arity)); $argm = (((Fm.Term.expand_ct term.argm) defs) +0); ((Fm.Term.app func) argm)) #term.name #term.expr #term.body $expr = (((Fm.Term.expand_ct term.expr) defs) +0); $body = #x (((Fm.Term.expand_ct (term.body x)) defs) +0); (((Fm.Term.let term.name) expr) body)) #term.name #term.expr #term.body $expr = (((Fm.Term.expand_ct term.expr) defs) +0); $body = #x (((Fm.Term.expand_ct (term.body x)) defs) +0); (((Fm.Term.def term.name) expr) body)) #term.done #term.term #term.type $term = (((Fm.Term.expand_ct term.term) defs) +0); $type = (((Fm.Term.expand_ct term.type) defs) +0); (((Fm.Term.ann term.done) term) type)) #term.name #term.dref #term.verb (((Fm.Term.gol term.name) term.dref) term.verb)) #term.path (Fm.Term.hol term.path)) #term.natx (Fm.Term.nat term.natx)) #term.chrx (Fm.Term.chr term.chrx)) #term.strx (Fm.Term.str term.strx)) #term.path #term.expr #term.name #term.with #term.cses #term.moti term);
Fm.Term.expand_at : @(path:Bits) @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #path #term #defs (((Fm.Term.patch_at path) term) #term ((((((((((((((((term #term Fm.Term) #term.name #term.indx term) #term.name ((((((Fm.get Fm.Def) term.name) defs) #got Fm.Term) (Fm.Term.ref term.name)) #got.value ((got.value #got.value Fm.Term) #got.value.name #got.value.term #got.value.type #got.value.stat got.value.term))) term) #term.eras #term.self #term.name #term.xtyp #term.body term) #term.name #term.body term) #term.func #term.argm term) #term.name #term.expr #term.body term) #term.name #term.expr #term.body term) #term.done #term.term #term.type term) #term.name #term.dref #term.verb term) #term.path term) #term.natx term) #term.chrx term) #term.strx term) #term.path #term.expr #term.name #term.with #term.cses #term.moti term));
Fm.Term.expand : @(dref:(List Bits)) @(term:Fm.Term) @(defs:Fm.Defs) Fm.Term = #dref #term #defs !term = ((Fm.Term.normalize term) (Map.new Fm.Def)); !term = (((((List.for Bits) dref) Fm.Term) term) #path #term !term = (((Fm.Term.expand_at path) term) defs); !term = ((Fm.Term.normalize term) (Map.new Fm.Def)); !term = (((Fm.Term.expand_ct term) defs) +0); !term = ((Fm.Term.normalize term) (Map.new Fm.Def)); term); term;
Fm.Term.equal.patch : @(path:Bits) @(term:Fm.Term) (Fm.Check Bool) = #path #term (((Fm.Check.result Bool) ((Maybe.some Bool) Bool.true)) (((List.cons Fm.Error) ((Fm.Error.patch path) ((Fm.Term.normalize term) (Map.new Fm.Def)))) (List.nil Fm.Error)));
Fm.Term.equal : @(a:Fm.Term) @(b:Fm.Term) @(defs:Fm.Defs) @(lv:Nat) @(seen:Set) (Fm.Check Bool) = #a #b #defs #lv #seen !a1 = ((Fm.Term.reduce a) defs); !b1 = ((Fm.Term.reduce b) defs); !ah = ((Fm.Term.serialize a1) lv); !bh = ((Fm.Term.serialize b1) lv); !id = ((Bits.concat ah) bh); (((((Bool.or ((Bits.eql ah) bh)) ((Set.has id) seen)) # (Fm.Check Bool)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.true)) ((((((((((((((((a1 #a1 (Fm.Check Bool)) #a1.name #a1.indx ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.eras #a1.self #a1.name #a1.xtyp #a1.body ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body !seen = ((Set.set id) seen); !a1_body = ((a1.body ((Fm.Term.var a1.self) lv)) ((Fm.Term.var a1.name) (Nat.succ lv))); !b1_body = ((b1.body ((Fm.Term.var b1.self) lv)) ((Fm.Term.var b1.name) (Nat.succ lv))); !eq_self = ((String.eql a1.self) b1.self); !eq_eras = ((Bool.eql a1.eras) b1.eras); (((((Bool.and eq_self) eq_eras) # (Fm.Check Bool)) ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.xtyp) b1.xtyp) defs) lv) seen)) #eq_type ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1_body) b1_body) defs) (Nat.succ (Nat.succ lv))) seen)) #eq_body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) ((Bool.and eq_type) eq_body))))) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name #a1.body ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body !seen = ((Set.set id) seen); !a1_body = (a1.body ((Fm.Term.var a1.name) lv)); !b1_body = (b1.body ((Fm.Term.var b1.name) lv)); ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1_body) b1_body) defs) (Nat.succ lv)) seen)) #eq_body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) eq_body))) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.func #a1.argm ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm !seen = ((Set.set id) seen); ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.func) b1.func) defs) lv) seen)) #eq_func ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.argm) b1.argm) defs) lv) seen)) #eq_argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) ((Bool.and eq_func) eq_argm))))) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name #a1.expr #a1.body ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body !seen = ((Set.set id) seen); !a1_body = (a1.body ((Fm.Term.var a1.name) lv)); !b1_body = (b1.body ((Fm.Term.var b1.name) lv)); ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1.expr) b1.expr) defs) lv) seen)) #eq_expr ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Bool) (((((Fm.Term.equal a1_body) b1_body) defs) (Nat.succ lv)) seen)) #eq_body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) ((Bool.and eq_expr) eq_body))))) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name #a1.expr #a1.body ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.done #a1.term #a1.type ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.name #a1.dref #a1.verb ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.path ((Fm.Term.equal.patch a1.path) b)) #a1.natx ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.chrx ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.strx ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))) #a1.path #a1.expr #a1.name #a1.with #a1.cses #a1.moti ((((((((((((((((b1 #b1 (Fm.Check Bool)) #b1.name #b1.indx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.eras #b1.self #b1.name #b1.xtyp #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.func #b1.argm ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.expr #b1.body ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.done #b1.term #b1.type ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.name #b1.dref #b1.verb ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path ((Fm.Term.equal.patch b1.path) a)) #b1.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false)) #b1.path #b1.expr #b1.name #b1.with #b1.cses #b1.moti ((((Monad.pure Fm.Check) Fm.Check.monad) Bool) Bool.false))));
Fm.Term.desugar_cse.motive : @(wyth:(List Fm.Def)) @(moti:Fm.Term) Fm.Term = #wyth #moti (((wyth #wyth Fm.Term) moti) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $all_name = wyth.head.name; $all_xtyp = wyth.head.type; $all_body = #s #x ((Fm.Term.desugar_cse.motive wyth.tail) moti); (((((Fm.Term.all Bool.false) "") all_name) all_xtyp) all_body)));
Fm.Term.desugar_cse.cases : @(expr:Fm.Term) @(name:Fm.Name) @(wyth:(List Fm.Def)) @(cses:(Map Fm.Term)) @(type:Fm.Term) @(defs:Fm.Defs) @(ctxt:Fm.Context) Fm.Term = #expr #name #wyth #cses #type #defs #ctxt ((((((((((((((((((Fm.Term.reduce type) defs) #type Fm.Term) #type.name #type.indx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.name !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.eras #type.self #type.name #type.xtyp #type.body !got = (((Maybe.or Fm.Term) (((Fm.get Fm.Term) type.name) cses)) (((Fm.get Fm.Term) "_") cses)); (((got #got Fm.Term) !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((def #def Fm.Term) #def.name #def.term #def.type #def.stat ((Fm.Term.app expr) def.term))); expr) #got.value !argm = (((((Fm.Term.desugar_cse.argument name) wyth) type.xtyp) got.value) defs); !expr = ((Fm.Term.app expr) argm); !type = ((type.body ((Fm.Term.var type.self) +0)) ((Fm.Term.var type.name) +0)); (((((((Fm.Term.desugar_cse.cases expr) name) wyth) cses) type) defs) ctxt))) #type.name #type.body !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.func #type.argm !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.name #type.expr #type.body !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.name #type.expr #type.body !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.done #type.term #type.type !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.name #type.dref #type.verb !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.path !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.natx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.chrx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.strx !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr) #type.path #type.expr #type.name #type.with #type.cses #type.moti !expr = (((((List.for Fm.Def) wyth) Fm.Term) expr) #def #expr ((Fm.Term.app expr) ((def #def Fm.Term) #def.name #def.term #def.type #def.stat def.term))); expr);
Fm.Term.desugar_cse.argument : @(name:Fm.Name) @(wyth:(List Fm.Def)) @(type:Fm.Term) @(body:Fm.Term) @(defs:Fm.Defs) Fm.Term = #name #wyth #type #body #defs ((((((((((((((((((Fm.Term.reduce type) defs) #type Fm.Term) #type.name #type.indx (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.name (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.eras #type.self #type.name #type.xtyp #type.body $type = ((type.body ((Fm.Term.var type.self) +0)) ((Fm.Term.var type.name) +0)); $lam_name = ((((String.is_empty type.name) # Fm.Name) name) (String.flatten (((List.cons String) name) (((List.cons String) ".") (((List.cons Fm.Name) type.name) (List.nil Fm.Name)))))); $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth) type) body) defs); ((Fm.Term.lam lam_name) lam_body)) #type.name #type.body (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.func #type.argm (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.name #type.expr #type.body (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.name #type.expr #type.body (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.done #type.term #type.type (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.name #type.dref #type.verb (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.path (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.natx (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.chrx (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.strx (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body)))) #type.path #type.expr #type.name #type.with #type.cses #type.moti (((wyth #wyth Fm.Term) body) #wyth.head #wyth.tail ((wyth.head #wyth.head Fm.Term) #wyth.head.name #wyth.head.term #wyth.head.type #wyth.head.stat $lam_name = wyth.head.name; $lam_body = #x (((((Fm.Term.desugar_cse.argument name) wyth.tail) type) body) defs); ((Fm.Term.lam lam_name) lam_body))));
Fm.Term.desugar_cse : @(expr:Fm.Term) @(name:Fm.Name) @(with:(List Fm.Def)) @(cses:(Map Fm.Term)) @(moti:Fm.Term) @(type:Fm.Term) @(defs:Fm.Defs) @(ctxt:Fm.Context) (Maybe Fm.Term) = #expr #name #with #cses #moti #type #defs #ctxt ((((((((((((((((((Fm.Term.reduce type) defs) #type (Maybe Fm.Term)) #type.name #type.indx (Maybe.none Fm.Term)) #type.name (Maybe.none Fm.Term)) (Maybe.none Fm.Term)) #type.eras #type.self #type.name #type.xtyp #type.body !moti = ((Fm.Term.desugar_cse.motive with) moti); !argm = (((((Fm.Term.desugar_cse.argument name) (List.nil Fm.Def)) type.xtyp) moti) defs); !expr = ((Fm.Term.app expr) argm); !type = ((type.body ((Fm.Term.var type.self) +0)) ((Fm.Term.var type.name) +0)); ((Maybe.some Fm.Term) (((((((Fm.Term.desugar_cse.cases expr) name) with) cses) type) defs) ctxt))) #type.name #type.body (Maybe.none Fm.Term)) #type.func #type.argm (Maybe.none Fm.Term)) #type.name #type.expr #type.body (Maybe.none Fm.Term)) #type.name #type.expr #type.body (Maybe.none Fm.Term)) #type.done #type.term #type.type (Maybe.none Fm.Term)) #type.name #type.dref #type.verb (Maybe.none Fm.Term)) #type.path (Maybe.none Fm.Term)) #type.natx (Maybe.none Fm.Term)) #type.chrx (Maybe.none Fm.Term)) #type.strx (Maybe.none Fm.Term)) #type.path #type.expr #type.name #type.with #type.cses #type.moti (Maybe.none Fm.Term));
Fm.Term.def : @(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) Fm.Term = #name #expr #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((def name) expr) body);
Fm.Term.cse : @(path:Bits) @(expr:Fm.Term) @(name:Fm.Name) @(with:(List Fm.Def)) @(cses:(Map Fm.Term)) @(moti:Fm.Term) Fm.Term = #path #expr #name #with #cses #moti #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((((((cse path) expr) name) with) cses) moti);
Fm.Term.core : @(term:Fm.Term) String = #term ((((((((((((((((term #term String) #term.name #term.indx (Fm.Name.show term.name)) #term.name (Fm.Name.show term.name)) "*") #term.eras #term.self #term.name #term.xtyp #term.body !eras = term.eras; !init = (((eras # String) "%") "@"); !self = (Fm.Name.show term.self); !name = (Fm.Name.show term.name); !xtyp = (Fm.Term.core term.xtyp); !body = (Fm.Term.core ((term.body ((Fm.Term.var term.self) +0)) ((Fm.Term.var term.name) +0))); (String.flatten (((List.cons String) init) (((List.cons String) self) (((List.cons String) "(") (((List.cons String) name) (((List.cons String) ":") (((List.cons String) xtyp) (((List.cons String) ") ") (((List.cons String) body) (List.nil String))))))))))) #term.name #term.body !name = (Fm.Name.show term.name); !body = (Fm.Term.core (term.body ((Fm.Term.var term.name) +0))); (String.flatten (((List.cons String) "#") (((List.cons String) name) (((List.cons String) " ") (((List.cons String) body) (List.nil String))))))) #term.func #term.argm !func = (Fm.Term.core term.func); !argm = (Fm.Term.core term.argm); (String.flatten (((List.cons String) "(") (((List.cons String) func) (((List.cons String) " ") (((List.cons String) argm) (((List.cons String) ")") (List.nil String)))))))) #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = (Fm.Term.core term.expr); !body = (Fm.Term.core (term.body ((Fm.Term.var term.name) +0))); (String.flatten (((List.cons String) "!") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.name #term.expr #term.body !name = (Fm.Name.show term.name); !expr = (Fm.Term.core term.expr); !body = (Fm.Term.core (term.body ((Fm.Term.var term.name) +0))); (String.flatten (((List.cons String) "$") (((List.cons String) name) (((List.cons String) " = ") (((List.cons String) expr) (((List.cons String) "; ") (((List.cons String) body) (List.nil String))))))))) #term.done #term.term #term.type !term = (Fm.Term.core term.term); !type = (Fm.Term.core term.type); (String.flatten (((List.cons String) "{") (((List.cons String) term) (((List.cons String) ":") (((List.cons String) type) (((List.cons String) "}") (List.nil String)))))))) #term.name #term.dref #term.verb "<ERROR>") #term.path "<ERROR>") #term.natx (String.flatten (((List.cons String) "+") (((List.cons String) (Nat.show term.natx)) (List.nil String))))) #term.chrx (String.flatten (((List.cons String) "\'") (((List.cons String) (Fm.escape.char term.chrx)) (((List.cons String) "\'") (List.nil String)))))) #term.strx (String.flatten (((List.cons String) "\"") (((List.cons String) (Fm.escape term.strx)) (((List.cons String) "\"") (List.nil String)))))) #term.path #term.expr #term.name #term.with #term.cses #term.moti "<ERROR>");
Fm.Term.chr : @(chrx:Char) Fm.Term = #chrx #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (chr chrx);
Fm.Term.check : @(term:Fm.Term) @(type:(Maybe Fm.Term)) @(defs:Fm.Defs) @(ctx:Fm.Context) @(path:Fm.MPath) (Fm.Check Fm.Term) = #term #type #defs #ctx #path ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) ((((((((((((((((term #term (Fm.Check Fm.Term)) #term.name #term.indx ((((((List.at_last ((Pair Fm.Name) Fm.Term)) term.indx) ctx) #got (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (Fm.Error.undefined_reference term.name)) (List.nil Fm.Error)))) #got.value ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) ((got.value #got.value Fm.Term) #got.value.fst #got.value.snd got.value.snd)))) #term.name ((((((Fm.get Fm.Def) term.name) defs) #got (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (Fm.Error.undefined_reference term.name)) (List.nil Fm.Error)))) #got.value ((got.value #got.value (Fm.Check Fm.Term)) #got.value.name #got.value.term #got.value.type #got.value.stat !ref_name = got.value.name; !ref_type = got.value.type; !ref_term = got.value.term; !ref_stat = got.value.stat; (((((ref_stat #ref_stat (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) ref_type)) (((List.cons Fm.Error) (Fm.Error.waiting ref_name)) (List.nil Fm.Error)))) (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) ref_type)) (List.nil Fm.Error))) (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) ref_type)) (List.nil Fm.Error))) #ref_stat.errors (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) ref_type)) (((List.cons Fm.Error) (Fm.Error.indirect ref_name)) (List.nil Fm.Error))))))) ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term.typ)) #term.eras #term.self #term.name #term.xtyp #term.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); !self_var = ((Fm.Term.var term.self) ctx_size); !body_var = ((Fm.Term.var term.name) (Nat.succ ctx_size)); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) term.xtyp)) (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.self) term)) ctx)); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.xtyp) ((Maybe.some Fm.Term) Fm.Term.typ)) defs) ctx) (Fm.MPath.0 path))) # ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check ((term.body self_var) body_var)) ((Maybe.some Fm.Term) Fm.Term.typ)) defs) body_ctx) (Fm.MPath.1 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term.typ)))) #term.name #term.body (((type #type (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((Fm.Error.cant_infer term) ctx)) (List.nil Fm.Error)))) #type.value !typv = ((Fm.Term.reduce type.value) defs); ((((((((((((((((typv #typv (Fm.Check Fm.Term)) #typv.name #typv.indx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.name !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.eras #typv.self #typv.name #typv.xtyp #typv.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); !self_var = term; !body_var = ((Fm.Term.var term.name) ctx_size); !body_typ = ((typv.body self_var) body_var); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) typv.xtyp)) ctx); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check (term.body body_var)) ((Maybe.some Fm.Term) body_typ)) defs) body_ctx) (Fm.MPath.0 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) type.value))) #typv.name #typv.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.func #typv.argm !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.name #typv.expr #typv.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.name #typv.expr #typv.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.done #typv.term #typv.type !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.name #typv.dref #typv.verb !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.path !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.natx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.chrx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.strx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #typv.path #typv.expr #typv.name #typv.with #typv.cses #typv.moti !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) type.value); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))))) #term.func #term.argm ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.func) (Maybe.none Fm.Term)) defs) ctx) (Fm.MPath.0 path))) #func_typ !func_typ = ((Fm.Term.reduce func_typ) defs); ((((((((((((((((func_typ #func_typ (Fm.Check Fm.Term)) #func_typ.name #func_typ.indx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.name !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.eras #func_typ.self #func_typ.name #func_typ.xtyp #func_typ.body ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.argm) ((Maybe.some Fm.Term) func_typ.xtyp)) defs) ctx) (Fm.MPath.1 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) ((func_typ.body term.func) term.argm)))) #func_typ.name #func_typ.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.func #func_typ.argm !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.name #func_typ.expr #func_typ.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.name #func_typ.expr #func_typ.body !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.done #func_typ.term #func_typ.type !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.name #func_typ.dref #func_typ.verb !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.path !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.natx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.chrx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.strx !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))) #func_typ.path #func_typ.expr #func_typ.name #func_typ.with #func_typ.cses #func_typ.moti !expected = (((Either.left String) Fm.Term) "Function"); !detected = (((Either.right String) Fm.Term) func_typ); (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch expected) detected) ctx)) (List.nil Fm.Error)))))) #term.name #term.expr #term.body !ctx_size = ((List.length ((Pair Fm.Name) Fm.Term)) ctx); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.expr) (Maybe.none Fm.Term)) defs) ctx) (Fm.MPath.0 path))) #expr_typ !body_val = (term.body ((Fm.Term.var term.name) ctx_size)); !body_ctx = (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) expr_typ)) ctx); ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check body_val) type) defs) body_ctx) (Fm.MPath.1 path))) #body_typ ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) body_typ)))) #term.name #term.expr #term.body (((((Fm.Term.check (term.body term.expr)) type) defs) ctx) path)) #term.done #term.term #term.type (((term.done # (Fm.Check Fm.Term)) ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) term.type)) ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.term) ((Maybe.some Fm.Term) term.type)) defs) ctx) (Fm.MPath.0 path))) # ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check term.type) ((Maybe.some Fm.Term) Fm.Term.typ)) defs) ctx) (Fm.MPath.1 path))) # ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) term.type))))) #term.name #term.dref #term.verb (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((((Fm.Error.show_goal term.name) term.dref) term.verb) type) ctx)) (List.nil Fm.Error)))) #term.path (((Fm.Check.result Fm.Term) type) (List.nil Fm.Error))) #term.natx ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) (Fm.Term.ref "Nat"))) #term.chrx ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) (Fm.Term.ref "Char"))) #term.strx ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) (Fm.Term.ref "String"))) #term.path #term.expr #term.name #term.with #term.cses #term.moti !expr = term.expr; ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Fm.Term) (((((Fm.Term.check expr) (Maybe.none Fm.Term)) defs) ctx) (Fm.MPath.0 path))) #etyp !dsug = ((((((((Fm.Term.desugar_cse term.expr) term.name) term.with) term.cses) term.moti) etyp) defs) ctx); (((dsug #dsug (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((Fm.Error.cant_infer term) ctx)) (List.nil Fm.Error)))) #dsug.value (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) ((Fm.Error.patch (Fm.MPath.to_bits path)) dsug.value)) (List.nil Fm.Error))))))) #infr (((type #type (Fm.Check Fm.Term)) (((Fm.Check.result Fm.Term) ((Maybe.some Fm.Term) infr)) (List.nil Fm.Error))) #type.value ((((((Monad.bind Fm.Check) Fm.Check.monad) Bool) Fm.Term) (((((Fm.Term.equal type.value) infr) defs) ((List.length ((Pair Fm.Name) Fm.Term)) ctx)) Set.new)) #eqls (((eqls # (Fm.Check Fm.Term)) ((((Monad.pure Fm.Check) Fm.Check.monad) Fm.Term) type.value)) (((Fm.Check.result Fm.Term) type) (((List.cons Fm.Error) (((Fm.Error.type_mismatch (((Either.right String) Fm.Term) type.value)) (((Either.right String) Fm.Term) infr)) ctx)) (List.nil Fm.Error)))))));
Fm.Term.bind : @(vars:Fm.Context) @(path:Fm.Path) @(term:Fm.Term) Fm.Term = #vars #path #term ((((((((((((((((term #term Fm.Term) #term.name #term.indx ((((((List.at_last ((Pair Fm.Name) Fm.Term)) term.indx) vars) #got Fm.Term) ((Fm.Term.var term.name) term.indx)) #got.value (((Pair.snd Fm.Name) Fm.Term) got.value))) #term.name (((((Fm.Context.find term.name) vars) #got Fm.Term) (Fm.Term.ref term.name)) #got.value got.value)) Fm.Term.typ) #term.eras #term.self #term.name #term.xtyp #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $xtyp = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.xtyp); $body = #s #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.self) s)) vars))) (Fm.Path.1 path)) ((term.body ((Fm.Term.var term.self) vlen)) ((Fm.Term.var term.name) (Nat.succ vlen)))); (((((Fm.Term.all term.eras) term.self) term.name) xtyp) body)) #term.name #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $body = #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) vars)) (Fm.Path.0 path)) (term.body ((Fm.Term.var term.name) vlen))); ((Fm.Term.lam term.name) body)) #term.func #term.argm $func = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.func); $argm = (((Fm.Term.bind vars) (Fm.Path.1 path)) term.argm); ((Fm.Term.app func) argm)) #term.name #term.expr #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $expr = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.expr); $body = #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) vars)) (Fm.Path.1 path)) (term.body ((Fm.Term.var term.name) vlen))); (((Fm.Term.let term.name) expr) body)) #term.name #term.expr #term.body !vlen = ((List.length ((Pair Fm.Name) Fm.Term)) vars); $expr = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.expr); $body = #x (((Fm.Term.bind (((List.cons ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) term.name) x)) vars)) (Fm.Path.1 path)) (term.body ((Fm.Term.var term.name) vlen))); (((Fm.Term.def term.name) expr) body)) #term.done #term.term #term.type $term = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.term); $type = (((Fm.Term.bind vars) (Fm.Path.1 path)) term.type); (((Fm.Term.ann term.done) term) type)) #term.name #term.dref #term.verb (((Fm.Term.gol term.name) term.dref) term.verb)) #term.path (Fm.Term.hol (Fm.Path.to_bits path))) #term.natx (Fm.Term.nat term.natx)) #term.chrx (Fm.Term.chr term.chrx)) #term.strx (Fm.Term.str term.strx)) #term.path #term.expr #term.name #term.with #term.cses #term.moti !expr = (((Fm.Term.bind vars) (Fm.Path.0 path)) term.expr); !name = term.name; !with = term.with; !cses = term.cses; !moti = term.moti; ((((((Fm.Term.cse (Fm.Path.to_bits path)) expr) name) with) cses) moti));
Fm.Term.app : @(func:Fm.Term) @(argm:Fm.Term) Fm.Term = #func #argm #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse ((app func) argm);
Fm.Term.ann : @(done:Bool) @(term:Fm.Term) @(type:Fm.Term) Fm.Term = #done #term #type #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((ann done) term) type);
Fm.Term.all : @(eras:Bool) @(self:Fm.Name) @(name:Fm.Name) @(xtyp:Fm.Term) @(body:@(:Fm.Term) @(:Fm.Term) Fm.Term) Fm.Term = #eras #self #name #xtyp #body #P #var #ref #typ #all #lam #app #let #def #ann #gol #hol #nat #chr #str #cse (((((all eras) self) name) xtyp) body);
Fm.Term : * = %Fm.Term.Self(P:@(:Fm.Term) *) @(var:@(name:Fm.Name) @(indx:Nat) (P ((Fm.Term.var name) indx))) @(ref:@(name:Fm.Name) (P (Fm.Term.ref name))) @(typ:(P Fm.Term.typ)) @(all:@(eras:Bool) @(self:Fm.Name) @(name:Fm.Name) @(xtyp:Fm.Term) @(body:@(:Fm.Term) @(:Fm.Term) Fm.Term) (P (((((Fm.Term.all eras) self) name) xtyp) body))) @(lam:@(name:Fm.Name) @(body:@(:Fm.Term) Fm.Term) (P ((Fm.Term.lam name) body))) @(app:@(func:Fm.Term) @(argm:Fm.Term) (P ((Fm.Term.app func) argm))) @(let:@(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) (P (((Fm.Term.let name) expr) body))) @(def:@(name:Fm.Name) @(expr:Fm.Term) @(body:@(:Fm.Term) Fm.Term) (P (((Fm.Term.def name) expr) body))) @(ann:@(done:Bool) @(term:Fm.Term) @(type:Fm.Term) (P (((Fm.Term.ann done) term) type))) @(gol:@(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) (P (((Fm.Term.gol name) dref) verb))) @(hol:@(path:Bits) (P (Fm.Term.hol path))) @(nat:@(natx:Nat) (P (Fm.Term.nat natx))) @(chr:@(chrx:Char) (P (Fm.Term.chr chrx))) @(str:@(strx:String) (P (Fm.Term.str strx))) @(cse:@(path:Bits) @(expr:Fm.Term) @(name:Fm.Name) @(with:(List Fm.Def)) @(cses:(Map Fm.Term)) @(moti:Fm.Term) (P ((((((Fm.Term.cse path) expr) name) with) cses) moti))) (P Fm.Term.Self);
Fm.Synth.one : @(name:Fm.Name) @(defs:Fm.Defs) Fm.Defs = #name #defs ((((((Fm.get Fm.Def) name) defs) #got Fm.Defs) defs) #got.value ((got.value #got.value Fm.Defs) #got.value.name #got.value.term #got.value.type #got.value.stat !name = got.value.name; !term = got.value.term; !type = got.value.type; !stat = got.value.stat; (((((stat #stat Fm.Defs) !defs = ((((Fm.set Fm.Def) name) ((((Fm.Def.new name) term) type) Fm.Status.wait)) defs); !checked = ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Unit) (((((Fm.Term.check type) ((Maybe.some Fm.Term) Fm.Term.typ)) defs) (List.nil ((Pair Fm.Name) Fm.Term))) (Fm.MPath.1 Fm.MPath.nil))) #chk_type ((((((Monad.bind Fm.Check) Fm.Check.monad) Fm.Term) Unit) (((((Fm.Term.check term) ((Maybe.some Fm.Term) type)) defs) (List.nil ((Pair Fm.Name) Fm.Term))) (Fm.MPath.0 Fm.MPath.nil))) #chk_term ((((Monad.pure Fm.Check) Fm.Check.monad) Unit) Unit.new))); ((checked #checked Fm.Defs) #checked.value #checked.errors (((((List.is_empty Fm.Error) checked.errors) # (Map Fm.Def)) !defs = ((((Fm.set Fm.Def) name) ((((Fm.Def.new name) term) type) Fm.Status.done)) defs); defs) !fixed = ((((((Fm.Synth.fix name) term) type) defs) checked.errors) Bool.false); (((fixed #fixed (Map Fm.Def)) !stat = (Fm.Status.fail checked.errors); !defs = ((((Fm.set Fm.Def) name) ((((Fm.Def.new name) term) type) stat)) defs); defs) #fixed.value ((Fm.Synth.one name) fixed.value))))) defs) defs) #stat.errors defs)));
Fm.Synth.fix : @(name:Fm.Name) @(term:Fm.Term) @(type:Fm.Term) @(defs:Fm.Defs) @(errs:(List Fm.Error)) @(fixd:Bool) (Maybe Fm.Defs) = #name #term #type #defs #errs #fixd (((errs #errs (Maybe Fm.Defs)) (((fixd # (Maybe Fm.Defs)) !type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) type); !term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) term); !defs = ((((Fm.set Fm.Def) name) ((((Fm.Def.new name) term) type) Fm.Status.init)) defs); ((Maybe.some (Map Fm.Def)) defs)) (Maybe.none Fm.Defs))) #errs.head #errs.tail ((((((((errs.head #errs.head (Maybe Fm.Defs)) #errs.head.expected #errs.head.detected #errs.head.context ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)) #errs.head.name #errs.head.dref #errs.head.verb #errs.head.goal #errs.head.context ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)) #errs.head.name !defs = ((Fm.Synth.one errs.head.name) defs); ((((((Fm.Synth.fix name) term) type) defs) errs.tail) Bool.true)) #errs.head.name ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)) #errs.head.path #errs.head.term ((((errs.head.path #errs.head.path (Maybe Fm.Defs)) (Maybe.none Fm.Defs)) #errs.head.path.pred !term = (((Fm.Term.patch_at errs.head.path.pred) term) #x errs.head.term); ((((((Fm.Synth.fix name) term) type) defs) errs.tail) Bool.true)) #errs.head.path.pred !type = (((Fm.Term.patch_at errs.head.path.pred) type) #x errs.head.term); ((((((Fm.Synth.fix name) term) type) defs) errs.tail) Bool.true))) #errs.head.name ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)) #errs.head.term #errs.head.context ((((((Fm.Synth.fix name) term) type) defs) errs.tail) fixd)));
Fm.Synth.all : @(defs:Fm.Defs) Fm.Defs = #defs !defs = (((((List.for Fm.Def) ((Map.values Fm.Def) defs)) Fm.Defs) defs) #def #defs ((def #def Fm.Defs) #def.name #def.term #def.type #def.stat !name = def.name; !term = def.term; !type = def.type; !stat = def.stat; ((Fm.Synth.one name) defs))); defs;
Fm.Status.wait : Fm.Status = #P #init #wait #done #fail wait;
Fm.Status.init : Fm.Status = #P #init #wait #done #fail init;
Fm.Status.fail : @(errors:(List Fm.Error)) Fm.Status = #errors #P #init #wait #done #fail (fail errors);
Fm.Status.done : Fm.Status = #P #init #wait #done #fail done;
Fm.Status : * = %Fm.Status.Self(P:@(:Fm.Status) *) @(init:(P Fm.Status.init)) @(wait:(P Fm.Status.wait)) @(done:(P Fm.Status.done)) @(fail:@(errors:(List Fm.Error)) (P (Fm.Status.fail errors))) (P Fm.Status.Self);
Fm.Path.1 : @(path:Fm.Path) Fm.Path = #path #x (path (Bits.1 x));
Fm.Path.0 : @(path:Fm.Path) Fm.Path = #path #x (path (Bits.0 x));
Fm.Path.to_bits : @(path:Fm.Path) Bits = #path (path Bits.nil);
Fm.Path.nil : Fm.Path = #x x;
Fm.Path : * = @(:Bits) Bits;
Fm.Parser.type : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "Type")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) Fm.Term.typ));
Fm.Parser.term : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) ((Parser.first_of Fm.Term) (((List.cons (Parser Fm.Term)) Fm.Parser.type) (((List.cons (Parser Fm.Term)) Fm.Parser.forall) (((List.cons (Parser Fm.Term)) Fm.Parser.lambda) (((List.cons (Parser Fm.Term)) Fm.Parser.parenthesis) (((List.cons (Parser Fm.Term)) Fm.Parser.letforin) (((List.cons (Parser Fm.Term)) Fm.Parser.let) (((List.cons (Parser Fm.Term)) Fm.Parser.def) (((List.cons (Parser Fm.Term)) Fm.Parser.if) (((List.cons (Parser Fm.Term)) Fm.Parser.char) (((List.cons (Parser Fm.Term)) Fm.Parser.string) (((List.cons (Parser Fm.Term)) Fm.Parser.pair) (((List.cons (Parser Fm.Term)) Fm.Parser.list) (((List.cons (Parser Fm.Term)) Fm.Parser.forin) (((List.cons (Parser Fm.Term)) Fm.Parser.do) (((List.cons (Parser Fm.Term)) Fm.Parser.case) (((List.cons (Parser Fm.Term)) Fm.Parser.goal) (((List.cons (Parser Fm.Term)) Fm.Parser.hole) (((List.cons (Parser Fm.Term)) Fm.Parser.nat) (((List.cons (Parser Fm.Term)) Fm.Parser.reference) (List.nil (Parser Fm.Term))))))))))))))))))))))) #term (Fm.Parser.suffix term));
Fm.Parser.suffix : @(term:Fm.Term) (Parser Fm.Term) = #term #code !suffix_parser = ((Parser.first_of Fm.Term) (((List.cons (Parser Fm.Term)) (Fm.Parser.application term)) (((List.cons (Parser Fm.Term)) (Fm.Parser.arrow term)) (((List.cons (Parser Fm.Term)) (Fm.Parser.equality term)) (((List.cons (Parser Fm.Term)) (Fm.Parser.annotation term)) (List.nil (Parser Fm.Term))))))); ((((suffix_parser code) #suffix_parsed (Parser.Reply Fm.Term)) #suffix_parsed.code #suffix_parsed.err (((Parser.Reply.value Fm.Term) code) term)) #suffix_parsed.code #suffix_parsed.val ((Fm.Parser.suffix suffix_parsed.val) suffix_parsed.code));
Fm.Parser.string : (Parser Fm.Term) = !quot = ((String.cons '\"') String.nil); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text quot)) # ((((((Monad.bind Parser) Parser.monad) (List Char)) Fm.Term) (((Parser.until Char) (Parser.text quot)) Fm.Parser.char.single)) #chrs ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.text quot)) # !strx = (((((List.fold Char) chrs) String) String.nil) String.cons); ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.str strx)))));
Fm.Parser.spaces_text : @(text:String) (Parser Unit) = #text ((((((Monad.bind Parser) Parser.monad) (List Unit)) Unit) Fm.Parser.spaces) # (Parser.text text));
Fm.Parser.spaces : (Parser (List Unit)) = ((Parser.many Unit) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text " ")) (((List.cons (Parser Unit)) (Parser.text "\u{A}")) (((List.cons (Parser Unit)) ((((((Monad.bind Parser) Parser.monad) Unit) Unit) (Parser.text "//")) # ((((((Monad.bind Parser) Parser.monad) (List Char)) Unit) ((Parser.many Char) (Parser.char_if #chr (Bool.not ((U16.eql chr) '\u{A}'))))) # (Parser.text "\u{A}")))) (List.nil (Parser Unit)))))));
Fm.Parser.reference : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.ref name))));
Fm.Parser.parenthesis : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "(")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #term ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text ")")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) term))));
Fm.Parser.pair : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "{")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #val0 ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ",")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #val1 ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "}")) # !term = (Fm.Term.ref "Pair.new"); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) val0); !term = ((Fm.Term.app term) val1); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))));
Fm.Parser.nat : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Nat) Fm.Term) Parser.nat) #natx ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.nat natx))));
Fm.Parser.name_term : (Parser ((Pair Fm.Name) Fm.Term)) = ((((((Monad.bind Parser) Parser.monad) Fm.Name) ((Pair Fm.Name) Fm.Term)) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) Unit) ((Pair Fm.Name) Fm.Term)) (Fm.Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) ((Pair Fm.Name) Fm.Term)) Fm.Parser.term) #type ((((Monad.pure Parser) Parser.monad) ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) name) type)))));
Fm.Parser.name1 : (Parser Fm.Name) = ((((((Monad.bind Parser) Parser.monad) (List Char)) Fm.Name) ((Parser.many1 Fm.Letter) Fm.Parser.letter)) #chrs ((((Monad.pure Parser) Parser.monad) Fm.Name) (((((List.fold Char) chrs) String) String.nil) String.cons)));
Fm.Parser.name : (Parser Fm.Name) = ((((((Monad.bind Parser) Parser.monad) (List Char)) Fm.Name) ((Parser.many Fm.Letter) Fm.Parser.letter)) #chrs ((((Monad.pure Parser) Parser.monad) Fm.Name) (((((List.fold Char) chrs) String) String.nil) String.cons)));
Fm.Parser.make_lambda : @(names:(List Fm.Name)) @(body:Fm.Term) Fm.Term = #names #body (((names #names Fm.Term) body) #names.head #names.tail ((Fm.Term.lam names.head) #x ((Fm.Parser.make_lambda names.tail) body)));
Fm.Parser.make_forall : @(binds:(List Fm.Binder)) @(body:Fm.Term) Fm.Term = #binds #body (((binds #binds Fm.Term) body) #binds.head #binds.tail ((binds.head #binds.head Fm.Term) #binds.head.eras #binds.head.name #binds.head.term $all_eras = binds.head.eras; $all_self = ""; $all_name = binds.head.name; $all_xtyp = binds.head.term; $all_body = #s #x ((Fm.Parser.make_forall binds.tail) body); (((((Fm.Term.all all_eras) all_self) all_name) all_xtyp) all_body)));
Fm.Parser.list : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "[")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Term)) Fm.Term) ((Parser.many Fm.Term) ((Fm.Parser.item Fm.Term) Fm.Parser.term))) #vals ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "]")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) (((((List.fold Fm.Term) vals) Fm.Term) ((Fm.Term.app (Fm.Term.ref (Fm.Name.read "List.nil"))) (Fm.Term.hol Bits.nil))) #x #xs !term = (Fm.Term.ref (Fm.Name.read "List.cons")); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) x); !term = ((Fm.Term.app term) xs); term)))));
Fm.Parser.letter : (Parser Fm.Letter) = #code (((code #code (Parser.Reply Fm.Letter)) (((Parser.Reply.error Fm.Letter) code) "Unexpected eof.")) #code.head #code.tail ((((Fm.Name.is_letter code.head) # (Parser.Reply Fm.Letter)) (((Parser.Reply.value Char) code.tail) code.head)) (((Parser.Reply.error Fm.Letter) code) "Expected letter.")));
Fm.Parser.letforin : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "let ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "for ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #elem ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "in")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #list ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #loop ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body !term = (Fm.Term.ref "List.for"); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) list); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.ref name)); !lamb = ((Fm.Term.lam elem) #i ((Fm.Term.lam name) #x loop)); !term = ((Fm.Term.app term) lamb); !term = (((Fm.Term.let name) term) #x body); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))))))))));
Fm.Parser.let : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "let ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Fm.Term) ((Parser.maybe Unit) (Fm.Parser.spaces_text ";"))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.let name) expr) #x body)))))))));
Fm.Parser.lambda : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.spaces_text "(")) (((List.cons (Parser Unit)) (Parser.spaces_text "<")) (List.nil (Parser Unit)))))) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Name)) Fm.Term) ((Parser.many1 Fm.Name) ((Fm.Parser.item Fm.Name) Fm.Parser.name1))) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text ")")) (((List.cons (Parser Unit)) (Parser.text ">")) (List.nil (Parser Unit)))))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) ((Fm.Parser.make_lambda name) body))))));
Fm.Parser.item : %(V:*) @(parser:(Parser V)) (Parser V) = #V #parser ((((((Monad.bind Parser) Parser.monad) (List Unit)) V) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) V) V) parser) #value ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) V) ((Parser.maybe Unit) (Fm.Parser.spaces_text ","))) # ((((Monad.pure Parser) Parser.monad) V) value))));
Fm.Parser.if : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "if ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #cond ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "then")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #tcse ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "else")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #fcse !term = cond; !term = ((Fm.Term.app term) ((Fm.Term.lam "") #x (Fm.Term.hol Bits.nil))); !term = ((Fm.Term.app term) tcse); !term = ((Fm.Term.app term) fcse); ((((Monad.pure Parser) Parser.monad) Fm.Term) term)))))));
Fm.Parser.hole : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "_")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.hol Bits.nil)));
Fm.Parser.goal : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "?")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) (List Bits)) Fm.Term) ((Parser.many Bits) ((((((Monad.bind Parser) Parser.monad) Unit) Bits) (Fm.Parser.spaces_text "-")) # ((((((Monad.bind Parser) Parser.monad) Nat) Bits) Parser.nat) #nat !bits = (Bits.reverse (Bits.tail (Bits.reverse (Nat.to_bits nat)))); ((((Monad.pure Parser) Parser.monad) Bits) bits))))) #dref ((((((Monad.bind Parser) Parser.monad) Bool) Fm.Term) ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Bool) ((Parser.maybe Unit) (Parser.text "-"))) #verb ((((Monad.pure Parser) Parser.monad) Bool) ((Maybe.to_bool Unit) verb)))) #verb ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.gol name) dref) verb))))));
Fm.Parser.forin : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "for ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #elem ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "in")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #list ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "with")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #loop !term = (Fm.Term.ref "List.for"); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) list); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.ref name)); !lamb = ((Fm.Term.lam elem) #i ((Fm.Term.lam name) #x loop)); !term = ((Fm.Term.app term) lamb); !term = (((Fm.Term.let name) term) #x (Fm.Term.ref name)); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))))))));
Fm.Parser.forall : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #self ((((((Monad.bind Parser) Parser.monad) (List Fm.Binder)) Fm.Term) Fm.Parser.binder) #bind ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Fm.Term) ((Parser.maybe Unit) (Parser.spaces_text "->"))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body !term = (((((List.fold Fm.Binder) bind) Fm.Term) body) #x #t ((x #x Fm.Term) #x.eras #x.name #x.term (((((Fm.Term.all x.eras) "") x.name) x.term) #s #x t))); ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((((((((((((((term #term Fm.Term) #term.name #term.indx term) #term.name term) term) #term.eras #term.self #term.name #term.xtyp #term.body (((((Fm.Term.all term.eras) self) term.name) term.xtyp) term.body)) #term.name #term.body term) #term.func #term.argm term) #term.name #term.expr #term.body term) #term.name #term.expr #term.body term) #term.done #term.term #term.type term) #term.name #term.dref #term.verb term) #term.path term) #term.natx term) #term.chrx term) #term.strx term) #term.path #term.expr #term.name #term.with #term.cses #term.moti term)))))));
Fm.Parser.file.go : @(defs:Fm.Defs) (Parser Fm.Defs) = #defs ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Def)) Fm.Defs) ((Parser.maybe Fm.Def) Fm.Parser.definition)) #def (((def #def (Parser Fm.Defs)) ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Datatype)) Fm.Defs) ((Parser.maybe Fm.Datatype) Fm.Parser.datatype)) #adt (((adt #adt (Parser Fm.Defs)) ((((Monad.pure Parser) Parser.monad) Fm.Defs) defs)) #adt.value ((adt.value #adt.value (Parser Fm.Defs)) #adt.value.name #adt.value.pars #adt.value.inds #adt.value.ctrs !term = (Fm.Datatype.build_term adt.value); !term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) term); !type = (Fm.Datatype.build_type adt.value); !type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) type); !defs = ((((Fm.set Fm.Def) adt.value.name) ((((Fm.Def.new adt.value.name) term) type) Fm.Status.init)) defs); !defs = (((((List.fold Fm.Constructor) adt.value.ctrs) Fm.Defs) defs) #ctr #defs !typ_name = adt.value.name; !ctr_name = (String.flatten (((List.cons String) typ_name) (((List.cons Fm.Name) (Fm.Name.read ".")) (((List.cons Fm.Name) ((ctr #ctr Fm.Name) #ctr.name #ctr.args #ctr.inds ctr.name)) (List.nil Fm.Name))))); !ctr_term = ((Fm.Constructor.build_term adt.value) ctr); !ctr_term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) ctr_term); !ctr_type = ((Fm.Constructor.build_type adt.value) ctr); !ctr_type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) ctr_type); ((((Fm.set Fm.Def) ctr_name) ((((Fm.Def.new ctr_name) ctr_term) ctr_type) Fm.Status.init)) defs)); (Fm.Parser.file.go defs))))) #def.value ((def.value #def.value (Parser Fm.Defs)) #def.value.name #def.value.term #def.value.type #def.value.stat (Fm.Parser.file.go ((((Fm.set Fm.Def) def.value.name) def.value) defs)))));
Fm.Parser.file : (Parser Fm.Defs) = (Fm.Parser.file.go (Map.new Fm.Def));
Fm.Parser.equality : @(val0:Fm.Term) (Parser Fm.Term) = #val0 ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "==")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #val1 !term = (Fm.Term.ref "Equal"); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) val0); !term = ((Fm.Term.app term) val1); ((((Monad.pure Parser) Parser.monad) Fm.Term) term)));
Fm.Parser.do.statements : @(monad_name:Fm.Name) (Parser Fm.Term) = #monad_name ((Parser.first_of Fm.Term) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "var ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements monad_name)) #body !term = ((Fm.Term.app (Fm.Term.ref "Monad.bind")) (Fm.Term.ref monad_name)); !term = ((Fm.Term.app term) (Fm.Term.ref ((String.concat monad_name) ".monad"))); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) expr); !term = ((Fm.Term.app term) ((Fm.Term.lam name) #x body)); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "let ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements monad_name)) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.let name) expr) #x body)))))))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "return ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # !term = ((Fm.Term.app (Fm.Term.ref "Monad.pure")) (Fm.Term.ref monad_name)); !term = ((Fm.Term.app term) (Fm.Term.ref ((String.concat monad_name) ".monad"))); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) expr); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements monad_name)) #body !term = ((Fm.Term.app (Fm.Term.ref "Monad.bind")) (Fm.Term.ref monad_name)); !term = ((Fm.Term.app term) (Fm.Term.ref ((String.concat monad_name) ".monad"))); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) (Fm.Term.hol Bits.nil)); !term = ((Fm.Term.app term) expr); !term = ((Fm.Term.app term) ((Fm.Term.lam "") #x body)); ((((Monad.pure Parser) Parser.monad) Fm.Term) term))))) (((List.cons (Parser Fm.Term)) ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text ";")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) expr)))) (List.nil (Parser Fm.Term))))))));
Fm.Parser.do : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "do ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "{")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) (Fm.Parser.do.statements name)) #term ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "}")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) term)))))));
Fm.Parser.definition : (Parser Fm.Def) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Def) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Def) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) (List (List Fm.Binder))) Fm.Def) ((Parser.many (List Fm.Binder)) Fm.Parser.binder)) #args !args = ((List.flatten Fm.Binder) args); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #type ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #term !type = ((Fm.Parser.make_forall args) type); !term = ((Fm.Parser.make_lambda ((((List.mapped Fm.Binder) args) Fm.Name) #x ((x #x Fm.Name) #x.eras #x.name #x.term x.name))) term); !type = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.1 x)) type); !term = (((Fm.Term.bind (List.nil ((Pair Fm.Name) Fm.Term))) #x (Bits.0 x)) term); ((((Monad.pure Parser) Parser.monad) Fm.Def) ((((Fm.Def.new name) term) type) Fm.Status.init))))))));
Fm.Parser.def : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "def ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Term) Fm.Parser.name) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) Fm.Term) ((Parser.maybe Unit) (Fm.Parser.spaces_text ";"))) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.def name) expr) #x body)))))))));
Fm.Parser.datatype : (Parser Fm.Datatype) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Datatype) (Fm.Parser.spaces_text "type ")) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Datatype) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Datatype) ((Parser.maybe (List Fm.Binder)) Fm.Parser.binder)) #pars ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Datatype) ((Parser.maybe (List Fm.Binder)) ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.spaces_text "~")) # Fm.Parser.binder))) #inds !pars = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) pars); !inds = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) inds); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Datatype) (Fm.Parser.spaces_text "{")) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Constructor)) Fm.Datatype) ((Parser.many Fm.Constructor) ((Fm.Parser.item Fm.Constructor) (Fm.Parser.constructor name)))) #ctrs ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Datatype) (Fm.Parser.spaces_text "}")) # ((((Monad.pure Parser) Parser.monad) Fm.Datatype) ((((Fm.Datatype.new name) pars) inds) ctrs)))))))));
Fm.Parser.constructor : @(namespace:Fm.Name) (Parser Fm.Constructor) = #namespace ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Constructor) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Constructor) ((Parser.maybe (List Fm.Binder)) Fm.Parser.binder)) #args ((((((Monad.bind Parser) Parser.monad) (Maybe (List Fm.Binder))) Fm.Constructor) ((Parser.maybe (List Fm.Binder)) ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.spaces_text "~")) # Fm.Parser.binder))) #inds !args = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) args); !inds = (((Maybe.default (List Fm.Binder)) (List.nil Fm.Binder)) inds); ((((Monad.pure Parser) Parser.monad) Fm.Constructor) (((Fm.Constructor.new name) args) inds)))));
Fm.Parser.char.single : (Parser Char) = ((Parser.first_of Char) (((List.cons (Parser Char)) ((Parser.first_of Char) ((((List.mapped ((Pair String) Char)) Fm.escapes) (Parser Char)) #esc ((esc #esc (Parser Char)) #esc.fst #esc.snd ((((((Monad.bind Parser) Parser.monad) Unit) Char) (Parser.text esc.fst)) # ((((Monad.pure Parser) Parser.monad) Char) esc.snd)))))) (((List.cons (Parser Char)) Parser.one) (List.nil (Parser Char)))));
Fm.Parser.char : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "\'")) # ((((((Monad.bind Parser) Parser.monad) Char) Fm.Term) Fm.Parser.char.single) #chrx ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.text "\'")) # ((((Monad.pure Parser) Parser.monad) Fm.Term) (Fm.Term.chr chrx)))));
Fm.Parser.case.with : (Parser Fm.Def) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.spaces_text "with")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Def) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) Fm.Def) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #type ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Def) (Fm.Parser.spaces_text "=")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Def) Fm.Parser.term) #term ((((Monad.pure Parser) Parser.monad) Fm.Def) ((((Fm.Def.new name) term) type) Fm.Status.init)))))))));
Fm.Parser.case.case : (Parser ((Pair Fm.Name) Fm.Term)) = ((((((Monad.bind Parser) Parser.monad) (List Unit)) ((Pair Fm.Name) Fm.Term)) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Name) ((Pair Fm.Name) Fm.Term)) Fm.Parser.name1) #name ((((((Monad.bind Parser) Parser.monad) Unit) ((Pair Fm.Name) Fm.Term)) (Fm.Parser.spaces_text ":")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) ((Pair Fm.Name) Fm.Term)) Fm.Parser.term) #term ((((((Monad.bind Parser) Parser.monad) (Maybe Unit)) ((Pair Fm.Name) Fm.Term)) ((Parser.maybe Unit) (Fm.Parser.spaces_text ","))) # ((((Monad.pure Parser) Parser.monad) ((Pair Fm.Name) Fm.Term)) ((((Pair.new Fm.Name) Fm.Term) name) term)))))));
Fm.Parser.case : (Parser Fm.Term) = ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "case ")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Term) Fm.Parser.spaces) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #expr ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Name)) Fm.Term) ((Parser.maybe Fm.Name) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Name) (Fm.Parser.spaces_text "as")) # ((((((Monad.bind Parser) Parser.monad) (List Unit)) Fm.Name) Fm.Parser.spaces) # Fm.Parser.name1)))) #name !name = (((name #name Fm.Name) ((((((((((((((((expr #expr Fm.Name) #expr.name #expr.indx expr.name) #expr.name expr.name) (Fm.Name.read "self")) #expr.eras #expr.self #expr.name #expr.xtyp #expr.body (Fm.Name.read "self")) #expr.name #expr.body (Fm.Name.read "self")) #expr.func #expr.argm (Fm.Name.read "self")) #expr.name #expr.expr #expr.body (Fm.Name.read "self")) #expr.name #expr.expr #expr.body (Fm.Name.read "self")) #expr.done #expr.term #expr.type (Fm.Name.read "self")) #expr.name #expr.dref #expr.verb (Fm.Name.read "self")) #expr.path (Fm.Name.read "self")) #expr.natx (Fm.Name.read "self")) #expr.chrx (Fm.Name.read "self")) #expr.strx (Fm.Name.read "self")) #expr.path #expr.expr #expr.name #expr.with #expr.cses #expr.moti (Fm.Name.read "self"))) #name.value name.value); ((((((Monad.bind Parser) Parser.monad) (List Fm.Def)) Fm.Term) ((Parser.many Fm.Def) Fm.Parser.case.with)) #with ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "{")) # ((((((Monad.bind Parser) Parser.monad) (List ((Pair Fm.Name) Fm.Term))) Fm.Term) ((Parser.many ((Pair Fm.Name) Fm.Term)) Fm.Parser.case.case)) #cses !cses = ((((Map.from_list Fm.Name) Fm.Term) Fm.Name.to_bits) cses); ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "}")) # ((((((Monad.bind Parser) Parser.monad) (Maybe Fm.Term)) Fm.Term) ((Parser.maybe Fm.Term) ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text ":")) # Fm.Parser.term))) #moti !moti = (((moti #moti Fm.Term) (Fm.Term.hol Bits.nil)) #moti.value moti.value); ((((Monad.pure Parser) Parser.monad) Fm.Term) ((((((Fm.Term.cse Bits.nil) expr) name) with) cses) moti)))))))))));
Fm.Parser.binder.homo : @(eras:Bool) (Parser (List Fm.Binder)) = #eras ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.spaces_text (((eras # String) "<") "("))) # ((((((Monad.bind Parser) Parser.monad) (List ((Pair Fm.Name) Fm.Term))) (List Fm.Binder)) ((Parser.many1 ((Pair Fm.Name) Fm.Term)) ((Fm.Parser.item ((Pair Fm.Name) Fm.Term)) Fm.Parser.name_term))) #bind ((((((Monad.bind Parser) Parser.monad) Unit) (List Fm.Binder)) (Fm.Parser.spaces_text (((eras # String) ">") ")"))) # ((((Monad.pure Parser) Parser.monad) (List Fm.Binder)) ((((List.mapped ((Pair Fm.Name) Fm.Term)) bind) Fm.Binder) #pair ((pair #pair Fm.Binder) #pair.fst #pair.snd (((Fm.Binder.new eras) pair.fst) pair.snd)))))));
Fm.Parser.binder : (Parser (List Fm.Binder)) = ((((((Monad.bind Parser) Parser.monad) (List (List Fm.Binder))) (List Fm.Binder)) ((Parser.many1 (List Fm.Binder)) ((Parser.first_of (List Fm.Binder)) (((List.cons (Parser (List Fm.Binder))) (Fm.Parser.binder.homo Bool.true)) (((List.cons (Parser (List Fm.Binder))) (Fm.Parser.binder.homo Bool.false)) (List.nil (Parser (List Fm.Binder)))))))) #lists ((((Monad.pure Parser) Parser.monad) (List Fm.Binder)) ((List.flatten Fm.Binder) lists)));
Fm.Parser.arrow : @(xtyp:Fm.Term) (Parser Fm.Term) = #xtyp ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Parser.spaces_text "->")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #body ((((Monad.pure Parser) Parser.monad) Fm.Term) (((((Fm.Term.all Bool.false) "") "") xtyp) #s #x body))));
Fm.Parser.application : @(func:Fm.Term) (Parser Fm.Term) = #func ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.text "(")) (((List.cons (Parser Unit)) (Parser.text "<")) (List.nil (Parser Unit)))))) # ((((((Monad.bind Parser) Parser.monad) (List Fm.Term)) Fm.Term) ((Parser.many1 Fm.Term) ((Fm.Parser.item Fm.Term) Fm.Parser.term))) #args ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) ((Parser.first_of Unit) (((List.cons (Parser Unit)) (Parser.spaces_text ")")) (((List.cons (Parser Unit)) (Parser.spaces_text ">")) (List.nil (Parser Unit)))))) # ((((Monad.pure Parser) Parser.monad) Fm.Term) (((((List.for Fm.Term) args) Fm.Term) func) #x #f ((Fm.Term.app f) x))))));
Fm.Parser.annotation : @(term:Fm.Term) (Parser Fm.Term) = #term ((((((Monad.bind Parser) Parser.monad) Unit) Fm.Term) (Fm.Parser.spaces_text "::")) # ((((((Monad.bind Parser) Parser.monad) Fm.Term) Fm.Term) Fm.Parser.term) #type ((((Monad.pure Parser) Parser.monad) Fm.Term) (((Fm.Term.ann Bool.false) term) type))));
Fm.Name.to_bits : @(name:Fm.Name) Bits = #name (((name #name Bits) Bits.nil) #name.head #name.tail !chr = name.head; !u16 = ((((((U16.btw 'A') chr) 'Z') # U16) ((U16.sub chr) (Nat.to_u16 +65))) ((((((U16.btw 'a') chr) 'z') # U16) ((U16.sub chr) (Nat.to_u16 +71))) ((((((U16.btw '0') chr) '9') # U16) ((U16.add chr) (Nat.to_u16 +4))) (((((U16.eql '.') chr) # U16) (Nat.to_u16 +62)) (((((U16.eql '_') chr) # U16) (Nat.to_u16 +63)) (Nat.to_u16 +0)))))); !bts = ((u16 #u16 Bits) #u16.value ((Word.to_bits +6) (((Word.trim +16) +6) u16.value))); ((Bits.concat (Bits.reverse bts)) (Fm.Name.to_bits name.tail)));
Fm.Name.show : @(name:Fm.Name) String = #name name;
Fm.Name.read : @(str:String) Fm.Name = #str str;
Fm.Name.is_letter : @(chr:Char) Bool = #chr ((((((U16.btw 'A') chr) 'Z') # Bool) Bool.true) ((((((U16.btw 'a') chr) 'z') # Bool) Bool.true) ((((((U16.btw '0') chr) '9') # Bool) Bool.true) (((((U16.eql '.') chr) # Bool) Bool.true) (((((U16.eql '_') chr) # Bool) Bool.true) Bool.false)))));
Fm.Name.from_bits : @(bits:Bits) Fm.Name = #bits !list = ((Bits.chunks_of +6) bits); !name = (((((List.fold Bits) list) Fm.Name) String.nil) #bts #name !u16 = (U16.new ((Word.from_bits +16) (Bits.reverse bts))); !chr = ((((((U16.btw (Nat.to_u16 +0)) u16) (Nat.to_u16 +25)) # Char) ((U16.add u16) (Nat.to_u16 +65))) ((((((U16.btw (Nat.to_u16 +26)) u16) (Nat.to_u16 +51)) # U16) ((U16.add u16) (Nat.to_u16 +71))) ((((((U16.btw (Nat.to_u16 +52)) u16) (Nat.to_u16 +61)) # U16) ((U16.sub u16) (Nat.to_u16 +4))) (((((U16.eql (Nat.to_u16 +62)) u16) # U16) (Nat.to_u16 +46)) (Nat.to_u16 +95))))); ((String.cons chr) name)); name;
Fm.Name.eql : @(a:Fm.Name) @(b:Fm.Name) Bool = #a #b ((String.eql a) b);
Fm.Name : * = String;
Fm.MPath.1 : @(path:(Maybe Fm.Path)) (Maybe Fm.Path) = #path ((((Maybe.mapped Fm.Path) path) Fm.Path) Fm.Path.1);
Fm.MPath.0 : @(path:(Maybe Fm.Path)) (Maybe Fm.Path) = #path ((((Maybe.mapped Fm.Path) path) Fm.Path) Fm.Path.0);
Fm.MPath.to_bits : @(path:(Maybe Fm.Path)) Bits = #path (((path #path Bits) Bits.nil) #path.value (path.value Bits.nil));
Fm.MPath.nil : (Maybe Fm.Path) = ((Maybe.some Fm.Path) Fm.Path.nil);
Fm.MPath : * = (Maybe Fm.Path);
Fm.Letter : * = Char;
Fm.Error.waiting : @(name:Fm.Name) Fm.Error = #name #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer (waiting name);
Fm.Error.undefined_reference : @(name:Fm.Name) Fm.Error = #name #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer (undefined_reference name);
Fm.Error.type_mismatch : @(expected:((Either String) Fm.Term)) @(detected:((Either String) Fm.Term)) @(context:Fm.Context) Fm.Error = #expected #detected #context #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer (((type_mismatch expected) detected) context);
Fm.Error.show_goal : @(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) @(goal:(Maybe Fm.Term)) @(context:Fm.Context) Fm.Error = #name #dref #verb #goal #context #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer (((((show_goal name) dref) verb) goal) context);
Fm.Error.show : @(error:Fm.Error) @(defs:Fm.Defs) String = #error #defs ((((((((error #error String) #error.expected #error.detected #error.context !expected = (((error.expected #error.expected String) #error.expected.value error.expected.value) #error.expected.value (Fm.Term.show ((Fm.Term.normalize error.expected.value) (Map.new Fm.Def)))); !detected = (((error.detected #error.detected String) #error.detected.value error.detected.value) #error.detected.value (Fm.Term.show ((Fm.Term.normalize error.detected.value) (Map.new Fm.Def)))); !context = (Fm.Context.show error.context); (String.flatten (((List.cons String) "Type mismatch.\u{A}") (((List.cons String) "- Expected: ") (((List.cons String) expected) (((List.cons String) "\u{A}") (((List.cons String) "- Detected: ") (((List.cons String) detected) (((List.cons String) "\u{A}") (((List.cons String) "With context:\u{A}") (((List.cons String) context) (List.nil String)))))))))))) #error.name #error.dref #error.verb #error.goal #error.context !goal_name = (String.flatten (((List.cons String) "Goal ?") (((List.cons String) (Fm.Name.show error.name)) (((List.cons String) ":\u{A}") (List.nil String))))); !with_type = (((error.goal #error.goal String) "") #error.goal.value !goal = (((Fm.Term.expand error.dref) error.goal.value) defs); (String.flatten (((List.cons String) "With type: ") (((List.cons String) (((error.verb # String) ((Fm.Term.show.go goal) ((Maybe.some @(:Bits) Bits) #x x))) (Fm.Term.show goal))) (((List.cons String) "\u{A}") (List.nil String)))))); !with_ctxt = (String.flatten (((List.cons String) "With ctxt:\u{A}") (((List.cons String) (Fm.Context.show error.context)) (List.nil String)))); (String.flatten (((List.cons String) goal_name) (((List.cons String) with_type) (((List.cons String) with_ctxt) (List.nil String)))))) #error.name (String.flatten (((List.cons String) "Waiting for \'") (((List.cons Fm.Name) error.name) (((List.cons String) "\'.") (List.nil String)))))) #error.name (String.flatten (((List.cons String) "Error on dependency \'") (((List.cons Fm.Name) error.name) (((List.cons String) "\'.") (List.nil String)))))) #error.path #error.term (String.flatten (((List.cons String) "Patching: ") (((List.cons String) (Fm.Term.show error.term)) (List.nil String))))) #error.name (String.flatten (((List.cons String) "Undefined reference: ") (((List.cons String) (Fm.Name.show error.name)) (List.nil String))))) #error.term #error.context !term = (Fm.Term.show error.term); !context = (Fm.Context.show error.context); (String.flatten (((List.cons String) "Can\'t infer type of: ") (((List.cons String) term) (((List.cons String) "\u{A}") (((List.cons String) "With ctxt:\u{A}") (((List.cons String) context) (List.nil String))))))));
Fm.Error.patch : @(path:Bits) @(term:Fm.Term) Fm.Error = #path #term #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer ((patch path) term);
Fm.Error.indirect : @(name:Fm.Name) Fm.Error = #name #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer (indirect name);
Fm.Error.cant_infer : @(term:Fm.Term) @(context:Fm.Context) Fm.Error = #term #context #P #type_mismatch #show_goal #waiting #indirect #patch #undefined_reference #cant_infer ((cant_infer term) context);
Fm.Error : * = %Fm.Error.Self(P:@(:Fm.Error) *) @(type_mismatch:@(expected:((Either String) Fm.Term)) @(detected:((Either String) Fm.Term)) @(context:Fm.Context) (P (((Fm.Error.type_mismatch expected) detected) context))) @(show_goal:@(name:Fm.Name) @(dref:(List Bits)) @(verb:Bool) @(goal:(Maybe Fm.Term)) @(context:Fm.Context) (P (((((Fm.Error.show_goal name) dref) verb) goal) context))) @(waiting:@(name:Fm.Name) (P (Fm.Error.waiting name))) @(indirect:@(name:Fm.Name) (P (Fm.Error.indirect name))) @(patch:@(path:Bits) @(term:Fm.Term) (P ((Fm.Error.patch path) term))) @(undefined_reference:@(name:Fm.Name) (P (Fm.Error.undefined_reference name))) @(cant_infer:@(term:Fm.Term) @(context:Fm.Context) (P ((Fm.Error.cant_infer term) context))) (P Fm.Error.Self);
Fm.Def.new : @(name:Fm.Name) @(term:Fm.Term) @(type:Fm.Term) @(stat:Fm.Status) Fm.Def = #name #term #type #stat #P #new ((((new name) term) type) stat);
Fm.Defs.report : @(defs:Fm.Defs) String = #defs !result = ""; !result = (((((List.for Fm.Def) ((Map.values Fm.Def) defs)) String) result) #def #result ((def #def String) #def.name #def.term #def.type #def.stat !name = def.name; !term = def.term; !type = def.type; !stat = def.stat; (((((stat #stat String) result) result) result) #stat.errors (((stat.errors #stat.errors String) result) #stat.errors.head #stat.errors.tail !name_str = (Fm.Name.show name); !type_str = "<error>"; !result = (((((List.for Fm.Error) stat.errors) String) result) #error #result (String.flatten (((List.cons String) result) (((List.cons String) "On ") (((List.cons String) name_str) (((List.cons String) ":\u{A}") (((List.cons String) ((Fm.Error.show error) defs)) (((List.cons String) "\u{A}\u{A}") (List.nil String))))))))); result)))); (((result #result String) "All terms check.") #result.head #result.tail result);
Fm.Defs.read : @(code:String) (Maybe Fm.Defs) = #code ((((Fm.Parser.file code) #parsed (Maybe Fm.Defs)) #parsed.code #parsed.err (Maybe.none Fm.Defs)) #parsed.code #parsed.val ((Maybe.some Fm.Defs) parsed.val));
Fm.Defs.core : @(defs:Fm.Defs) String = #defs !result = ""; !result = (((((List.for Fm.Def) ((Map.values Fm.Def) defs)) String) result) #def #result ((def #def String) #def.name #def.term #def.type #def.stat (((((def.stat #def.stat String) result) result) !name = def.name; !term = (Fm.Term.core def.term); !type = (Fm.Term.core def.type); (String.flatten (((List.cons String) result) (((List.cons Fm.Name) name) (((List.cons String) " : ") (((List.cons String) type) (((List.cons String) " = ") (((List.cons String) term) (((List.cons String) ";\u{A}") (List.nil String)))))))))) #def.stat.errors result))); result;
Fm.Defs : * = (Map Fm.Def);
Fm.Def : * = %Fm.Def.Self(P:@(:Fm.Def) *) @(new:@(name:Fm.Name) @(term:Fm.Term) @(type:Fm.Term) @(stat:Fm.Status) (P ((((Fm.Def.new name) term) type) stat))) (P Fm.Def.Self);
Fm.Datatype.new : @(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) @(ctrs:(List Fm.Constructor)) Fm.Datatype = #name #pars #inds #ctrs #P #new ((((new name) pars) inds) ctrs);
Fm.Datatype.build_type.go : @(type:Fm.Datatype) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) Fm.Term = #type #name #pars #inds (((pars #pars Fm.Term) (((inds #inds Fm.Term) Fm.Term.typ) #inds.head #inds.tail ((inds.head #inds.head Fm.Term) #inds.head.eras #inds.head.name #inds.head.term $ind_eras = inds.head.eras; $ind_name = inds.head.name; $ind_xtyp = inds.head.term; $ind_body = #s #x ((((Fm.Datatype.build_type.go type) name) pars) inds.tail); (((((Fm.Term.all Bool.false) "") ind_name) ind_xtyp) ind_body)))) #pars.head #pars.tail ((pars.head #pars.head Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $par_eras = pars.head.eras; $par_name = pars.head.name; $par_xtyp = pars.head.term; $par_body = #s #x ((((Fm.Datatype.build_type.go type) name) pars.tail) inds); (((((Fm.Term.all Bool.false) "") par_name) par_xtyp) par_body)));
Fm.Datatype.build_type : @(type:Fm.Datatype) Fm.Term = #type ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((((Fm.Datatype.build_type.go type) type.name) type.pars) type.inds));
Fm.Datatype.build_term.motive.go : @(type:Fm.Datatype) @(name:Fm.Name) @(inds:(List Fm.Binder)) Fm.Term = #type #name #inds (((inds #inds Fm.Term) ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs !slf = (Fm.Term.ref name); !slf = (((((List.for Fm.Binder) type.pars) Fm.Term) slf) #var #slf ((Fm.Term.app slf) (Fm.Term.ref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); !slf = (((((List.for Fm.Binder) type.inds) Fm.Term) slf) #var #slf ((Fm.Term.app slf) (Fm.Term.ref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); (((((Fm.Term.all Bool.false) "") "") slf) #s #x Fm.Term.typ))) #inds.head #inds.tail ((inds.head #inds.head Fm.Term) #inds.head.eras #inds.head.name #inds.head.term $ind_eras = inds.head.eras; $ind_name = inds.head.name; $ind_xtyp = inds.head.term; $ind_body = #s #x (((Fm.Datatype.build_term.motive.go type) name) inds.tail); (((((Fm.Term.all ind_eras) "") ind_name) ind_xtyp) ind_body)));
Fm.Datatype.build_term.motive : @(type:Fm.Datatype) Fm.Term = #type ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs (((Fm.Datatype.build_term.motive.go type) type.name) type.inds));
Fm.Datatype.build_term.go : @(type:Fm.Datatype) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) Fm.Term = #type #name #pars #inds (((pars #pars Fm.Term) (((inds #inds Fm.Term) $moti = (Fm.Datatype.build_term.motive type); $body = #s #x (Fm.Datatype.build_term.constructors type); (((((Fm.Term.all Bool.true) ((String.concat name) ".Self")) (Fm.Name.read "P")) moti) body)) #inds.head #inds.tail ((inds.head #inds.head Fm.Term) #inds.head.eras #inds.head.name #inds.head.term $ind_name = inds.head.name; $ind_body = #x ((((Fm.Datatype.build_term.go type) name) pars) inds.tail); ((Fm.Term.lam ind_name) ind_body)))) #pars.head #pars.tail ((pars.head #pars.head Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $par_name = pars.head.name; $par_body = #x ((((Fm.Datatype.build_term.go type) name) pars.tail) inds); ((Fm.Term.lam par_name) par_body)));
Fm.Datatype.build_term.constructor.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(args:(List Fm.Binder)) Fm.Term = #type #ctor #args (((args #args Fm.Term) ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds !ret = (Fm.Term.ref (Fm.Name.read "P")); !ret = (((((List.for Fm.Binder) ctor.inds) Fm.Term) ret) #var #ret ((Fm.Term.app ret) ((var #var Fm.Term) #var.eras #var.name #var.term var.term))); !ctr = (String.flatten (((List.cons String) type.name) (((List.cons Fm.Name) (Fm.Name.read ".")) (((List.cons Fm.Name) ctor.name) (List.nil Fm.Name))))); !slf = (Fm.Term.ref ctr); !slf = (((((List.for Fm.Binder) type.pars) Fm.Term) slf) #var #slf ((Fm.Term.app slf) (Fm.Term.ref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); !slf = (((((List.for Fm.Binder) ctor.args) Fm.Term) slf) #var #slf ((Fm.Term.app slf) (Fm.Term.ref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); ((Fm.Term.app ret) slf)))) #args.head #args.tail ((args.head #args.head Fm.Term) #args.head.eras #args.head.name #args.head.term !eras = args.head.eras; !name = args.head.name; !xtyp = args.head.term; !body = (((Fm.Datatype.build_term.constructor.go type) ctor) args.tail); (((((Fm.Term.all eras) "") name) xtyp) #s #x body)));
Fm.Datatype.build_term.constructors.go : @(type:Fm.Datatype) @(name:Fm.Name) @(ctrs:(List Fm.Constructor)) Fm.Term = #type #name #ctrs (((ctrs #ctrs Fm.Term) ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs !ret = (Fm.Term.ref (Fm.Name.read "P")); !ret = (((((List.for Fm.Binder) type.inds) Fm.Term) ret) #var #ret ((Fm.Term.app ret) (Fm.Term.ref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); ((Fm.Term.app ret) (Fm.Term.ref ((String.concat name) ".Self"))))) #ctrs.head #ctrs.tail ((ctrs.head #ctrs.head Fm.Term) #ctrs.head.name #ctrs.head.args #ctrs.head.inds (((((Fm.Term.all Bool.false) "") ctrs.head.name) ((Fm.Datatype.build_term.constructor type) ctrs.head)) #s #x (((Fm.Datatype.build_term.constructors.go type) name) ctrs.tail))));
Fm.Datatype.build_term.constructors : @(type:Fm.Datatype) Fm.Term = #type ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs (((Fm.Datatype.build_term.constructors.go type) type.name) type.ctrs));
Fm.Datatype.build_term.constructor : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds (((Fm.Datatype.build_term.constructor.go type) ctor) ctor.args));
Fm.Datatype.build_term : @(type:Fm.Datatype) Fm.Term = #type ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((((Fm.Datatype.build_term.go type) type.name) type.pars) type.inds));
Fm.Datatype : * = %Fm.Datatype.Self(P:@(:Fm.Datatype) *) @(new:@(name:Fm.Name) @(pars:(List Fm.Binder)) @(inds:(List Fm.Binder)) @(ctrs:(List Fm.Constructor)) (P ((((Fm.Datatype.new name) pars) inds) ctrs))) (P Fm.Datatype.Self);
Fm.Context.show : @(context:Fm.Context) String = #context (((context #context String) "") #context.head #context.tail ((context.head #context.head String) #context.head.fst #context.head.snd !name = (Fm.Name.show context.head.fst); !type = (Fm.Term.show context.head.snd); !rest = (Fm.Context.show context.tail); (String.flatten (((List.cons String) rest) (((List.cons String) ((((String.is_empty rest) # String) "") "\u{A}")) (((List.cons String) "- ") (((List.cons String) name) (((List.cons String) ": ") (((List.cons String) type) (List.nil String))))))))));
Fm.Context.find : @(name:Fm.Name) @(ctx:Fm.Context) (Maybe Fm.Term) = #name #ctx (((ctx #ctx (Maybe Fm.Term)) (Maybe.none Fm.Term)) #ctx.head #ctx.tail ((ctx.head #ctx.head (Maybe Fm.Term)) #ctx.head.fst #ctx.head.snd (((((Fm.Name.eql name) ctx.head.fst) # (Maybe Fm.Term)) ((Maybe.some Fm.Term) ctx.head.snd)) ((Fm.Context.find name) ctx.tail))));
Fm.Context : * = (List ((Pair Fm.Name) Fm.Term));
Fm.Constructor.new : @(name:Fm.Name) @(args:(List Fm.Binder)) @(inds:(List Fm.Binder)) Fm.Constructor = #name #args #inds #P #new (((new name) args) inds);
Fm.Constructor.build_type.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(args:(List Fm.Binder)) Fm.Term = #type #ctor #name #pars #args (((pars #pars Fm.Term) (((args #args Fm.Term) ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds !type = (Fm.Term.ref name); !type = (((((List.for Fm.Binder) type.pars) Fm.Term) type) #var #type ((Fm.Term.app type) (Fm.Term.ref ((var #var Fm.Name) #var.eras #var.name #var.term var.name)))); !type = (((((List.for Fm.Binder) ctor.inds) Fm.Term) type) #var #type ((Fm.Term.app type) ((var #var Fm.Term) #var.eras #var.name #var.term var.term))); type))) #args.head #args.tail ((args.head #args.head Fm.Term) #args.head.eras #args.head.name #args.head.term $ctr_eras = args.head.eras; $ctr_name = args.head.name; $ctr_xtyp = args.head.term; $ctr_body = #s #x (((((Fm.Constructor.build_type.go type) ctor) name) pars) args.tail); (((((Fm.Term.all ctr_eras) "") ctr_name) ctr_xtyp) ctr_body)))) #pars.head #pars.tail ((pars.head #pars.head Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $pars_eras = pars.head.eras; $pars_name = pars.head.name; $pars_xtyp = pars.head.term; $pars_body = #s #x (((((Fm.Constructor.build_type.go type) ctor) name) pars.tail) args); (((((Fm.Term.all pars_eras) "") pars_name) pars_xtyp) pars_body)));
Fm.Constructor.build_type : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds (((((Fm.Constructor.build_type.go type) ctor) type.name) type.pars) ctor.args)));
Fm.Constructor.build_term.opt.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(ctrs:(List Fm.Constructor)) Fm.Term = #type #ctor #ctrs (((ctrs #ctrs Fm.Term) ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds !ret = (Fm.Term.ref ctor.name); !ret = (((((List.for Fm.Binder) ctor.args) Fm.Term) ret) #arg #ret ((Fm.Term.app ret) (Fm.Term.ref ((arg #arg Fm.Name) #arg.eras #arg.name #arg.term arg.name)))); ret)) #ctrs.head #ctrs.tail ((ctrs.head #ctrs.head Fm.Term) #ctrs.head.name #ctrs.head.args #ctrs.head.inds $name = ctrs.head.name; $body = #x (((Fm.Constructor.build_term.opt.go type) ctor) ctrs.tail); ((Fm.Term.lam name) body)));
Fm.Constructor.build_term.opt : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs (((Fm.Constructor.build_term.opt.go type) ctor) type.ctrs));
Fm.Constructor.build_term.go : @(type:Fm.Datatype) @(ctor:Fm.Constructor) @(name:Fm.Name) @(pars:(List Fm.Binder)) @(args:(List Fm.Binder)) Fm.Term = #type #ctor #name #pars #args (((pars #pars Fm.Term) (((args #args Fm.Term) $lam_name = (Fm.Name.read "P"); $lam_body = #x ((Fm.Constructor.build_term.opt type) ctor); ((Fm.Term.lam lam_name) lam_body)) #args.head #args.tail ((args.head #args.head Fm.Term) #args.head.eras #args.head.name #args.head.term $ctr_name = args.head.name; $ctr_body = #x (((((Fm.Constructor.build_term.go type) ctor) name) pars) args.tail); ((Fm.Term.lam ctr_name) ctr_body)))) #pars.head #pars.tail ((pars.head #pars.head Fm.Term) #pars.head.eras #pars.head.name #pars.head.term $par_name = pars.head.name; $par_body = #x (((((Fm.Constructor.build_term.go type) ctor) name) pars.tail) args); ((Fm.Term.lam par_name) par_body)));
Fm.Constructor.build_term : @(type:Fm.Datatype) @(ctor:Fm.Constructor) Fm.Term = #type #ctor ((type #type Fm.Term) #type.name #type.pars #type.inds #type.ctrs ((ctor #ctor Fm.Term) #ctor.name #ctor.args #ctor.inds (((((Fm.Constructor.build_term.go type) ctor) type.name) type.pars) ctor.args)));
Fm.Constructor : * = %Fm.Constructor.Self(P:@(:Fm.Constructor) *) @(new:@(name:Fm.Name) @(args:(List Fm.Binder)) @(inds:(List Fm.Binder)) (P (((Fm.Constructor.new name) args) inds))) (P Fm.Constructor.Self);
Fm.Check.result : %(V:*) @(value:(Maybe V)) @(errors:(List Fm.Error)) (Fm.Check V) = #V #value #errors #P #result ((result value) errors);
Fm.Check.pure : %(V:*) @(value:V) (Fm.Check V) = #V #value (((Fm.Check.result V) ((Maybe.some V) value)) (List.nil Fm.Error));
Fm.Check.monad : (Monad Fm.Check) = (((Monad.new Fm.Check) Fm.Check.bind) Fm.Check.pure);
Fm.Check.bind : %(A:*) %(B:*) @(a:(Fm.Check A)) @(f:@(:A) (Fm.Check B)) (Fm.Check B) = #A #B #a #f ((a #a (Fm.Check B)) #a.value #a.errors (((a.value #got (Fm.Check B)) (((Fm.Check.result B) (Maybe.none B)) a.errors)) #got.value (((f got.value) #b (Fm.Check B)) #b.value #b.errors (((Fm.Check.result B) b.value) (((List.concat Fm.Error) a.errors) b.errors)))));
Fm.Check : @(V:*) * = #V %Fm.Check.Self(P:@(:(Fm.Check V)) *) @(result:@(value:(Maybe V)) @(errors:(List Fm.Error)) (P (((Fm.Check.result V) value) errors))) (P Fm.Check.Self);
Fm.Binder.new : @(eras:Bool) @(name:Fm.Name) @(term:Fm.Term) Fm.Binder = #eras #name #term #P #new (((new eras) name) term);
Fm.Binder : * = %Fm.Binder.Self(P:@(:Fm.Binder) *) @(new:@(eras:Bool) @(name:Fm.Name) @(term:Fm.Term) (P (((Fm.Binder.new eras) name) term))) (P Fm.Binder.Self);
Either.right : %(A:*) %(B:*) @(value:B) ((Either A) B) = #A #B #value #P #left #right (right value);
Either.left : %(A:*) %(B:*) @(value:A) ((Either A) B) = #A #B #value #P #left #right (left value);
Either : @(A:*) @(B:*) * = #A #B %Either.Self(P:@(:((Either A) B)) *) @(left:@(value:A) (P (((Either.left A) B) value))) @(right:@(value:B) (P (((Either.right A) B) value))) (P Either.Self);
Cmp.ltn : Cmp = #P #ltn #eql #gtn ltn;
Cmp.gtn : Cmp = #P #ltn #eql #gtn gtn;
Cmp.eql : Cmp = #P #ltn #eql #gtn eql;
Cmp.as_lte : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp Bool) Bool.true) Bool.true) Bool.false);
Cmp.as_gtn : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp Bool) Bool.false) Bool.false) Bool.true);
Cmp.as_gte : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp Bool) Bool.false) Bool.true) Bool.true);
Cmp.as_eql : @(cmp:Cmp) Bool = #cmp ((((cmp #cmp Bool) Bool.false) Bool.true) Bool.false);
Cmp : * = %Cmp.Self(P:@(:Cmp) *) @(ltn:(P Cmp.ltn)) @(eql:(P Cmp.eql)) @(gtn:(P Cmp.gtn)) (P Cmp.Self);
Char : * = U16;
Bool.true : Bool = #P #true #false true;
Bool.or : @(a:Bool) @(b:Bool) Bool = #a #b (((a #a Bool) Bool.true) b);
Bool.not : @(a:Bool) Bool = #a (((a #a Bool) Bool.false) Bool.true);
Bool.false : Bool = #P #true #false false;
Bool.eql : @(a:Bool) @(b:Bool) Bool = #a #b (((a #a Bool) b) (Bool.not b));
Bool.and : @(a:Bool) @(b:Bool) Bool = #a #b (((a #a Bool) b) Bool.false);
Bool : * = %Bool.Self(P:@(:Bool) *) @(true:(P Bool.true)) @(false:(P Bool.false)) (P Bool.Self);
Bits.1 : @(pred:Bits) Bits = #pred #P #nil #0 #1 (1 pred);
Bits.0 : @(pred:Bits) Bits = #pred #P #nil #0 #1 (0 pred);
Bits.to_nat : @(b:Bits) Nat = #b ((((b #b Nat) +0) #b.pred ((Nat.mul +2) (Bits.to_nat b.pred))) #b.pred (Nat.succ ((Nat.mul +2) (Bits.to_nat b.pred))));
Bits.tail : @(a:Bits) Bits = #a ((((a #a Bits) Bits.nil) #a.pred a.pred) #a.pred a.pred);
Bits.reverse.tco : @(a:Bits) @(r:Bits) Bits = #a #r ((((a #a Bits) r) #a.pred ((Bits.reverse.tco a.pred) (Bits.0 r))) #a.pred ((Bits.reverse.tco a.pred) (Bits.1 r)));
Bits.reverse : @(a:Bits) Bits = #a ((Bits.reverse.tco a) Bits.nil);
Bits.nil : Bits = #P #nil #0 #1 nil;
Bits.inc : @(a:Bits) Bits = #a ((((a #a Bits) (Bits.1 Bits.nil)) #a.pred (Bits.1 a.pred)) #a.pred (Bits.0 (Bits.inc a.pred)));
Bits.eql : @(a:Bits) @(b:Bits) Bool = #a #b ((((a #a Bool) ((((b #b Bool) Bool.true) #b.pred Bool.false) #b.pred Bool.false)) #a.pred ((((b #b Bool) Bool.false) #b.pred ((Bits.eql a.pred) b.pred)) #b.pred Bool.false)) #a.pred ((((b #b Bool) Bool.false) #b.pred Bool.false) #b.pred ((Bits.eql a.pred) b.pred)));
Bits.concat : @(a:Bits) @(b:Bits) Bits = #a #b ((((a #a Bits) b) #a.pred (Bits.0 ((Bits.concat a.pred) b))) #a.pred (Bits.1 ((Bits.concat a.pred) b)));
Bits.chunks_of.go : @(len:Nat) @(bits:Bits) @(need:Nat) @(chunk:Bits) (List Bits) = #len #bits #need #chunk ((((bits #bits (List Bits)) (((List.cons Bits) (Bits.reverse chunk)) (List.nil Bits))) #bits.pred (((need #need (List Bits)) !head = (Bits.reverse chunk); !tail = ((((Bits.chunks_of.go len) bits) len) Bits.nil); (((List.cons Bits) head) tail)) #need.pred !chunk = (Bits.0 chunk); ((((Bits.chunks_of.go len) bits.pred) need.pred) chunk))) #bits.pred (((need #need (List Bits)) !head = (Bits.reverse chunk); !tail = ((((Bits.chunks_of.go len) bits) len) Bits.nil); (((List.cons Bits) head) tail)) #need.pred !chunk = (Bits.1 chunk); ((((Bits.chunks_of.go len) bits.pred) need.pred) chunk)));
Bits.chunks_of : @(len:Nat) @(bits:Bits) (List Bits) = #len #bits ((((Bits.chunks_of.go len) bits) len) Bits.nil);
Bits : * = %Bits.Self(P:@(:Bits) *) @(nil:(P Bits.nil)) @(0:@(pred:Bits) (P (Bits.0 pred))) @(1:@(pred:Bits) (P (Bits.1 pred))) (P Bits.Self);
