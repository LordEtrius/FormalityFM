type Parser.Reply <V: Type> {
  error(code: String, err: String),
  value(code: String, val: V),
}

// A parser is a function that receives a string and returns a reply
Parser(V: Type): Type
  String -> Parser.Reply(V)

// Parser monadic binder
Parser.bind<A: Type, B: Type>(parse: Parser(A), next: A -> Parser(B)): Parser(B)
  (code) case parse(code) as reply {
    error: Parser.Reply.error<B>(reply.code, reply.err),
    value: next(reply.val, reply.code),
  }

// Parser monadic injection
Parser.pure<V: Type>(value: V): Parser(V)
  (code) Parser.Reply.value<V>(code, value)

// Perser monad
Parser.monad: Monad(Parser)
  Monad.new<Parser>(Parser.bind, Parser.pure)

// Consumes a specific text, returns the remaining code
Parser.text.go(text: String): Parser(Unit)
  (code) case text {
    nil:
      Parser.Reply.value<Unit>(code, Unit.new),
    cons: case code {
      nil:
        let error = String.flatten(["Expected '", text, "', found end of file."]);
        Parser.Reply.error<Unit>(code, error)
      cons:
        if U16.eql(text.head, code.head) then
          Parser.text(text.tail, code.tail)
        else
          let error = String.flatten(["Expected '", text, "', found '", String.cons(code.head, String.nil), "'."]);
          Parser.Reply.error<Unit>(code, error)
    }
  }

Parser.text(text: String): Parser(Unit)
  (code) case Parser.text.go(text, code) as reply {
    error: Parser.Reply.error<Unit>(code, reply.err),
    value: Parser.Reply.value<Unit>(reply.code, reply.val),
  }

Parser.one: Parser(Char)
  (code) case code {
    nil: Parser.Reply.error<Char>(code, "Unexpected end of file."),
    cons: Parser.Reply.value<Char>(code.tail, code.head),
  }
  
Parser.if_not<A: Type>(a: Parser(Unit), b: Parser(A)): Parser(A)
  (code) case a(code) {
    error: b(code),
    value: Parser.Reply.error<A>(code, "Prevented."),
  }

// Repeats a parse until it fails, returns a list of results
Parser.many<V: Type>(parser: Parser(V)): Parser(List(V))
  Parser.many.go<V>(parser, (x) x)

Parser.many.go<V: Type>(parse: Parser(V), values: List(V) -> List(V), code: String): Parser.Reply(List(V))
  case parse(code) as reply {
    error: Parser.Reply.value<List(V)>(code, values([])),
    value: Parser.many.go<V>(parse, (xs) values(List.cons<_>(reply.val, xs)), reply.code),
  }

// Same as Parser.many, but parses at least one instance
Parser.many1<V: Type>(parser: Parser(V)): Parser(List(V))
  do Parser {
    var head = parser;
    var tail = Parser.many<V>(parser);
    return List.cons<V>(head, tail);
  }

Parser.until<A: Type>(cond: Parser(Unit), parser: Parser(A)): Parser(List(A))
  Parser.many<_>(Parser.if_not<_>(cond, parser))

// Parses an optional
Parser.maybe<V: Type>(parse: Parser(V)): Parser(Maybe(V))
  (code) case parse(code) as reply {
    error: Parser.Reply.value<Maybe(V)>(code, Maybe.none<V>),
    value: Parser.Reply.value<Maybe(V)>(reply.code, Maybe.some<V>(reply.val)),
  }

// Parses the first in a list
Parser.first_of<A: Type>(pars: List(Parser(A))): Parser(A)
  (code) case pars {
    nil: Parser.Reply.error<_>(code, "No parse."),
    cons:
      let parsed = pars.head(code);
      case parsed {
        error: Parser.first_of<_>(pars.tail, code),
        value: Parser.Reply.value<_>(parsed.code, parsed.val),
      }
  }

// Skips whitespaces
Parser.spaces: Parser(List(Unit))
  Parser.many<_>(Parser.first_of<_>([
    Parser.text(" "),
    Parser.text("\n"),
  ]))

// Parses spaces then a text
Parser.spaces_text(text: String): Parser(Unit)
  do Parser {
    Parser.spaces;
    Parser.text(text);
  }

// Parses a character
Parser.char_if(fun: Char -> Bool): Parser(Char)
  (code) case code {
    nil: Parser.Reply.error<_>(code, "No parse."),
    cons:
      if fun(code.head) then
        Parser.Reply.value<_>(code.tail, code.head)
      else
        Parser.Reply.error<_>(code, "No parse."),
  }

// Parses a digit: [0123456789]
Parser.digit: Parser(Nat)
  (code) case code {
    nil:
      Parser.Reply.error<_>(code, "No parse."),
    cons:
      if      U16.eql(code.head, '0') then Parser.Reply.value<_>(code.tail, 0)
      else if U16.eql(code.head, '1') then Parser.Reply.value<_>(code.tail, 1)
      else if U16.eql(code.head, '2') then Parser.Reply.value<_>(code.tail, 2)
      else if U16.eql(code.head, '3') then Parser.Reply.value<_>(code.tail, 3)
      else if U16.eql(code.head, '4') then Parser.Reply.value<_>(code.tail, 4)
      else if U16.eql(code.head, '5') then Parser.Reply.value<_>(code.tail, 5)
      else if U16.eql(code.head, '6') then Parser.Reply.value<_>(code.tail, 6)
      else if U16.eql(code.head, '7') then Parser.Reply.value<_>(code.tail, 7)
      else if U16.eql(code.head, '8') then Parser.Reply.value<_>(code.tail, 8)
      else if U16.eql(code.head, '9') then Parser.Reply.value<_>(code.tail, 9)
      else Parser.Reply.error<_>(code, "No parse."),
  }

// Parses a natural number: 123
Parser.nat: Parser(Nat)
  do Parser {
    var digits = Parser.many1<Nat>(Parser.digit);
    return Nat.from_base(10, digits);
  }

// Gets the current code
Parser.get_code: Parser(String)
  (code) Parser.Reply.value<_>(code, code)

// Gets the current code
Parser.log_code: Parser(Unit)
  (code) Debug.log<_>(code, (x) Parser.Reply.value<_>(code, Unit.new))

// Parses something
Parser.log(str: String): Parser(Unit)
  (code) Debug.log<_>(str, (x) Parser.Reply.value<_>(code, Unit.new))

