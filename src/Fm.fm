// Types
// =====

// A Formality Letter is a character in: [A-Za-z0-9._]
Fm.Letter: Type
  Char

// A Formality Name is a string of letters
Fm.Name: Type
  String

// A Formality term (high-order)
type Fm.Term {
  // A variable bound by another constructor
  var(
    name: Fm.Name, // the variable name, used for pretty printing
    indx: Nat, // the variable bruijn level, used for equality and binding
  ),
  // A reference to a top-level definition
  ref(
    name: Fm.Name, // the reference name
  ),
  // The type of types
  typ,
  // The self-dependent function type (self-Pi)
  all(
    eras: Bool, // if it is erased at runtime
    self: Fm.Name, // the term name
    name: Fm.Name, // the input name
    xtyp: Fm.Term, // the input type
    body: Fm.Term -> Fm.Term -> Fm.Term, // the returned type
  ),
  // An anonymous function (lambda)
  lam(
    name: Fm.Name, // the input name
    body: Fm.Term -> Fm.Term, // the returned body
  ),
  // A function application
  app(
    func: Fm.Term, // the function
    argm: Fm.Term, // the argument
  ),
  // A local definition
  let(
    name: Fm.Name, // the expression name
    expr: Fm.Term, // the expression value
    body: Fm.Term -> Fm.Term, // the body where name=value
  ),
  // A local alias
  def(
    name: Fm.Name, // the expression name
    expr: Fm.Term, // the expression value
    body: Fm.Term -> Fm.Term, // the body where name=value
  ),
  // An inline annotation
  ann(
    done: Bool, // was this type-checked?
    term: Fm.Term, // the annotated term
    type: Fm.Term, // the annotated type
  ),
  // A hole to show the goal
  gol(
    name: Fm.Name, // the goal's name
    dref: List(Bits), // a list of labels to expand when displaying it
    verb: Bool, // show labels of expandable terms?
  ),
  // A hole to be auto-filled
  hol(
    path: Bits,
  ),
  // A natural number
  nat(
    natx: Nat,
  ),
  // A character
  chr(
    chrx: Char,
  ),
  // A string
  str(
    strx: String,
  ),
  // A case-of expression
  cse(
    path: Bits,
    expr: Fm.Term,
    name: Fm.Name,
    with: List(Fm.Def),
    cses: Map(Fm.Term),
    moti: Fm.Term,
  ),
  // An origin
  ori(
    orig: Fm.Origin,
    expr: Fm.Term,
  )
}

type Fm.Origin {
  new(
    file: String,
    from: Nat,
    upto: Nat,
  )
}

// A primitive type (
type Fm.Prim {
  bool,
  nat,
  u16,
  string,
  data(ctrs: List(Nat)),
  //bits,
}

// A compilable term intermediate format
type Fm.Comp {
  nil,
  var(name: Fm.Name),
  ref(name: Fm.Name),
  lam(name: Fm.Name, body: Fm.Comp),
  app(func: Fm.Comp, argm: Fm.Comp),
  let(name: Fm.Name, expr: Fm.Comp, body: Fm.Comp),
  eli(prim: Fm.Prim, expr: Fm.Comp),
  ins(prim: Fm.Prim, expr: Fm.Comp),
  nat(natx: Nat),
  chr(chrx: Char),
  str(strx: String),
}

// A constructor
type Fm.Constructor {
  new(
    name: Fm.Name,
    args: List(Fm.Binder),
    inds: List(Fm.Binder),
  )
}

// An algebraic datatype
type Fm.Datatype {
  new(
    name: Fm.Name,
    pars: List(Fm.Binder),
    inds: List(Fm.Binder),
    ctrs: List(Fm.Constructor),
  )
}

// A type error
type Fm.Error {
  // Two types do not match
  type_mismatch(
    origin: Maybe(Fm.Origin),
    expected: Either(String, Fm.Term),
    detected: Either(String, Fm.Term),
    context: Fm.Context,
  ),
  // Found a goal to be shown
  show_goal(
    name: Fm.Name,
    dref: List(Bits),
    verb: Bool,
    goal: Maybe(Fm.Term),
    context: Fm.Context,
  ),
  // Waits for another term's type checking
  waiting(
    name: Fm.Name,
  ),
  // Error in a dependency
  indirect(
    name: Fm.Name,
  ),
  // Patch the original term
  patch(
    path: Bits,
    term: Fm.Term,
  ),
  // Some reference isn't found
  undefined_reference(
    origin: Maybe(Fm.Origin),
    name: Fm.Name,
  ),
  // A lambda without a type
  cant_infer(
    origin: Maybe(Fm.Origin),
    term: Fm.Term,
    context: Fm.Context,
  ),
}

// The result of a type-checking attempt
type Fm.Check<V: Type> {
  result(
    value: Maybe(V), // the returned value
    errors: List(Fm.Error), // a list of errors
  ),
}

// Status of a type-checking process
type Fm.Status {
  init,
  wait,
  done,
  fail(errors: List(Fm.Error)),
}

// A top-level definition
type Fm.Def {
  new(
    file: String,
    name: Fm.Name,
    term: Fm.Term,
    type: Fm.Term,
    stat: Fm.Status,
  ),
}

type Fm.Binder {
  new(
    eras: Bool,
    name: Fm.Name,
    term: Fm.Term,
  )
}

// A map from Names to definitions
Fm.Defs: Type
  Map(Fm.Def)

// A context is a list of (name, term) pairs
Fm.Context: Type
  List(Pair(Fm.Name,Fm.Term))

// A path
Fm.Path: Type
  Bits -> Bits

// Maybe a path
Fm.MPath: Type
  Maybe(Fm.Path)

// Paths
// =====

Fm.Path.to_bits(path: Fm.Path): Bits
  path(Bits.nil)

Fm.Path.nil: Fm.Path
  (x) x

Fm.Path.0(path: Fm.Path): Fm.Path
  (x) path(Bits.0(x))

Fm.Path.1(path: Fm.Path): Fm.Path
  (x) path(Bits.1(x))

Fm.MPath.to_bits(path: Maybe(Fm.Path)): Bits
  case path {
    none: Bits.nil,
    some: path.value(Bits.nil),
  }

Fm.MPath.nil: Maybe(Fm.Path)
  Maybe.some<_>(Fm.Path.nil)

Fm.MPath.0(path: Maybe(Fm.Path)): Maybe(Fm.Path)
  Maybe.mapped<_>(path)<_>(Fm.Path.0)

Fm.MPath.1(path: Maybe(Fm.Path)): Maybe(Fm.Path)
  Maybe.mapped<_>(path)<_>(Fm.Path.1)

// Contexts
// ========

// Gets a core term from a map by its name
Fm.get<A: Type>(name: Fm.Name, map: Map(A)): Maybe(A)
  Map.get<A>(Fm.Name.to_bits(name), map)

// Adds a name, core term pair to a map
Fm.set<A: Type>(name: Fm.Name, val: A, map: Map(A)): Map(A)
  Map.set<A>(Fm.Name.to_bits(name), val, map)

// Finds a value in a context
Fm.Context.find(name: Fm.Name, ctx: Fm.Context): Maybe(Fm.Term)
  case ctx {
    nil:
      Maybe.none<_>,
    cons:
      case ctx.head {
        new:
          if Fm.Name.eql(name, ctx.head.fst) then
            Maybe.some<_>(ctx.head.snd)
          else
            Fm.Context.find(name, ctx.tail)
      }
  }

// Gets the names of a context
Fm.Context.names(ctx: Fm.Context): List(Fm.Name)
  List.mapped<_>(ctx)<_>((x) Pair.fst<_,_>(x))

// Stringification
// ===============

Fm.Error.origin(error: Fm.Error): Maybe(Fm.Origin)
  case error {
    type_mismatch: error.origin,
    waiting: Maybe.none<_>,
    indirect: Maybe.none<_>,
    show_goal: Maybe.none<_>,
    patch: Maybe.none<_>,
    undefined_reference: error.origin,
    cant_infer: error.origin,
  }

// Stringifies an error
Fm.Error.show(error: Fm.Error, defs: Fm.Defs): String
  case error {
    type_mismatch: 
      let expected = case error.expected {
        left: error.expected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.expected.value, Map.new<_>)),
      };
      let detected = case error.detected {
        left: error.detected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.detected.value, Map.new<_>)),
      };
      String.flatten([
        "Type mismatch.\n",
        "- Expected: ", expected, "\n",
        "- Detected: ", detected, "\n",
        case error.context {
          nil : "",
          cons: String.flatten(["With context:\n", Fm.Context.show(error.context)]),
        },
      ]),
    waiting:
      String.flatten([
        "Waiting for '", error.name, "'."
      ]),
    indirect:
      String.flatten([
        "Error on dependency '", error.name, "'."
      ]),
    show_goal:
      let goal_name = String.flatten(["Goal ?", Fm.Name.show(error.name), ":\n"]);
      let with_type = case error.goal {
        none: "",
        some: 
          let goal = Fm.Term.expand(error.dref, error.goal.value, defs);
          String.flatten([
            "With type: ",
            if error.verb then
              Fm.Term.show.go(goal, Maybe.some<Bits -> Bits>((x) x))
            else
              Fm.Term.show(goal),
            "\n",
          ]),
      };
      let with_ctxt = case error.context {
        nil: "",
        cons: String.flatten([
          "With ctxt:\n",
          Fm.Context.show(error.context),
        ]),
      };
      String.flatten([goal_name, with_type, with_ctxt]),
    patch:
      String.flatten([
        "Patching: ", Fm.Term.show(error.term),
      ]),
    undefined_reference: 
      String.flatten([
        "Undefined reference: ", Fm.Name.show(error.name), "\n",
      ]),
    cant_infer:
      let term = Fm.Term.show(error.term);
      let context = Fm.Context.show(error.context);
      String.flatten([
        "Can't infer type of: ", term, "\n",
        "With ctxt:\n", context,
      ])
  }

// Return the first type error, plus all hole errors.
Fm.Error.relevant(errors: List(Fm.Error), got: Bool): List(Fm.Error)
  case errors {
    nil:
      List.nil<Fm.Error>,
    cons:
      let keep = case errors.head {
        type_mismatch: Bool.not(got),
        show_goal: Bool.true,
        waiting: Bool.false,
        indirect: Bool.false,
        patch: Bool.false,
        undefined_reference: Bool.not(got),
        cant_infer: Bool.not(got),
      };
      let got = case errors.head {
        type_mismatch: Bool.true,
        show_goal: got,
        waiting: got,
        indirect: got,
        patch: got,
        undefined_reference: Bool.true,
        cant_infer: got,
      };
      let tail = Fm.Error.relevant(errors.tail, got);
      if keep then
        List.cons<_>(errors.head, tail)
      else
        tail
  }

// Stringifies a context
Fm.Context.show(context: Fm.Context): String
  case context {
    nil: "",
    cons: case context.head {
      new:
        let name = Fm.Name.show(context.head.fst);
        let type = Fm.Term.show(context.head.snd);
        let rest = Fm.Context.show(context.tail);
        String.flatten([
          rest,
          "- ",
          name,
          ": ",
          type,
          "\n",
        ])
    }
  }

// Attempts to view a term as a Nat literal
Fm.Term.show.as_nat.go(term: Fm.Term): Maybe(Nat)
  case term {
    app: case term.func {
      ref: 
        if String.eql(term.func.name, "Nat.succ") then do Maybe {
          var pred = Fm.Term.show.as_nat.go(term.argm);
          return Nat.succ(pred);
        } else
          Maybe.none<_>,
      _: Maybe.none<_>,
    },
    ref:
      if String.eql(term.name, "Nat.zero") then
        Maybe.some<_>(0)
      else
        Maybe.none<_>,
    _: Maybe.none<_>,
  }

Fm.Term.show.as_nat(term: Fm.Term): Maybe(String)
  Maybe.mapped<_>(Fm.Term.show.as_nat.go(term))<_>(Nat.show)

Fm.color(col: String, str: String): String
  String.cons(Nat.to_u16(27),
  String.cons('[',
  String.concat(col,
  String.cons('m', 
  String.concat(str,
  String.cons(Nat.to_u16(27),
  String.cons('[',
  String.cons('0',
  String.cons('m', 
  String.nil)))))))))

Fm.Term.show.is_ref(term: Fm.Term, name: Fm.Name): Bool
  case term {
    ref: String.eql(name, term.name),
    _: Bool.false,
  }

Fm.Term.show.app(term: Fm.Term, path: Maybe(Bits -> Bits), args: List(String)): String
  case term {
    app:
      let argm = Fm.Term.show.go(term.argm, Fm.MPath.1(path));
      Fm.Term.show.app(term.func, Fm.MPath.0(path), List.cons<_>(argm, args)),
    _:
      let arity = List.length<_>(args);
      if Bool.and(Fm.Term.show.is_ref(term,"Equal"), Nat.eql(arity,3)) then
        let func = Fm.Term.show.go(term, path);
        let eq_lft = Maybe.default<_>("?", List.at<_>(1, args));
        let eq_rgt = Maybe.default<_>("?", List.at<_>(2, args));
        String.flatten([eq_lft, " == ", eq_rgt])
      else
        let func = Fm.Term.show.go(term, path);
        let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')};
        let args = String.join(",", args);
        let func = if wrap then String.flatten(["(",func,")"]) else func;
        String.flatten([func, "(", args, ")"]),
  }

// SHOW: Stringifies a term
Fm.Term.show.go(term: Fm.Term, path: Maybe(Bits -> Bits)): String
  case Fm.Term.show.as_nat(term) as as_nat {
    some: as_nat.value,
    none: case term {
      ref:
        let name = Fm.Name.show(term.name);
        case path {
          none:
            name,
          some: 
            let path_val = Bits.concat(Fm.Path.to_bits(path.value), Bits.1(Bits.nil));
            let path_str = Nat.show(Bits.to_nat(path_val));
            String.flatten([name, Fm.color("2", String.concat("-", path_str))]),
        },
      var:
        Fm.Name.show(term.name),
      typ:
        "Type",
      all:
        let eras = term.eras;
        let self = Fm.Name.show(term.self);
        let name = Fm.Name.show(term.name);
        let type = Fm.Term.show.go(term.xtyp, Fm.MPath.0(path));
        let open = if eras then "<" else "(";
        let clos = if eras then ">" else ")";
        let body = Fm.Term.show.go(
          term.body(
            Fm.Term.var(term.self, 0),
            Fm.Term.var(term.name, 0)),
          Fm.MPath.1(path));
        String.flatten([self,open,name,":",type,clos," ",body]),
      lam:
        let name = Fm.Name.show(term.name);
        let body = Fm.Term.show.go(
          term.body(Fm.Term.var(term.name, 0)),
          Fm.MPath.0(path));
        String.flatten(["(",name,") ",body]),
      app: Fm.Term.show.app(term, path, List.nil<_>),
      let:
        let name = Fm.Name.show(term.name);
        let expr = Fm.Term.show.go(term.expr, Fm.MPath.0(path));
        let body = Fm.Term.show.go(
          term.body(Fm.Term.var(term.name, 0)),
          Fm.MPath.1(path));
        String.flatten(["let ", name, " = ", expr, "; ", body]),
      def:
        let name = Fm.Name.show(term.name);
        let expr = Fm.Term.show.go(term.expr, Fm.MPath.0(path));
        let body = Fm.Term.show.go(
          term.body(Fm.Term.var(term.name, 0)),
          Fm.MPath.1(path));
        String.flatten(["def ", name, " = ", expr, "; ", body]),
      ann:
        let term = Fm.Term.show.go(term.term, Fm.MPath.0(path));
        let type = Fm.Term.show.go(term.type, Fm.MPath.1(path));
        String.flatten([term,"::",type]),
      gol:
        let name = Fm.Name.show(term.name);
        String.flatten(["?", name]),
      hol:
        "_",
      nat:
        String.flatten([Nat.show(term.natx)]),
      chr:
        String.flatten(["'", Fm.escape.char(term.chrx), "'"]),
      str:
        String.flatten(["\"", Fm.escape(term.strx), "\""]),
      cse:
        let expr = Fm.Term.show.go(term.expr, Fm.MPath.0(path));
        let name = Fm.Name.show(term.name);
        let wyth = String.join("", List.mapped<_>(term.with)<_>((defn)
          case defn {
            new:
              let name = Fm.Name.show(defn.name);
              let type = Fm.Term.show.go(defn.type, Maybe.none<_>);
              let term = Fm.Term.show.go(defn.term, Maybe.none<_>);
              String.flatten([name, ": ", type, " = " term, ";"])
          }));
        let cses = Map.to_list<_>(term.cses);
        let cses = String.join("", List.mapped<_>(cses)<_>((x)
          let name = Fm.Name.from_bits(Pair.fst<_,_>(x));
          let term = Fm.Term.show.go(Pair.snd<_,_>(x), Maybe.none<_>);
          String.flatten([name, ": ", term, "; "])));
        let moti = Fm.Term.show.go(term.moti, Maybe.none<_>);
        String.flatten(["case ",expr," as ",name,wyth," { ",cses,"} : ",moti]),
      ori:
        Fm.Term.show.go(term.expr, path),
    }
  }

Fm.Term.show(term: Fm.Term): String
  Fm.Term.show.go(term, Maybe.none<_>)

// Stringifies a defs
Fm.Defs.show(defs: Fm.Defs): String
  let str = "";
  for name_defn in Map.to_list<Fm.Def>(defs) with str:
    case name_defn {
      new: case name_defn.snd as defn {
        new: String.flatten([
          str,
          Fm.Name.show(defn.name),
          ": ",
          Fm.Term.show(defn.type),
          "\n  ",
          Fm.Term.show(defn.term),
          "\n",
        ])
      }
    }

// Reduction
// =========

// BIND: Binds named variables to their lambdas
Fm.Term.bind(vars: Fm.Context, path: Fm.Path, term: Fm.Term): Fm.Term 
  case term {
    ref: case Fm.Context.find(term.name, vars) as got {
      none: Fm.Term.ref(term.name),
      some: got.value,
    },
    var: case List.at_last<_>(term.indx, vars) as got {
      none: Fm.Term.var(term.name, term.indx),
      some: Pair.snd<_,_>(got.value),
    },
    typ: Fm.Term.typ,
    all: 
      let vlen = List.length<_>(vars);
      def xtyp = Fm.Term.bind(vars, Fm.Path.0(path), term.xtyp);
      def body = (s,x) Fm.Term.bind(
        List.cons<_>({term.name,x},
          List.cons<_>({term.self,s},
          vars)),
        Fm.Path.1(path),
        term.body(
          Fm.Term.var(term.self, vlen),
          Fm.Term.var(term.name, Nat.succ(vlen))));
      Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    lam:
      let vlen = List.length<_>(vars);
      def body = (x) Fm.Term.bind(
        List.cons<_>({term.name,x},vars),
        Fm.Path.0(path),
        term.body(Fm.Term.var(term.name, vlen)));
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.bind(vars, Fm.Path.0(path), term.func);
      def argm = Fm.Term.bind(vars, Fm.Path.1(path), term.argm);
      Fm.Term.app(func, argm),
    let:
      let vlen = List.length<_>(vars);
      def expr = Fm.Term.bind(vars, Fm.Path.0(path), term.expr);
      def body = (x) Fm.Term.bind(
        List.cons<_>({term.name,x}, vars),
        Fm.Path.1(path),
        term.body(Fm.Term.var(term.name, vlen)));
      Fm.Term.let(term.name, expr, body),
    def:
      let vlen = List.length<_>(vars);
      def expr = Fm.Term.bind(vars, Fm.Path.0(path), term.expr);
      def body = (x) Fm.Term.bind(
        List.cons<_>({term.name,x}, vars),
        Fm.Path.1(path),
        term.body(Fm.Term.var(term.name, vlen)));
      Fm.Term.def(term.name, expr, body),
    ann:
      def term = Fm.Term.bind(vars, Fm.Path.0(path), term.term);
      def type = Fm.Term.bind(vars, Fm.Path.1(path), term.type);
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(Fm.Path.to_bits(path)),
    nat:
      Fm.Term.nat(term.natx),
    chr:
      Fm.Term.chr(term.chrx),
    str:
      Fm.Term.str(term.strx),
    cse:
      let expr = Fm.Term.bind(vars, Fm.Path.0(path), term.expr);
      let name = term.name; // TODO
      let wyth = term.with; // TODO
      let cses = term.cses; // TODO
      let moti = term.moti; // TODO
      Fm.Term.cse(Fm.Path.to_bits(path), expr, name, wyth, cses, moti),
    ori:
      Fm.Term.ori(term.orig, Fm.Term.bind(vars, path, term.expr)),
  }

// REDUCE: Reduces a high order term to weak head normal form
Fm.Term.reduce(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case term {
    ref: case Fm.get<_>(term.name, defs) as got {
      none: Fm.Term.ref(term.name),
      some: case got.value { new: Fm.Term.reduce(got.value.term, defs) },
    },
    app:
      let func = Fm.Term.reduce(term.func, defs);
      case func {
        lam: Fm.Term.reduce(func.body(term.argm), defs),
        _: term,
      },
    let:
      Fm.Term.reduce(term.body(term.expr), defs),
    def:
      Fm.Term.reduce(term.body(term.expr), defs),
    ann:
      Fm.Term.reduce(term.term, defs),
    nat:
      Fm.Term.reduce(Fm.Term.unroll_nat(term.natx), defs),
    chr:
      Fm.Term.reduce(Fm.Term.unroll_chr(term.chrx), defs),
    str:
      Fm.Term.reduce(Fm.Term.unroll_str(term.strx), defs),
    ori:
      Fm.Term.reduce(term.expr, defs),
    _: term,
  }

// NORMALIZE: Normalizes a high order term
Fm.Term.normalize(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case Fm.Term.reduce(term, defs) as term {
    ref:
      Fm.Term.ref(term.name),
    var:
      Fm.Term.var(term.name, term.indx),
    typ:
      Fm.Term.typ,
    all: 
      def xtyp = Fm.Term.normalize(term.xtyp, defs);
      def body = (s,x) Fm.Term.normalize(term.body(s,x), defs);
      Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Term.normalize(term.body(x), defs);
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.normalize(term.func, defs);
      def argm = Fm.Term.normalize(term.argm, defs);
      Fm.Term.app(func, argm),
    let:
      def expr = Fm.Term.normalize(term.expr, defs);
      def body = (x) Fm.Term.normalize(term.body(x), defs);
      Fm.Term.let(term.name, expr, body),
    def:
      def expr = Fm.Term.normalize(term.expr, defs);
      def body = (x) Fm.Term.normalize(term.body(x), defs);
      Fm.Term.def(term.name, expr, body),
    ann:
      def term = Fm.Term.normalize(term.term, defs);
      def type = Fm.Term.normalize(term.type, defs);
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(term.path),
    nat:
      Fm.Term.nat(term.natx),
    chr:
      Fm.Term.chr(term.chrx),
    str:
      Fm.Term.str(term.strx),
    cse:
      term,
    ori:
      Fm.Term.normalize(term.expr, defs),
  }

//Fm.Term.clean(term: Fm.Term, defs: Fm.Defs): Fm.Term
  //case term {
    //ref:
      //Fm.Term.ref(term.name),
    //var:
      //Fm.Term.var(term.name, term.indx),
    //typ:
      //Fm.Term.typ,
    //all: 
      //def xtyp = Fm.Term.clean(term.xtyp, defs);
      //def body = (s,x) Fm.Term.clean(term.body(s,x), defs);
      //Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    //lam:
      //def body = (x) Fm.Term.clean(term.body(x), defs);
      //Fm.Term.lam(term.name, body),
    //app:
      //def func = Fm.Term.clean(term.func, defs);
      //def argm = Fm.Term.clean(term.argm, defs);
      //Fm.Term.app(func, argm),
    //let:
      //def expr = Fm.Term.clean(term.expr, defs);
      //def body = (x) Fm.Term.clean(term.body(x), defs);
      //Fm.Term.let(term.name, expr, body),
    //def:
      //def expr = Fm.Term.clean(term.expr, defs);
      //def body = (x) Fm.Term.clean(term.body(x), defs);
      //Fm.Term.def(term.name, expr, body),
    //ann:
      //def term = Fm.Term.clean(term.term, defs);
      //def type = Fm.Term.clean(term.type, defs);
      //Fm.Term.ann(term.done, term, type),
    //gol:
      //Fm.Term.gol(term.name, term.dref, term.verb),
    //hol:
      //Fm.Term.hol(term.path),
    //nat:
      //Fm.Term.nat(term.natx),
    //chr:
      //Fm.Term.chr(term.chrx),
    //str:
      //Fm.Term.str(term.strx),
    //cse:
      //term,
    //ori:
      //Fm.Term.clean(term.expr, defs),
  //}

// Patching
// ========

// PATCH_AT Does something at a specific path
Fm.Term.patch_at(path: Bits, term: Fm.Term, fn: Fm.Term -> Fm.Term): Fm.Term
  case term {
    all: case path {
      nil: fn(term),
      0: Fm.Term.all(term.eras, term.self, term.name, Fm.Term.patch_at(path.pred,term.xtyp,fn), term.body),
      1: Fm.Term.all(term.eras, term.self, term.name, term.xtyp, (s,x) Fm.Term.patch_at(path.pred,term.body(s,x),fn)),
    },
    lam: case path {
      nil: fn(term),
      0: Fm.Term.lam(term.name, (x) Fm.Term.patch_at(Bits.tail(path), term.body(x), fn)),
      1: Fm.Term.lam(term.name, (x) Fm.Term.patch_at(Bits.tail(path), term.body(x), fn)),
    },
    app: case path {
      nil: fn(term),
      0: Fm.Term.app(Fm.Term.patch_at(path.pred,term.func,fn), term.argm),
      1: Fm.Term.app(term.func, Fm.Term.patch_at(path.pred,term.argm,fn)),
    },
    let: case path {
      nil: fn(term),
      0: Fm.Term.let(term.name, Fm.Term.patch_at(path.pred,term.expr,fn), term.body),
      1: Fm.Term.let(term.name, term.expr, (x) Fm.Term.patch_at(path.pred,term.body(x),fn)),
    },
    def: case path {
      nil: fn(term),
      0: Fm.Term.def(term.name, Fm.Term.patch_at(path.pred,term.expr,fn), term.body),
      1: Fm.Term.def(term.name, term.expr, (x) Fm.Term.patch_at(path.pred,term.body(x),fn)),
    },
    ann: case path {
      nil: fn(term),
      0: Fm.Term.ann(term.done, Fm.Term.patch_at(path,term.term,fn), term.type),
      1: Fm.Term.ann(term.done, Fm.Term.patch_at(path,term.term,fn), term.type),
    },
    ori: Fm.Term.patch_at(path, term.expr, fn),
    _: case path {
      nil: fn(term),
      0: term,
      1: term,
    },
  }

// Expands the ref at given path
Fm.Term.expand_at(path: Bits, term: Fm.Term, defs: Fm.Defs): Fm.Term
  Fm.Term.patch_at(path, term, (term) case term {
    ref: case Fm.get<_>(term.name, defs) as got {
      none: Fm.Term.ref(term.name),
      some: case got.value { new: got.value.term },
    },
    _: term,
  })

// Expands constructor applications for better pretty printing
Fm.Term.expand_ct(term: Fm.Term, defs: Fm.Defs, arity: Nat): Fm.Term
  case term {
    ref: // TODO: support constructors generally, not hardcodedly
      let expand = Bool.false;
      let expand = Bool.or(Bool.and(String.eql(term.name, "Nat.succ"), Nat.gtn(arity, 1)), expand);
      let expand = Bool.or(Bool.and(String.eql(term.name, "Nat.zero"), Nat.gtn(arity, 0)), expand);
      let expand = Bool.or(Bool.and(String.eql(term.name, "Bool.true"), Nat.gtn(arity, 0)), expand);
      let expand = Bool.or(Bool.and(String.eql(term.name, "Bool.false"), Nat.gtn(arity, 0)), expand);
      if expand then
        case Fm.get<_>(term.name, defs) as got {
          none: Fm.Term.ref(term.name),
          some: case got.value { new: got.value.term },
        }
      else
        Fm.Term.ref(term.name),
    var:
      Fm.Term.var(term.name, term.indx),
    typ:
      Fm.Term.typ,
    all: 
      def xtyp = Fm.Term.expand_ct(term.xtyp, defs, 0);
      def body = (s,x) Fm.Term.expand_ct(term.body(s,x), defs, 0);
      Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Term.expand_ct(term.body(x), defs, 0);
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.expand_ct(term.func, defs, Nat.succ(arity));
      def argm = Fm.Term.expand_ct(term.argm, defs, 0);
      Fm.Term.app(func, argm),
    let:
      def expr = Fm.Term.expand_ct(term.expr, defs, 0);
      def body = (x) Fm.Term.expand_ct(term.body(x), defs, 0);
      Fm.Term.let(term.name, expr, body),
    def:
      def expr = Fm.Term.expand_ct(term.expr, defs, 0);
      def body = (x) Fm.Term.expand_ct(term.body(x), defs, 0);
      Fm.Term.def(term.name, expr, body),
    ann:
      def term = Fm.Term.expand_ct(term.term, defs, 0);
      def type = Fm.Term.expand_ct(term.type, defs, 0);
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(term.path),
    nat:
      Fm.Term.nat(term.natx),
    chr:
      Fm.Term.chr(term.chrx),
    str:
      Fm.Term.str(term.strx),
    cse:
      term,
    ori:
      def expr = Fm.Term.expand_ct(term.expr, defs, 0);
      Fm.Term.ori(term.orig, term.expr),
  }

// Expands a term for pretty printing
Fm.Term.expand(dref: List(Bits), term: Fm.Term, defs: Fm.Defs): Fm.Term
  let term = Fm.Term.normalize(term, Map.new<_>);
  for path in dref with term:
    let term = Fm.Term.expand_at(path, term, defs);
    let term = Fm.Term.normalize(term, Map.new<_>);
    let term = Fm.Term.expand_ct(term, defs, 0);
    let term = Fm.Term.normalize(term, Map.new<_>);
    term

// Equality
// ========

Fm.Term.serialize.name(name: String): Bits
  Fm.Name.to_bits(name)

// Helper function
Fm.Term.serialize(term: Fm.Term, depth: Nat, init: Nat, x: Bits): Bits
  case term {
    ref:
      let name = Bits.concat(Fm.Term.serialize.name(term.name));
      Bits.0(Bits.0(Bits.0(name(x)))),
    var:
      if Nat.gte(term.indx, init) then
        let name = Bits.concat(Nat.to_bits(Nat.pred(Nat.sub(depth,term.indx))));
        Bits.0(Bits.0(Bits.1(name(x))))
      else
        let name = Bits.concat(Nat.to_bits(term.indx));
        Bits.0(Bits.1(Bits.0(name(x)))),
    typ:
      Bits.0(Bits.1(Bits.1(x))),
    all:
      let eras = if term.eras then Bits.1 else Bits.0
      let self = Bits.concat(Fm.Name.to_bits(term.self));
      let xtyp = Fm.Term.serialize(term.xtyp, depth, init);
      let body = Fm.Term.serialize(
        term.body(
          Fm.Term.var(term.self, depth),
          Fm.Term.var(term.name, Nat.succ(depth))),
        Nat.succ(Nat.succ(depth)),
        init);
      Bits.1(Bits.0(Bits.0(eras(self(xtyp(body(x))))))),
    lam:
      let body = Fm.Term.serialize(
        term.body(Fm.Term.var(term.name, depth)),
        Nat.succ(depth),
        init);
      Bits.1(Bits.0(Bits.1(body(x)))),
    app:
      let func = Fm.Term.serialize(term.func, depth, init);
      let argm = Fm.Term.serialize(term.argm, depth, init);
      Bits.1(Bits.1(Bits.0(func(argm(x))))),
    let:
      let expr = Fm.Term.serialize(term.expr, depth, init);
      let body = Fm.Term.serialize(
        term.body(Fm.Term.var(term.name, depth)),
        Nat.succ(depth),
        init);
      Bits.1(Bits.1(Bits.1(expr(body(x))))),
    def:
      Fm.Term.serialize(term.body(term.expr), depth, init, x),
    ann:
      Fm.Term.serialize(term.term, depth, init, x),
    gol:
      let name = Bits.concat(Fm.Name.to_bits(term.name));
      Bits.0(Bits.0(Bits.0(name(x)))),
    hol:
      x,
    nat:
      Fm.Term.serialize(Fm.Term.unroll_nat(term.natx), depth, init, x),
    chr:
      Fm.Term.serialize(Fm.Term.unroll_chr(term.chrx), depth, init, x),
    str:
      Fm.Term.serialize(Fm.Term.unroll_str(term.strx), depth, init, x),
    cse:
      x,
    ori:
      Fm.Term.serialize(term.expr, depth, init, x),
  }

// Helper function
Fm.Term.equal.patch(path: Bits, term: Fm.Term): Fm.Check(Bool)
  Fm.Check.result<_>(Maybe.some<_>(Bool.true), [Fm.Error.patch(path, Fm.Term.normalize(term, Map.new<_>))])

// EQUAL: Determines if two terms are equal
Fm.Term.equal(a: Fm.Term, b: Fm.Term, defs: Fm.Defs, lv: Nat, seen: Set): Fm.Check(Bool)
  let ah = Fm.Term.serialize(a, lv, lv, Bits.nil);
  let bh = Fm.Term.serialize(b, lv, lv, Bits.nil);
  if Bits.eql(ah, bh) then do Fm.Check {
    //let ue = Debug.log<_>(String.flatten([
      //"==", Fm.Term.show(a), "\n",
      //"==", Fm.Term.show(b), "\n",
      //Bits.show(ah), "\n",
      //Bits.show(bh), "\n",
      //"~",
    //]), (x) Unit.new);
    return Bool.true;
  } else do Fm.Check {
    let a1 = Fm.Term.reduce(a, defs);
    let b1 = Fm.Term.reduce(b, defs);
    let ah = Fm.Term.serialize(a1, lv, lv, Bits.nil);
    let bh = Fm.Term.serialize(b1, lv, lv, Bits.nil);
    if Bits.eql(ah, bh) then do Fm.Check {
      return Bool.true;
    } else do Fm.Check {
      let id = Bits.concat(ah, bh);
      if Set.has(id, seen) then do Fm.Check {
        return Bool.true;
      } else case a1 {
        all: case b1 {
          all: do Fm.Check {
            let seen = Set.set(id, seen);
            let a1_body = a1.body(
              Fm.Term.var(a1.self, lv),
              Fm.Term.var(a1.name, Nat.succ(lv)));
            let b1_body = b1.body(
              Fm.Term.var(b1.self, lv),
              Fm.Term.var(b1.name, Nat.succ(lv)));
            let eq_self = String.eql(a1.self, b1.self);
            let eq_eras = Bool.eql(a1.eras, b1.eras);
            if Bool.and(eq_self, eq_eras) then do Fm.Check {
              var eq_type = Fm.Term.equal(a1.xtyp, b1.xtyp, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(Nat.succ(lv)), seen);
              return Bool.and(eq_type, eq_body);
            } else do Fm.Check {
              return Bool.false;
            };
          },
          hol:
            Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
        lam: case b1 {
          lam: do Fm.Check {
              let seen = Set.set(id, seen);
              let a1_body = a1.body(Fm.Term.var(a1.name, lv));
              let b1_body = b1.body(Fm.Term.var(b1.name, lv));
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return eq_body;
            },
            hol: Fm.Term.equal.patch(b1.path, a),
            _: do Fm.Check {
              return Bool.false;
            },
          },
        app: case b1 {
          app: do Fm.Check {
            let seen = Set.set(id, seen);
            var eq_func = Fm.Term.equal(a1.func, b1.func, defs, lv, seen);
            var eq_argm = Fm.Term.equal(a1.argm, b1.argm, defs, lv, seen);
            return Bool.and(eq_func, eq_argm);
          },
          hol: Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
        let: case b1 {
          let: do Fm.Check {
            let seen = Set.set(id, seen);
            let a1_body = a1.body(Fm.Term.var(a1.name, lv));
            let b1_body = b1.body(Fm.Term.var(b1.name, lv));
            var eq_expr = Fm.Term.equal(a1.expr, b1.expr, defs, lv, seen);
            var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
            return Bool.and(eq_expr, eq_body);
          },
          hol:
            Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
        hol:
          Fm.Term.equal.patch(a1.path, b),
        _: case b1 {
          hol: Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      };
    };
  }

// Type Checking
// =============

// Fm.Check monad pure
Fm.Check.pure<V: Type>(value: V): Fm.Check(V)
  Fm.Check.result<V>(Maybe.some<V>(value), [])

// Fm.Check monad bind
Fm.Check.bind<A: Type, B: Type>(a: Fm.Check(A), f: A -> Fm.Check(B)): Fm.Check(B)
  case a {
    result: case a.value as got {
      none: Fm.Check.result<B>(Maybe.none<B>, a.errors),
      some: case f(got.value) as b {
        result: Fm.Check.result<B>(b.value, List.concat<_>(a.errors,b.errors)),
      }
    }
  }

// Fm.Check monad
Fm.Check.monad: Monad(Fm.Check)
  Monad.new<Fm.Check>(Fm.Check.bind, Fm.Check.pure)

// Fm.Check to Maybe
Fm.Check.value<A: Type>(chk: Fm.Check(A)): Maybe(A)
  case chk {
    result: chk.value
  }

// Fm.Check none
Fm.Check.none<A: Type>: Fm.Check(A)
  Fm.Check.result<A>(Maybe.none<A>, [])

// CHECK: Checks the type of a core term
Fm.Term.check(
  term: Fm.Term,
  type: Maybe(Fm.Term),
  defs: Fm.Defs,
  ctx: Fm.Context,
  path: Fm.MPath,
  orig: Maybe(Fm.Origin),
): Fm.Check(Fm.Term)
  do Fm.Check {
    var infr = case term {
      ref: case Fm.get<_>(term.name, defs) as got {
        none: Fm.Check.result<_>(type, [Fm.Error.undefined_reference(orig, term.name)]),
        some: case got.value {
          new:
            let ref_name = got.value.name;
            let ref_type = got.value.type;
            let ref_term = got.value.term;
            let ref_stat = got.value.stat;
            case ref_stat {
              init: Fm.Check.result<_>(Maybe.some<_>(ref_type), [Fm.Error.waiting(ref_name)]),
              wait: Fm.Check.result<_>(Maybe.some<_>(ref_type), []),
              done: Fm.Check.result<_>(Maybe.some<_>(ref_type), []),
              fail: Fm.Check.result<_>(Maybe.some<_>(ref_type), [Fm.Error.indirect(ref_name)]),
            },
        }
      },
      var: case List.at_last<_>(term.indx, ctx) as got {
        none: Fm.Check.result<_>(type, [Fm.Error.undefined_reference(orig, term.name)]),
        some: do Fm.Check { return case got.value { new: got.value.snd }; },
      },
      typ: do Fm.Check {
        return Fm.Term.typ;
      },
      all: do Fm.Check {
        let ctx_size = List.length<_>(ctx);
        let self_var = Fm.Term.var(term.self, ctx_size);
        let body_var = Fm.Term.var(term.name, Nat.succ(ctx_size));
        let body_ctx = List.cons<_>({term.name,term.xtyp}, List.cons<_>({term.self,term}, ctx));
        Fm.Term.check(term.xtyp, Maybe.some<_>(Fm.Term.typ), defs, ctx, Fm.MPath.0(path), orig);
        Fm.Term.check(term.body(self_var,body_var), Maybe.some<_>(Fm.Term.typ), defs, body_ctx, Fm.MPath.1(path), orig);
        return Fm.Term.typ;
      },
      lam: case type {
        none: do Fm.Check {
          Fm.Check.result<_>(type, [Fm.Error.cant_infer(orig, term, ctx)]);
        },
        some: do Fm.Check {
          let typv = Fm.Term.reduce(type.value, defs);
          case typv {
            all: do Fm.Check {
              let ctx_size = List.length<_>(ctx);
              let self_var = term;
              let body_var = Fm.Term.var(term.name, ctx_size);
              let body_typ = typv.body(self_var, body_var);
              let body_ctx = List.cons<_>({term.name,typv.xtyp}, ctx);
              Fm.Term.check(term.body(body_var), Maybe.some<_>(body_typ), defs, body_ctx, Fm.MPath.0(path), orig);
              return type.value;
            },
            _: do Fm.Check {
              let expected = Either.left<_,_>("Function");
              let detected = Either.right<_,_>(type.value);
              Fm.Check.result<_>(type, [Fm.Error.type_mismatch(orig, expected, detected, ctx)]);
            }
          };
        }
      },
      app: do Fm.Check {
        var func_typ = Fm.Term.check(term.func, Maybe.none<_>, defs, ctx, Fm.MPath.0(path), orig);
        let func_typ = Fm.Term.reduce(func_typ, defs);
        case func_typ {
          all: do Fm.Check {
            Fm.Term.check(term.argm, Maybe.some<_>(func_typ.xtyp), defs, ctx, Fm.MPath.1(path), orig);
            return func_typ.body(term.func, term.argm);
          },
          _: do Fm.Check {
            let expected = Either.left<_,_>("Function");
            let detected = Either.right<_,_>(func_typ);
            Fm.Check.result<_>(type, [Fm.Error.type_mismatch(orig, expected, detected, ctx)]);
          },
        };
      },
      ann:
        if term.done then do Fm.Check {
          return term.type;
        } else do Fm.Check {
          Fm.Term.check(term.term, Maybe.some<_>(term.type), defs, ctx, Fm.MPath.0(path), orig);
          Fm.Term.check(term.type, Maybe.some<_>(Fm.Term.typ), defs, ctx, Fm.MPath.1(path), orig);
          return term.type;
        },
      let: do Fm.Check {
        let ctx_size = List.length<_>(ctx);
        var expr_typ = Fm.Term.check(term.expr, Maybe.none<_>, defs, ctx, Fm.MPath.0(path), orig);
        let body_val = term.body(Fm.Term.var(term.name, ctx_size));
        let body_ctx = List.cons<_>({term.name, expr_typ}, ctx);
        var body_typ = Fm.Term.check(body_val, type, defs, body_ctx, Fm.MPath.1(path), orig);
        return body_typ;
      },
      def: do Fm.Check {
        Fm.Term.check(term.body(term.expr), type, defs, ctx, path, orig);
      },
      nat: do Fm.Check {
        return Fm.Term.ref("Nat");
      },
      chr: do Fm.Check {
        return Fm.Term.ref("Char");
      },
      str: do Fm.Check {
        return Fm.Term.ref("String");
      },
      cse: do Fm.Check {
        let expr = term.expr;
        var etyp = Fm.Term.check(expr, Maybe.none<_>, defs, ctx, Fm.MPath.0(path), orig);
        let dsug = Fm.Term.desugar_cse(term.expr, term.name, term.with, term.cses, term.moti, etyp, defs, ctx);
        case dsug {
          none: Fm.Check.result<_>(type, [Fm.Error.cant_infer(orig, term, ctx)]),
          some: Fm.Check.result<_>(type, [Fm.Error.patch(Fm.MPath.to_bits(path),dsug.value)]),
        };
      },
      gol: do Fm.Check {
        Fm.Check.result<_>(type, [
          Fm.Error.show_goal(term.name, term.dref, term.verb, type, ctx)
        ]);
      },
      hol: do Fm.Check {
        Fm.Check.result<_>(type, []);
      },
      ori: do Fm.Check {
        Fm.Term.check(term.expr, type, defs, ctx, path, Maybe.some<_>(term.orig));
      },
    };
    case type {
      none:
        Fm.Check.result<_>(Maybe.some<_>(infr), []),
      some: do Fm.Check {
        var eqls = Fm.Term.equal(type.value, infr, defs, List.length<_>(ctx), Set.new);
        if eqls then do Fm.Check {
          return type.value;
        } else Fm.Check.result<_>(type, [
          Fm.Error.type_mismatch(
            orig,
            Either.right<_,_>(type.value),
            Either.right<_,_>(infr),
            ctx)
        ]);
      }
    };
  }

// SYNTH: Fixes a list of errors, if possible
Fm.Synth.fix(
  file: String,
  name: Fm.Name,
  term: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  errs: List(Fm.Error),
  fixd: Bool,
): Maybe(Fm.Defs)
  case errs {
    nil:
      if fixd then
        let type = Fm.Term.bind([], (x) Bits.1(x), type);
        let term = Fm.Term.bind([], (x) Bits.0(x), term);
        let defs = Fm.set<_>(name, Fm.Def.new(file, name, term, type, Fm.Status.init), defs);
        Maybe.some<_>(defs)
      else
        Maybe.none<_>,
    cons: case errs.head {
      waiting:
        let defs = Fm.Synth.one(errs.head.name, defs);
        Fm.Synth.fix(file, name, term, type, defs, errs.tail, Bool.true),
      patch: 
        case errs.head.path {
          nil: // shouldn't happen
            Maybe.none<_>,
          0: // hole is on term
            let term = Fm.Term.patch_at(errs.head.path.pred, term, (x) errs.head.term);
            Fm.Synth.fix(file, name, term, type, defs, errs.tail, Bool.true),
          1: // hole is on type
            let type = Fm.Term.patch_at(errs.head.path.pred, type, (x) errs.head.term);
            Fm.Synth.fix(file, name, term, type, defs, errs.tail, Bool.true),
        },
      // The error isn't fixable
      _: Fm.Synth.fix(file, name, term, type, defs, errs.tail, fixd),
    }
  }

// Synths one defs
Fm.Synth.one(name: Fm.Name, defs: Fm.Defs): Fm.Defs
  //Debug.log<_>(String.flatten(["synth ",name]), (x) 
  case Fm.get<_>(name, defs) as got {
    none: 
      defs,
    some: case got.value {
      new:
        let file = got.value.file;
        let name = got.value.name;
        let term = got.value.term;
        let type = got.value.type;
        let stat = got.value.stat;
        //Debug.log<_>(String.flatten(["synth ", name, " ", case stat { init: "INIT", wait: "WAIT", done: "DONE", fail: "FAIL" }]), (x)
        case stat {
          init:
            let defs = Fm.set<_>(name, Fm.Def.new(file, name, term, type, Fm.Status.wait), defs);
            let checked = do Fm.Check {
              var chk_type = Fm.Term.check(type, Maybe.some<_>(Fm.Term.typ), defs, [], Fm.MPath.1(Fm.MPath.nil), Maybe.none<_>);
              var chk_term = Fm.Term.check(term, Maybe.some<_>(type), defs, [], Fm.MPath.0(Fm.MPath.nil), Maybe.none<_>);
              return Unit.new;
            };
            case checked {
              result:
                if List.is_empty<_>(checked.errors) then
                  let defs = Fm.set<_>(name, Fm.Def.new(file, name, term, type, Fm.Status.done), defs);
                  //use skip = Debug.log<_>(String.flatten(["done: ", name]))
                  defs
                else
                  let fixed = Fm.Synth.fix(file, name, term, type, defs, checked.errors, Bool.false);
                  case fixed {
                    none:
                      let stat = Fm.Status.fail(checked.errors);
                      let defs = Fm.set<_>(name, Fm.Def.new(file, name, term, type, stat), defs);
                      //use skip = Debug.log<_>(String.flatten(["fail: ", name]))
                      defs,
                    some:
                      //use skip = Debug.log<_>(String.flatten(["cont: ", name]))
                      Fm.Synth.one(name, fixed.value),
                  }
            },
          wait:
            //use skip = Debug.log<_>(String.flatten(["wait ", name]))
            defs,
          done:
            //use skip = Debug.log<_>(String.flatten(["done ", name]))
            defs,
          fail:
            //use skip = Debug.log<_>(String.flatten(["fail ", name]))
            defs,
        }
        //)
    }
  }
  //)

// Synths all defs of specific file
Fm.Synth.file(file: String, defs: Fm.Defs): Fm.Defs
  for defn in Map.values<_>(defs) with defs:
    case defn {
      new: 
        if String.eql(defn.file, file) then
          Fm.Synth.one(defn.name, defs)
        else
          defs
    }

// Synths all defs
Fm.Synth.all(defs: Fm.Defs): Fm.Defs
  for defn in Map.values<_>(defs) with defs:
    case defn {
      new: Fm.Synth.one(defn.name, defs)
    }

Fm.Synth.load.undefs(errors: List(Fm.Error)): List(String)
  case errors {
    nil: List.nil<_>,
    cons:
      let tail = Fm.Synth.load.undefs(errors.tail);
      case errors.head {
        undefined_reference: List.cons<_>(errors.head.name, tail),
        _: tail,
      }
  }

Fm.Synth.file_of(name: Fm.Name): String
  case name {
    nil:
      ".fmfm"
    cons:
      if U16.eql(name.head, '.') then
        ".fmfm"
      else
        String.cons(name.head, Fm.Synth.file_of(name.tail))
  }

//Fm.load.many(names: List(Fm.Name), defs: Fm.Defs): IO(Fm.Defs)
  //case names {
    //nil: do IO {
      //return defs;
    //},
    //cons: do IO {
      //var defs = Fm.load(names.head, defs);
      //Fm.load.many(names.tail, defs);
    //}
  //}

//Fm.load(name: Fm.Name, defs: Fm.Defs): IO(Fm.Defs)
  //let skip = Debug.log<_>(String.flatten(["load_name ", name]), (x) Unit.new);
  //let defs = Fm.Synth.one(name, defs);
  //case Fm.get<_>(name, defs) as got {
    //some: case got.value {
      //new: case got.value.stat {
        //init: do IO { return defs; },
        //wait: do IO { return defs; },
        //done: do IO { return defs; },
        //fail: do IO {
          //let undefs = Fm.load.undefs(got.value.stat.errors);
          //let defs = Fm.load.many(undefs, defs);
          //var defs = Fm.load(name, defs);
          //return defs;
        //}
      //}
    //},
    //none: do IO {
      //let file = Fm.Synth.file_of(name);
      //let skip = Debug.log<_>(String.flatten(["load_file ", file]), (x) Unit.new);
      //var code = IO.get_file(file);
      //case code {
        //nil: do IO {
          //return defs;
        //},
        //cons: do IO {
          //let defs = Fm.Defs.read(file, code, defs);
          //case Fm.get<_>(name, defs) as got {
            //none: do IO {
              //return defs;
            //},
            //some: Fm.load(name, defs)
          //};
        //}
      //};
    //}
  //}

// Sugars
// ======

// Unrolls a natural number
Fm.Term.unroll_nat(natx: Nat): Fm.Term
  case natx {
    zero:
      Fm.Term.ref(Fm.Name.read("Nat.zero")),
    succ:
      let func = Fm.Term.ref(Fm.Name.read("Nat.succ"));
      let argm = Fm.Term.nat(natx.pred);
      Fm.Term.app(func, argm),
  }

// Unrolls a character
Fm.Term.unroll_chr(chrx: Char): Fm.Term
  case chrx {
    new: 
      let term = Fm.Term.ref(Fm.Name.read("Word.from_bits"));
      let term = Fm.Term.app(term, Fm.Term.nat(16));
      let term = Fm.Term.app(term, Fm.Term.unroll_chr.bits(Word.to_bits<16>(chrx.value)));
      let term = Fm.Term.app(Fm.Term.ref(Fm.Name.read("U16.new")), term);
      term
  }

Fm.Term.unroll_chr.bits(bits: Bits): Fm.Term
  case bits {
    nil: Fm.Term.ref(Fm.Name.read("Bits.nil")),
    0: Fm.Term.app(Fm.Term.ref(Fm.Name.read("Bits.0")), Fm.Term.unroll_chr.bits(bits.pred)),
    1: Fm.Term.app(Fm.Term.ref(Fm.Name.read("Bits.1")), Fm.Term.unroll_chr.bits(bits.pred)),
  }

// Unrolls a string
Fm.Term.unroll_str(strx: String): Fm.Term
  case strx {
    nil:
      Fm.Term.ref(Fm.Name.read("String.nil")),
    cons:
      let char = Fm.Term.chr(strx.head);
      let term = Fm.Term.ref(Fm.Name.read("String.cons"));
      let term = Fm.Term.app(term, char);
      let term = Fm.Term.app(term, Fm.Term.str(strx.tail));
      term,
  }

// Desugars the case-of expression (wraps lambdas around arguments)
Fm.Term.desugar_cse(
  expr: Fm.Term,
  name: Fm.Name,
  with: List(Fm.Def),
  cses: Map(Fm.Term),
  moti: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Maybe(Fm.Term)
  case Fm.Term.reduce(type, defs) as type {
    all:
      let moti = Fm.Term.desugar_cse.motive(with, moti);
      let argm = Fm.Term.desugar_cse.argument(name, [], type.xtyp, moti, defs);
      let expr = Fm.Term.app(expr, argm);
      let type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0));
      Maybe.some<_>(Fm.Term.desugar_cse.cases(expr, name, with, cses, type, defs, ctxt)),
    _:
      Maybe.none<_>,
  }

// Desugars the case-of expression (cases)
Fm.Term.desugar_cse.cases(
  expr: Fm.Term,
  name: Fm.Name,
  wyth: List(Fm.Def),
  cses: Map(Fm.Term),
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all: 
      let got = Maybe.or<_>(Fm.get<_>(type.name, cses), Fm.get<_>("_", cses));
      case got {
        some:
          let argm = Fm.Term.desugar_cse.argument(name, wyth, type.xtyp, got.value, defs);
          let expr = Fm.Term.app(expr, argm);
          let type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0));
          Fm.Term.desugar_cse.cases(expr, name, wyth, cses, type, defs, ctxt),
        none: 
          for defn in wyth with expr:
            case defn {
              new: Fm.Term.app(expr, defn.term)
            },
      },
    _:
      for defn in wyth with expr:
        Fm.Term.app(expr, case defn { new: defn.term }),
  }

// Extends a type with motive variables
Fm.Term.desugar_cse.motive(
  wyth: List(Fm.Def),
  moti: Fm.Term,
): Fm.Term
  case wyth {
    cons: case wyth.head {
      new:
        def all_name = wyth.head.name;
        def all_xtyp = wyth.head.type;
        def all_body = (s,x) Fm.Term.desugar_cse.motive(wyth.tail, moti);
        Fm.Term.all(Bool.false, "", all_name, all_xtyp, all_body)
    },
    nil: moti,
  }

// Desugars the case-of expression (wraps lambdas around an argument)
Fm.Term.desugar_cse.argument(
  name: Fm.Name,
  wyth: List(Fm.Def),
  type: Fm.Term,
  body: Fm.Term,
  defs: Fm.Defs,
): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all:
      def type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0));
      def lam_name =
        if String.is_empty(type.name) then
          name
        else
          String.flatten([name, ".", type.name]);
      def lam_body = (x) Fm.Term.desugar_cse.argument(name, wyth, type, body, defs);
      Fm.Term.lam(lam_name, lam_body),
    _: case wyth {
      cons: case wyth.head {
        new:
          def lam_name = wyth.head.name;
          def lam_body = (x) Fm.Term.desugar_cse.argument(name, wyth.tail, type, body, defs);
          Fm.Term.lam(lam_name, lam_body)
      },
      nil: body,
    }
  }

// Builds the type of a datatype
Fm.Datatype.build_type(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_type.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_type.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Fm.Binder),
  inds: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def par_eras = pars.head.eras;
        def par_name = pars.head.name;
        def par_xtyp = pars.head.term;
        def par_body = (s,x) Fm.Datatype.build_type.go(type, name, pars.tail, inds);
        Fm.Term.all(Bool.false, "", par_name, par_xtyp, par_body)
    },
    nil: case inds {
      cons: case inds.head {
        new: 
          def ind_eras = inds.head.eras;
          def ind_name = inds.head.name;
          def ind_xtyp = inds.head.term;
          def ind_body = (s,x) Fm.Datatype.build_type.go(type, name, pars, inds.tail);
          Fm.Term.all(Bool.false, "", ind_name, ind_xtyp, ind_body)
      },
      nil: Fm.Term.typ,
    }
  }

// Builds the term of a datatype (motive)
Fm.Datatype.build_term.motive(
  type: Fm.Datatype,
): Fm.Term
  case type {
    new: Fm.Datatype.build_term.motive.go(type, type.name, type.inds),
  }

Fm.Datatype.build_term.motive.go(
  type: Fm.Datatype,
  name: Fm.Name,
  inds: List(Fm.Binder),
): Fm.Term
  case inds {
    cons: case inds.head {
      new:
        def ind_eras = inds.head.eras;
        def ind_name = inds.head.name;
        def ind_xtyp = inds.head.term;
        def ind_body = (s,x) Fm.Datatype.build_term.motive.go(type, name, inds.tail);
        Fm.Term.all(ind_eras, "", ind_name, ind_xtyp, ind_body),
    },
    nil:
      case type {
        new:
          let slf = Fm.Term.ref(name);
          let slf = for var in type.pars:
            Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }));
          let slf = for var in type.inds:
            Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }));
          Fm.Term.all(Bool.false, "", "", slf, (s,x) Fm.Term.typ)
      }
  }

// Builds the term of a datatype (constructors)
Fm.Datatype.build_term.constructors(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.constructors.go(type, type.name, type.ctrs)
  }

Fm.Datatype.build_term.constructors.go(
  type: Fm.Datatype,
  name: Fm.Name,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new: Fm.Term.all(Bool.false, "",
        ctrs.head.name,
        Fm.Datatype.build_term.constructor(type, ctrs.head),
        (s,x) Fm.Datatype.build_term.constructors.go(type, name, ctrs.tail))
    },
    nil:
      case type {
        new:
          let ret = Fm.Term.ref(Fm.Name.read("P"));
          let ret = for var in type.inds:
            Fm.Term.app(ret, Fm.Term.ref(case var { new: var.name }));
          Fm.Term.app(ret, Fm.Term.ref(String.concat(name,".Self")))
      }
  }

// Builds the term of a datatype (constructor)
Fm.Datatype.build_term.constructor(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case ctor {
    new: Fm.Datatype.build_term.constructor.go(type, ctor, ctor.args),
  }

Fm.Datatype.build_term.constructor.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  args: List(Fm.Binder),
): Fm.Term
  case args {
    cons: case args.head {
      new:
        let eras = args.head.eras;
        let name = args.head.name;
        let xtyp = args.head.term;
        let body = Fm.Datatype.build_term.constructor.go(type, ctor, args.tail);
        Fm.Term.all(eras, "", name, xtyp, (s,x) body)
    },
    nil:
      case type {
        new: case ctor {
          new:
            let ret = Fm.Term.ref(Fm.Name.read("P"));
            let ret = for var in ctor.inds:
              Fm.Term.app(ret, case var { new: var.term });
            let ctr = String.flatten([type.name,Fm.Name.read("."),ctor.name]);
            let slf = Fm.Term.ref(ctr);
            let slf = for var in type.pars:
              Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }));
            let slf = for var in ctor.args:
              Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }));
            Fm.Term.app(ret, slf)
        }
      }
  }
        
// Builds the term of a datatype
Fm.Datatype.build_term(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_term.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Fm.Binder),
  inds: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def par_name = pars.head.name;
        def par_body = (x) Fm.Datatype.build_term.go(type, name, pars.tail, inds);
        Fm.Term.lam(par_name, par_body),
    },
    nil: case inds {
      cons: case inds.head {
        new:
          def ind_name = inds.head.name;
          def ind_body = (x) Fm.Datatype.build_term.go(type, name, pars, inds.tail);
          Fm.Term.lam(ind_name, ind_body),
      },
      nil: 
        def moti = Fm.Datatype.build_term.motive(type);
        def body = (s,x) Fm.Datatype.build_term.constructors(type); // TODO
        Fm.Term.all(Bool.true, String.concat(name,".Self"), Fm.Name.read("P"), moti, body)
    }
  }

Fm.Constructor.build_type(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_type.go(
        type,
        ctor,
        type.name,
        type.pars,
        ctor.args)
    }
  }

Fm.Constructor.build_type.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Fm.Binder),
  args: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def pars_eras = pars.head.eras;
        def pars_name = pars.head.name;
        def pars_xtyp = pars.head.term;
        def pars_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars.tail, args);
        Fm.Term.all(pars_eras, "", pars_name, pars_xtyp, pars_body),
    },
    nil: case args {
      cons: case args.head {
        new:
          def ctr_eras = args.head.eras;
          def ctr_name = args.head.name;
          def ctr_xtyp = args.head.term;
          def ctr_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars, args.tail);
          Fm.Term.all(ctr_eras, "", ctr_name, ctr_xtyp, ctr_body),
      },
      nil: case type {
        new: case ctor {
          new:
            let type = Fm.Term.ref(name);
            let type = for var in type.pars:
              Fm.Term.app(type, Fm.Term.ref(case var { new: var.name }));
            let type = for var in ctor.inds:
              Fm.Term.app(type, case var { new: var.term });
            type,
        }
      }
    }
  }

Fm.Constructor.build_term.opt(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: Fm.Constructor.build_term.opt.go(type, ctor, type.ctrs)
  }

Fm.Constructor.build_term.opt.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new:
        def name = ctrs.head.name;
        def body = (x) Fm.Constructor.build_term.opt.go(type, ctor, ctrs.tail);
        Fm.Term.lam(name, body)
    },
    nil: 
      case ctor {
        new:
          let ret = Fm.Term.ref(ctor.name);
          let ret = for arg in ctor.args:
            Fm.Term.app(ret, Fm.Term.ref(case arg { new: arg.name }));
          ret
      },
  }

Fm.Constructor.build_term(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_term.go(type, ctor, type.name, type.pars, ctor.args)
    }
  }

Fm.Constructor.build_term.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Fm.Binder),
  args: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def par_name = pars.head.name;
        def par_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars.tail, args);
        Fm.Term.lam(par_name, par_body),
    },
    nil: case args {
      cons: case args.head {
        new:
          def ctr_name = args.head.name;
          def ctr_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars, args.tail);
          Fm.Term.lam(ctr_name, ctr_body),
      },
      nil:
        def lam_name = Fm.Name.read("P");
        def lam_body = (x) Fm.Constructor.build_term.opt(type, ctor);
        Fm.Term.lam(lam_name, lam_body),
    }
  }

// Parsing
// =======

// Is this character a valid letter?
Fm.Name.is_letter(chr: Char): Bool
  if      U16.btw('A', chr, 'Z') then Bool.true
  else if U16.btw('a', chr, 'z') then Bool.true
  else if U16.btw('0', chr, '9') then Bool.true
  else if U16.eql('.', chr)      then Bool.true
  else if U16.eql('_', chr)      then Bool.true
  else                                Bool.false

// Converts a String to a Fm.Name
Fm.Name.read(str: String): Fm.Name
  str

// Converts a Fm.Name to a String
Fm.Name.show(name: Fm.Name): String
  name
  
// Converts a name to a bits
Fm.Name.to_bits(name: Fm.Name): Bits
  case name {
    nil:
      Bits.nil,
    cons:
      let chr = name.head;
      let u16 = 
        if      U16.btw('A', chr, 'Z') then U16.sub(chr, Nat.to_u16(65))
        else if U16.btw('a', chr, 'z') then U16.sub(chr, Nat.to_u16(71))
        else if U16.btw('0', chr, '9') then U16.add(chr, Nat.to_u16(4))
        else if U16.eql('.', chr)      then Nat.to_u16(62)
        else if U16.eql('_', chr)      then Nat.to_u16(63)
        else                                Nat.to_u16(0);
      let bts = case u16 { new: Word.to_bits<6>(Word.trim<16>(6, u16.value)) };
      Bits.concat(Bits.reverse(bts), Fm.Name.to_bits(name.tail)),
  }

// Converts a bits to a name
Fm.Name.from_bits(bits: Bits): Fm.Name
  let list = Bits.chunks_of(6, bits);
  let name = List.fold<_>(list)<_>(String.nil, (bts, name)
    let u16 = U16.new(Word.from_bits(16, Bits.reverse(bts)));
    let chr = 
      if      U16.btw( Nat.to_u16(0), u16, Nat.to_u16(25)) then U16.add(u16, Nat.to_u16(65))
      else if U16.btw(Nat.to_u16(26), u16, Nat.to_u16(51)) then U16.add(u16, Nat.to_u16(71))
      else if U16.btw(Nat.to_u16(52), u16, Nat.to_u16(61)) then U16.sub(u16, Nat.to_u16(4))
      else if U16.eql(Nat.to_u16(62), u16)                 then Nat.to_u16(46)
      else                                                      Nat.to_u16(95);
    String.cons(chr, name));
  name

// Are two names the same?
Fm.Name.eql(a: Fm.Name, b: Fm.Name): Bool
  String.eql(a, b)

Fm.backslash: Char
  Nat.to_u16(92)

// String escapable sequences
// TODO: '\\' isn't working, investigate
Fm.escapes: List(Pair(String, Char))
  [
    {"\\b" , '\b'},
    {"\\f" , '\f'},
    {"\\n" , '\n'},
    {"\\r" , '\r'},
    {"\\t" , '\t'},
    {"\\v" , '\v'},
    {String.cons(Fm.backslash, String.cons(Fm.backslash, String.nil)), Fm.backslash},
    {"\\\"", '"'},
    {"\\0" , '\0'},
    {"\\'" , '\''},
  ]

Fm.escape.char(chr: Char): String
  if U16.eql(chr, Fm.backslash) then
    String.cons(Fm.backslash, String.cons(chr, String.nil))
  else if U16.eql(chr, '"') then
    String.cons(Fm.backslash, String.cons(chr, String.nil))
  else if U16.eql(chr, '\'') then
    String.cons(Fm.backslash, String.cons(chr, String.nil))
  else if U16.btw(' ', chr, '~') then
    String.cons(chr, String.nil)
  else
    String.flatten([
      String.cons(Fm.backslash, String.nil),
      "u{", U16.show_hex(chr), "}",
      String.nil,
    ])


Fm.escape(str: String): String
  case str {
    nil:
      String.nil,
    cons:
      let head = Fm.escape.char(str.head);
      let tail = Fm.escape(str.tail);
      String.concat(head, tail)
  }
        
// Spaces and comments
Fm.Parser.spaces: Parser(List(Unit))
  Parser.many<_>(Parser.first_of<_>([
    Parser.text(" "),
    Parser.text("\n"),
    do Parser {
      Parser.text("//");
      Parser.until<_>(Parser.text("\n"), Parser.one);
      return Unit.new;
    }
  ]))

Fm.Parser.init: Parser(Nat)
  do Parser {
    Fm.Parser.spaces;
    var from = Parser.get_index;
    return from;
  }

Fm.Parser.stop(from: Nat): Parser(Fm.Origin)
  do Parser {
    var upto = Parser.get_index;
    let orig = Fm.Origin.new("", from, upto);
    return orig;
  }

// Parses spaces then a text
Fm.Parser.text(text: String): Parser(Unit)
  do Parser {
    Fm.Parser.spaces;
    Parser.text(text);
  }

// Parses a letter: @[a-zA-Z_.]@
Fm.Parser.letter: Parser(Fm.Letter)
  (idx, code) case code {
    nil: Parser.Reply.error<_>(idx, code, "Unexpected eof."),
    cons:
      if Fm.Name.is_letter(code.head) then
        Parser.Reply.value<_>(Nat.succ(idx), code.tail, code.head)
      else
        Parser.Reply.error<_>(idx, code, "Expected letter."),
  }
  
// Parses a (possibly empty) name: @[a-zA-Z_.]*@
Fm.Parser.name: Parser(Fm.Name)
  do Parser {
    Fm.Parser.spaces;
    var chrs = Parser.many<Fm.Letter>(Fm.Parser.letter);
    return List.fold<_>(chrs)<_>(String.nil, String.cons);
  }

// Parses a non-empty name: @[a-zA-Z_.]+@
Fm.Parser.name1: Parser(Fm.Name)
  do Parser {
    Fm.Parser.spaces;
    var chrs = Parser.many1<Fm.Letter>(Fm.Parser.letter);
    return List.fold<_>(chrs)<_>(String.nil, String.cons);
  }

// Parses a type: @Type@
Fm.Parser.type: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("Type");
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.typ);
  }

// Parses a lambda (erased): @<name> body@
Fm.Parser.lambda.erased: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("<");
    var name = Parser.until1<_>(
      Fm.Parser.text(">"),
      Fm.Parser.item<_>(Fm.Parser.name1));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let expr = Fm.Parser.make_lambda(name, body);
    return Fm.Term.ori(orig, expr);
  }

// Parses a lambda: @(name) body@
Fm.Parser.lambda: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("(");
    var name = Parser.until1<_>(
      Fm.Parser.text(")"),
      Fm.Parser.item<_>(Fm.Parser.name1));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let expr = Fm.Parser.make_lambda(name, body);
    return Fm.Term.ori(orig, expr);
  }

// Parses a parenthesis: @(term)@
Fm.Parser.parenthesis: Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("(");
    var term = Fm.Parser.term;
    Fm.Parser.text(")");
    return term;
  }

// Parses a name:term pair
Fm.Parser.name_term: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    var name = Fm.Parser.name;
    Fm.Parser.text(":");
    var type = Fm.Parser.term;
    return {name, type};
  }

// Parses a binding list, @(a: A, b: B, c: C)@
Fm.Parser.binder.homo(eras: Bool): Parser(List(Fm.Binder))
  do Parser {
    Fm.Parser.text(if eras then "<" else "(");
    var bind = Parser.until1<_>(
      Fm.Parser.text(if eras then ">" else ")"),
      Fm.Parser.item<_>(Fm.Parser.name_term));
    return List.mapped<_>(bind)<_>((pair) case pair {
      new: Fm.Binder.new(eras, pair.fst, pair.snd)
    });
  }

// Parses a mixed binding list, @<a: A, b: B>(c: C, d: D)<e: E>@
Fm.Parser.binder: Parser(List(Fm.Binder))
  do Parser {
    var lists = Parser.many1<_>(Parser.first_of<_>([
      Fm.Parser.binder.homo(Bool.true),
      Fm.Parser.binder.homo(Bool.false),
    ]));
    return List.flatten<_>(lists);
  }

// Parses a forall: @self(a: A, b: B, c: C) D@
Fm.Parser.forall: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    var self = Fm.Parser.name;
    var bind = Fm.Parser.binder;
    Parser.maybe<_>(Fm.Parser.text("->"));
    var body = Fm.Parser.term;
    let term = List.fold<_>(bind)<_>(body, (x,t) case x {
      new: Fm.Term.all(x.eras, "", x.name, x.term, (s,x) t)
    });
    var orig = Fm.Parser.stop(init);
    return case term {
      all: Fm.Term.ori(orig, Fm.Term.all(term.eras, self, term.name, term.xtyp, term.body)),
      _: term,
    };
  }

// Parses a let: @let name = expr; body@
Fm.Parser.let: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("let ");
    var name = Fm.Parser.name;
    Fm.Parser.text("=");
    var expr = Fm.Parser.term;
    Parser.maybe<_>(Fm.Parser.text(";"));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.let(name, expr, (x) body));
  }

// Parses a def: @def name = expr; body@
Fm.Parser.def: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("def ");
    var name = Fm.Parser.name;
    Fm.Parser.text("=");
    var expr = Fm.Parser.term;
    Parser.maybe<_>(Fm.Parser.text(";"));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.def(name, expr, (x) body));
  }

// Parses an if-then-else: @if b then t else f@
Fm.Parser.if: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("if ");
    var cond = Fm.Parser.term;
    Fm.Parser.text("then");
    var tcse = Fm.Parser.term;
    Fm.Parser.text("else");
    var fcse = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = cond;
    let term = Fm.Term.app(term, Fm.Term.lam("", (x) Fm.Term.hol(Bits.nil)));
    let term = Fm.Term.app(term, tcse);
    let term = Fm.Term.app(term, fcse);
    return Fm.Term.ori(orig, term);
  }

// Parses a single char
Fm.Parser.char.single: Parser(Char)
  Parser.first_of<_>([
    Parser.first_of<_>(List.mapped<_>(Fm.escapes)<_>((esc) case esc {
      new: do Parser {
        Parser.text(esc.fst);
        return esc.snd;
      }
    })),
    Parser.one,
  ])

// Parses a char literal: @'x'@
Fm.Parser.char: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("'");
    var chrx = Fm.Parser.char.single;
    Parser.text("'");
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.chr(chrx));
  }

// Parses a string literal: @"foo"@
Fm.Parser.string: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    let quot = String.cons('"', String.nil);
    Fm.Parser.text(quot);
    var chrs = Parser.until<_>(Parser.text(quot), Fm.Parser.char.single);
    let strx = List.fold<_>(chrs)<_>(String.nil, String.cons);
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.str(strx));
  }

// Parses a pair literal: @{1, 2}@
Fm.Parser.pair: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("{");
    var val0 = Fm.Parser.term;
    Fm.Parser.text(",");
    var val1 = Fm.Parser.term;
    Fm.Parser.text("}");
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("Pair.new");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
    let term = Fm.Term.app(term, val0);
    let term = Fm.Term.app(term, val1);
    return Fm.Term.ori(orig, term);
  }

// Parses a list literal: @[1, 2, 3]@
Fm.Parser.list: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("[");
    var vals = Parser.until<_>(
      Fm.Parser.text("]"),
      Fm.Parser.item<_>(Fm.Parser.term));
    var orig = Fm.Parser.stop(init);
    return List.fold<_>(vals)<_>(
      Fm.Term.app(Fm.Term.ref(Fm.Name.read("List.nil")), Fm.Term.hol(Bits.nil)),
      (x,xs)
        let term = Fm.Term.ref(Fm.Name.read("List.cons"));
        let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
        let term = Fm.Term.app(term, x);
        let term = Fm.Term.app(term, xs);
        Fm.Term.ori(orig, term));
  }

// Parses a for-in expression
Fm.Parser.forin: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("for ");
    var elem = Fm.Parser.name1;
    Fm.Parser.text("in");
    var list = Fm.Parser.term;
    Fm.Parser.text("with");
    var name = Fm.Parser.name1;
    Fm.Parser.text(":");
    var loop = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("List.for");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
    let term = Fm.Term.app(term, list);
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
    let term = Fm.Term.app(term, Fm.Term.ref(name));
    let lamb = Fm.Term.lam(elem, (i) Fm.Term.lam(name, (x) loop));
    let term = Fm.Term.app(term, lamb);
    let term = Fm.Term.let(name, term, (x) Fm.Term.ref(name));
    return Fm.Term.ori(orig, term);
  }

// Parses a let-for-in expression
Fm.Parser.letforin: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("let ");
    var name = Fm.Parser.name1;
    Fm.Parser.text("=");
    Fm.Parser.text("for ");
    var elem = Fm.Parser.name1;
    Fm.Parser.text("in");
    var list = Fm.Parser.term;
    Fm.Parser.text(":");
    var loop = Fm.Parser.term;
    Fm.Parser.text(";");
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("List.for");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
    let term = Fm.Term.app(term, list);
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
    let term = Fm.Term.app(term, Fm.Term.ref(name));
    let lamb = Fm.Term.lam(elem, (i) Fm.Term.lam(name, (x) loop));
    let term = Fm.Term.app(term, lamb);
    let term = Fm.Term.let(name, term, (x) body);
    return Fm.Term.ori(orig, term);
  }

// Parses statements of the do-notation
Fm.Parser.do.statements(monad_name: Fm.Name): Parser(Fm.Term)
  Parser.first_of<_>([
    // Binding call: @ask x = expr; rest@
    do Parser {
      var init = Fm.Parser.init;
      Fm.Parser.text("var ");
      var name = Fm.Parser.name1;
      Fm.Parser.text("=");
      var expr = Fm.Parser.term;
      Fm.Parser.text(";");
      var body = Fm.Parser.do.statements(monad_name);
      var orig = Fm.Parser.stop(init);
      let term = Fm.Term.app(Fm.Term.ref("Monad.bind"), Fm.Term.ref(monad_name));
      let term = Fm.Term.app(term, Fm.Term.ref(String.concat(monad_name, ".monad")));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
      let term = Fm.Term.app(term, expr);
      let term = Fm.Term.app(term, Fm.Term.lam(name, (x) body));
      return Fm.Term.ori(orig, term);
    },
    // Local definition (let): @let x = expr; rest@
    do Parser {
      var init = Fm.Parser.init;
      Fm.Parser.text("let ");
      var name = Fm.Parser.name1;
      Fm.Parser.text("=");
      var expr = Fm.Parser.term;
      Fm.Parser.text(";");
      var body = Fm.Parser.do.statements(monad_name);
      var orig = Fm.Parser.stop(init);
      return Fm.Term.ori(orig, Fm.Term.let(name, expr, (x) body));
    },
    // Return pure: @return expr;@
    do Parser {
      var init = Fm.Parser.init;
      Fm.Parser.text("return ");
      var expr = Fm.Parser.term;
      Fm.Parser.text(";");
      var orig = Fm.Parser.stop(init);
      let term = Fm.Term.app(Fm.Term.ref("Monad.pure"), Fm.Term.ref(monad_name));
      let term = Fm.Term.app(term, Fm.Term.ref(String.concat(monad_name, ".monad")));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
      let term = Fm.Term.app(term, expr);
      return Fm.Term.ori(orig, term);
    },
    // Non-binding call: @expr; rest@
    do Parser {
      var init = Fm.Parser.init;
      var expr = Fm.Parser.term;
      Fm.Parser.text(";");
      var body = Fm.Parser.do.statements(monad_name);
      var orig = Fm.Parser.stop(init);
      let term = Fm.Term.app(Fm.Term.ref("Monad.bind"), Fm.Term.ref(monad_name));
      let term = Fm.Term.app(term, Fm.Term.ref(String.concat(monad_name, ".monad")));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
      let term = Fm.Term.app(term, expr);
      let term = Fm.Term.app(term, Fm.Term.lam("", (x) body));
      return Fm.Term.ori(orig, term);
    },
    // Return direct: @expr;@
    do Parser {
      var expr = Fm.Parser.term;
      Fm.Parser.text(";");
      return expr;
    },
  ])

// Parses a block of the do-notation
Fm.Parser.do: Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("do ");
    var name = Fm.Parser.name1;
    Fm.Parser.text("{");
    var term = Fm.Parser.do.statements(name);
    Fm.Parser.text("}");
    return term;
  }

// Parses a with statement of a case
Fm.Parser.case.with: Parser(Fm.Def)
  do Parser {
    Fm.Parser.text("with");
    var name = Fm.Parser.name1;
    Fm.Parser.text(":");
    var type = Fm.Parser.term;
    Fm.Parser.text("=");
    var term = Fm.Parser.term;
    return Fm.Def.new("", name, term, type, Fm.Status.init);
  }

// Parses a case statement of a case
Fm.Parser.case.case: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    var name = Fm.Parser.name1;
    Fm.Parser.text(":");
    var term = Fm.Parser.term;
    Parser.maybe<_>(Fm.Parser.text(","));
    return {name, term};
  }

// Parses a case: @case f(x) as k with a:A = X; { zero: x, succ: y } : T@
Fm.Parser.case: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("case ");
    Fm.Parser.spaces;
    var expr = Fm.Parser.term;
    var name = Parser.maybe<_>(do Parser {
      Fm.Parser.text("as");
      Fm.Parser.name1;
    });
    let name = case name {
      none: case Fm.Term.reduce(expr, Map.new<_>) as expr {
        ref: expr.name,
        var: expr.name,
        _: Fm.Name.read("self"),
      },
      some: name.value,
    };
    var with = Parser.many<_>(Fm.Parser.case.with);
    Fm.Parser.text("{");
    var cses = Parser.until<_>(Fm.Parser.text("}"), Fm.Parser.case.case);
    let cses = Map.from_list<_,_>(Fm.Name.to_bits, cses);
    var moti = Parser.maybe<_>(do Parser {
      Fm.Parser.text(":");
      Fm.Parser.term;
    });
    var orig = Fm.Parser.stop(init);
    let moti = case moti { none: Fm.Term.hol(Bits.nil), some: moti.value };
    return Fm.Term.ori(orig, Fm.Term.cse(Bits.nil, expr, name, with, cses, moti));
  }

// Parses a goal: @?name@
Fm.Parser.goal: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("?");
    var name = Fm.Parser.name;
    var dref = Parser.many<_>(do Parser {
      Fm.Parser.text("-");
      var nat = Parser.nat;
      let bits = Bits.reverse(Bits.tail(Bits.reverse(Nat.to_bits(nat))));
      do Parser { return bits; };
    });
    var verb = do Parser {
      var verb = Parser.maybe<_>(Parser.text("-"));
      return Maybe.to_bool<_>(verb);
    };
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.gol(name, dref, verb));
  }

// Parses a hole: @_@
Fm.Parser.hole: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("_");
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.hol(Bits.nil));
  }

// Parses a natural number: @123@
Fm.Parser.nat: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.spaces;
    var natx = Parser.nat;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.nat(natx));
  }

// Parses a reference: @name@
Fm.Parser.reference: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    var name = Fm.Parser.name1;
    if String.eql(name, "case") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "do") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "if") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "then") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "else") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "let") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "def") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else do Parser {
      var orig = Fm.Parser.stop(init);
      return Fm.Term.ori(orig, Fm.Term.ref(name));
    };
  }

// Parses an optional comma after
Fm.Parser.item<V: Type>(parser: Parser(V)): Parser(V)
  do Parser {
    Fm.Parser.spaces;
    var value = parser;
    Parser.maybe<_>(Fm.Parser.text(","));
    return value;
  }

// Parses an application (erased): @func<argm0>@
Fm.Parser.application.erased(init: Nat, func: Fm.Term): Parser(Fm.Term)
  do Parser {
    var init = Parser.get_index;
    Parser.text("<");
    var args = Parser.until1<_>(
      Parser.spaces_text(">"),
      Fm.Parser.item<_>(Fm.Parser.term));
    var orig = Fm.Parser.stop(init);
    let expr = List.for<_>(args)<_>(func, (x,f) Fm.Term.app(f, x));
    return Fm.Term.ori(orig, expr);
  }

// Parses an application: @func<argm0>@
Fm.Parser.application(init: Nat, func: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.text("(");
    var args = Parser.until1<_>(
      Fm.Parser.text(")"),
      Fm.Parser.item<_>(Fm.Parser.term));
    var orig = Fm.Parser.stop(init);
    let expr = List.for<_>(args)<_>(func, (x,f) Fm.Term.app(f, x));
    return Fm.Term.ori(orig, expr);
  }

// Parses an arrow: @A -> B@
Fm.Parser.arrow(init: Nat, xtyp: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("->");
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.all(Bool.false, "", "", xtyp, (s,x) body));
  }

// Parses an equality: @a == b@
Fm.Parser.equality(init: Nat, val0: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("==");
    var val1 = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("Equal");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil));
    let term = Fm.Term.app(term, val0);
    let term = Fm.Term.app(term, val1);
    return Fm.Term.ori(orig, term);
  }

// Parses an annotation: @term :: type@
Fm.Parser.annotation(init: Nat, term: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("::");
    var type = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.ann(Bool.false, term, type));
  }
  
// Parses a core term (prefix phase)
Fm.Parser.term: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    var term = Parser.first_of<_>([
      Fm.Parser.type,
      Fm.Parser.forall,
      Fm.Parser.lambda,
      Fm.Parser.lambda.erased,
      Fm.Parser.parenthesis,
      Fm.Parser.letforin,
      Fm.Parser.let,
      Fm.Parser.def,
      Fm.Parser.if,
      Fm.Parser.char,
      Fm.Parser.string,
      Fm.Parser.pair,
      Fm.Parser.list,
      Fm.Parser.forin,
      Fm.Parser.do,
      Fm.Parser.case,
      Fm.Parser.goal,
      Fm.Parser.hole,
      Fm.Parser.nat,
      Fm.Parser.reference,
    ]);
    Fm.Parser.suffix(init, term);
  }

// Parses a core term (suffix phase)
Fm.Parser.suffix(init: Nat, term: Fm.Term): Parser(Fm.Term)
  (idx, code)
  let suffix_parser = Parser.first_of<_>([
    Fm.Parser.application(init, term),
    Fm.Parser.application.erased(init, term),
    Fm.Parser.arrow(init, term),
    Fm.Parser.equality(init, term),
    Fm.Parser.annotation(init, term),
  ]);
  case suffix_parser(idx, code) as suffix_parsed {
    error: Parser.Reply.value<_>(idx, code, term),
    value: Fm.Parser.suffix(init, suffix_parsed.val, suffix_parsed.idx, suffix_parsed.code),
  }

// Builds a chained forall
Fm.Parser.make_forall(binds: List(Fm.Binder), body: Fm.Term): Fm.Term
  case binds {
    nil: body,
    cons: case binds.head {
      new:
        def all_eras = binds.head.eras;
        def all_self = "";
        def all_name = binds.head.name;
        def all_xtyp = binds.head.term;
        def all_body = (s,x) Fm.Parser.make_forall(binds.tail, body);
        Fm.Term.all(all_eras, all_self, all_name, all_xtyp, all_body),
    }
  }

// Builds a chained lambda
Fm.Parser.make_lambda(names: List(Fm.Name), body: Fm.Term): Fm.Term
  case names {
    nil: body,
    cons: Fm.Term.lam(names.head, (x) Fm.Parser.make_lambda(names.tail, body)),
  }

// Parses a constructor: @foo(a: A, b: B, c: C) ~ (i: I, j: J)@
Fm.Parser.constructor(namespace: Fm.Name): Parser(Fm.Constructor)
  do Parser {
    var name = Fm.Parser.name1;
    var args = Parser.maybe<_>(Fm.Parser.binder);
    var inds = Parser.maybe<_>(do Parser {
      Fm.Parser.text("~");
      Fm.Parser.binder;
    });
    let args = Maybe.default<_>([], args);
    let inds = Maybe.default<_>([], inds);
    return Fm.Constructor.new(name, args, inds);
  }

// Parses a datatype: @type Foo (x: A) ~ (i: I) { ctor0(a: A) ~ (i: I), ... }@
Fm.Parser.datatype: Parser(Fm.Datatype)
  do Parser {
    Fm.Parser.text("type ");
    var name = Fm.Parser.name1; 
    var pars = Parser.maybe<_>(Fm.Parser.binder);
    var inds = Parser.maybe<_>(do Parser {
      Fm.Parser.text("~");
      Fm.Parser.binder;
    });
    let pars = Maybe.default<_>([], pars);
    let inds = Maybe.default<_>([], inds);
    Fm.Parser.text("{");
    var ctrs = Parser.until<_>(
      Fm.Parser.text("}"),
      Fm.Parser.item<_>(Fm.Parser.constructor(name)));
    return Fm.Datatype.new(name, pars, inds, ctrs);
  }

// Parses a definition
Fm.Parser.file.def(file: String, defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    var name = Fm.Parser.name;
    var args = Parser.many<_>(Fm.Parser.binder);
    let args = List.flatten<_>(args);
    Fm.Parser.text(":");
    var type = Fm.Parser.term;
    var term = Fm.Parser.term;
    let type = Fm.Parser.make_forall(args, type);
    let term = Fm.Parser.make_lambda(List.mapped<_>(args)<_>((x) case x { new: x.name }),term);
    let type = Fm.Term.bind([], (x) Bits.1(x), type);
    let term = Fm.Term.bind([], (x) Bits.0(x), term);
    let defs = Fm.set<_>(name, Fm.Def.new(file, name, term, type, Fm.Status.init), defs);
    return defs;
  }

// Parses an ADT
Fm.Parser.file.adt(file: String, defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    var adt = Fm.Parser.datatype;
    case adt {
      new: do Parser {
        let term = Fm.Datatype.build_term(adt);
        let term = Fm.Term.bind([], (x) Bits.1(x), term);
        let type = Fm.Datatype.build_type(adt);
        let type = Fm.Term.bind([], (x) Bits.0(x), type);
        let defs = Fm.set<_>(adt.name, Fm.Def.new(file, adt.name, term, type, Fm.Status.init), defs);
        let defs = List.fold<_>(adt.ctrs)<_>(defs, (ctr, defs)
          let typ_name = adt.name;
          let ctr_name = String.flatten([typ_name, Fm.Name.read("."), case ctr { new: ctr.name }]);
          let ctr_term = Fm.Constructor.build_term(adt, ctr);
          let ctr_term = Fm.Term.bind([], (x) Bits.1(x), ctr_term);
          let ctr_type = Fm.Constructor.build_type(adt, ctr);
          let ctr_type = Fm.Term.bind([], (x) Bits.0(x), ctr_type);
          Fm.set<_>(ctr_name, Fm.Def.new(file, ctr_name, ctr_term, ctr_type, Fm.Status.init), defs));
        return defs;
      }
    };
  }

// Parses the end of a file
Fm.Parser.file.end(file: String, defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    Fm.Parser.spaces;
    Parser.eof;
    return defs;
  }

// Parses many definitions
Fm.Parser.file(file: String, defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    var stop = Parser.is_eof;
    if stop then do Parser {
      return defs;
    } else Parser.first_of<_>([
      do Parser {
        Fm.Parser.text("#");
        var file = Fm.Parser.name1;
        Fm.Parser.file(file, defs);
      },
      do Parser {
        var defs = Parser.first_of<_>([
          Fm.Parser.file.def(file, defs),
          Fm.Parser.file.adt(file, defs),
          Fm.Parser.file.end(file, defs),
        ]);
        Fm.Parser.file(file, defs);
      },
    ]);
  }

// Stringifies a parser error
Fm.highlight.tc(
  code: String,
  ix0: Nat,
  ix1: Nat,
  col: Nat,
  row: Nat,
  lft: Maybe(Nat),
  lin: String,
  res: List(String),
): String
  //use skip = Debug.log<_>(String.flatten([
    //"ix0=", Nat.show(ix0), " ",
    //"ix1=", Nat.show(ix1), " ",
    //"col=", Nat.show(col), " ",
    //"row=", Nat.show(row), " ",
    //"lft=", case lft { none: "-", some: Nat.show(lft.value) }, " ",
    //"len=", Nat.show(String.length(code)), " ",
    //"chr=", Fm.escape.char(case code { nil: '_', cons: code.head }), " ",
    //"res={", String.join("|", List.reverse<_>(res)), "}",
  //]))
  case code {
    nil:
      Fm.highlight.end(col, row, List.reverse<_>(res)),
    cons:
      if U16.eql(code.head, '\n') then
        let stp = Maybe.extract<_>(lft)<_>(Bool.false, Nat.is_zero);
        if stp then
          Fm.highlight.end(col, row, List.reverse<_>(res))
        else
          let spa = 3;
          let siz = Nat.succ(Nat.double(spa));
          let lft = case ix1 {
            zero: case lft {
              none: Maybe.some<_>(spa),
              some: Maybe.some<_>(Nat.pred(lft.value)),
            },
            succ: lft,
          };
          let ix0 = Nat.pred(ix0);
          let ix1 = Nat.pred(ix1);
          let col = 0;
          let row = Nat.succ(row);
          let res = List.take<_>(siz, List.cons<_>(String.reverse(lin), res));
          let lin = String.reverse(String.flatten([
            String.pad_left(4, ' ', Nat.show(row)),
            " | "
          ]));
          Fm.highlight.tc(code.tail, ix0, ix1, col, row, lft, lin, res)
      else
        let chr = String.cons(code.head, String.nil);
        let chr =
          if Bool.and(Nat.is_zero(ix0), Bool.not(Nat.is_zero(ix1))) then
            String.reverse(Fm.color("31", Fm.color("4", chr)))
          else
            chr;
        let ix0 = Nat.pred(ix0);
        let ix1 = Nat.pred(ix1);
        let col = Nat.succ(col);
        let lin = String.flatten([chr, lin]);
        Fm.highlight.tc(code.tail, ix0, ix1, col, row, lft, lin, res)
  }
  
Fm.highlight.end(
  col: Nat,
  row: Nat,
  res: List(String),
): String
  String.join("\n", res)

Fm.highlight(
  code: String,
  idx0: Nat,
  idx1: Nat,
): String
  Fm.highlight.tc(code, idx0, idx1, 0, 1, Maybe.none<_>, String.reverse("   1 | "), [])
  
// Reads a term from string
Fm.Term.read(code: String): Maybe(Fm.Term)
  case Fm.Parser.term(0,code) as parsed {
    error: Maybe.none<_>,
    value: Maybe.some<_>(parsed.val),
  }

// Reads a defs from string
Fm.Defs.read(file: String, code: String, defs: Fm.Defs): Either(String, Fm.Defs)
  case Fm.Parser.file(file, defs, 0, code) as parsed {
    error:
      let err = parsed.err;
      let hig = Fm.highlight(code, parsed.idx, Nat.succ(parsed.idx));
      let str = String.flatten([err, "\n", hig]);
      Either.left<_,_>(str),
    value:
      Either.right<_,_>(parsed.val),
  }

// Compilers
// =========

Fm.Comp.data.ctr_args(type: Fm.Term, defs: Fm.Defs): Nat
  case Fm.Term.reduce(type, defs) as type {
    all: Nat.succ(Fm.Comp.data.ctr_args(type.body(Fm.Term.typ, Fm.Term.typ), defs)),
    _: Nat.zero,
  }

Fm.Comp.data.ctrs(type: Fm.Term, defs: Fm.Defs): List(Nat)
  case Fm.Term.reduce(type, defs) as type {
    all: List.cons<_>(
      Fm.Comp.data.ctr_args(type.xtyp, defs),
      Fm.Comp.data.ctrs(type.body(Fm.Term.typ, Fm.Term.typ), defs)),
    _: List.nil<_>,
  }

Fm.Comp.prim_of(type: Fm.Term, defs: Fm.Defs): Maybe(Fm.Prim)
  case Fm.Term.reduce(type, defs) as type {
    all: List.fold<_>(Fm.Comp.prims)<Maybe(Fm.Prim)>(
      case type.self {
        nil: Maybe.none<_>,
        cons: Maybe.some<_>(Fm.Prim.data(Fm.Comp.data.ctrs(type.body(Fm.Term.typ, Fm.Term.typ),defs))),
      },
      (name_prim, cont) case name_prim {
        new: if String.eql(name_prim.fst, type.self)
          then Maybe.some<_>(name_prim.snd)
          else cont
        })
    _: Maybe.none<_>,
  }

// Compiles a term to js
Fm.Comp.compile(
  term: Fm.Term,
  type: Maybe(Fm.Term),
  defs: Fm.Defs,
  ctx: Fm.Context,
): Maybe(Fm.Comp)
  //use skip = Debug.log<_>(String.flatten([
    //"Compile: ",
    //"- ", Fm.Term.show(term), "\n",
    //"- ", Fm.Term.show(Maybe.default<_>(Fm.Term.ref("_"), type)), "\n",
  //]))
  case term {
    ref: do Maybe {
      return Fm.Comp.ref(term.name);
    },
    var: do Maybe {
      return Fm.Comp.var(term.name);
    },
    typ: do Maybe {
      return Fm.Comp.nil;
    },
    all: do Maybe {
      return Fm.Comp.nil;
    },
    lam: case type {
      none:
        Maybe.none<_>,
      some: 
        let typv = Fm.Term.reduce(type.value, defs);
        case typv {
          all: do Maybe {
            let ctx_size = List.length<_>(ctx);
            let self_var = term;
            let body_var = Fm.Term.var(term.name, ctx_size);
            let body_typ = typv.body(self_var, body_var);
            let body_ctx = List.cons<_>({term.name,typv.xtyp}, ctx);
            var body_cmp = Fm.Comp.compile(term.body(body_var), Maybe.some<_>(body_typ), defs, body_ctx);
            let term_cmp = if typv.eras then body_cmp else Fm.Comp.lam(term.name, body_cmp);
            let term_cmp = case Fm.Comp.prim_of(type.value, defs) as prim {
              none: term_cmp,
              some: Fm.Comp.ins(prim.value, term_cmp),
            };
            return term_cmp;
          },
          _: Maybe.none<_>,
        }
      },
    app: 
      do Maybe {
        var func_typ = Fm.Check.value<_>(Fm.Term.check(term.func, Maybe.none<_>, defs, ctx, Maybe.none<_>, Maybe.none<_>));
        let func_typ = Fm.Term.reduce(func_typ, defs);
        case func_typ {
          all: do Maybe {
            var func_cmp = Fm.Comp.compile(term.func, Maybe.none<_>, defs, ctx);
            let func_cmp = case Fm.Comp.prim_of(func_typ, defs) as prim {
              none: func_cmp,
              some: Fm.Comp.eli(prim.value, func_cmp),
            };
            if func_typ.eras then do Maybe {
              return func_cmp;
            } else do Maybe {
              var argm_cmp = Fm.Comp.compile(term.argm, Maybe.some<_>(func_typ.xtyp), defs, ctx);
              return Fm.Comp.app(func_cmp, argm_cmp);
            };
          },
          _: Maybe.none<_>,
        };
      },
    ann:
      Fm.Comp.compile(term.term, Maybe.some<_>(term.type), defs, ctx)
    let:
      let ctx_size = List.length<_>(ctx);
      do Maybe {
        var expr_typ = Fm.Check.value<_>(Fm.Term.check(term.expr, Maybe.none<_>, defs, ctx, Maybe.none<_>, Maybe.none<_>));
        var expr_cmp = Fm.Comp.compile(term.expr, Maybe.none<_>, defs, ctx);
        let new_name = String.flatten([term.name, "_", Nat.show(ctx_size)]);
        let body_var = Fm.Term.var(new_name, ctx_size);
        let body_val = term.body(body_var);
        let body_ctx = List.cons<_>({term.name, expr_typ}, ctx);
        var body_cmp = Fm.Comp.compile(body_val, type, defs, body_ctx);
        return Fm.Comp.let(new_name, expr_cmp, body_cmp);
      },
    def:
      Fm.Comp.compile(term.body(term.expr), type, defs, ctx),
    nat: do Maybe {
      return Fm.Comp.nat(term.natx);
    },
    chr: do Maybe {
      return Fm.Comp.chr(term.chrx);
    },
    str: do Maybe {
      return Fm.Comp.str(term.strx);
    },
    cse:
      Maybe.none<_>,
    gol: do Maybe {
      return Fm.Comp.nil;
    },
    hol: do Maybe {
      return Fm.Comp.nil;
    },
    ori: do Maybe {
      Fm.Comp.compile(term.expr, type, defs, ctx);
    }
  }

Fm.Comp.hs.name(name: Fm.Name): String
  case name {
    nil: "",
    cons:
      let chr =
        if U16.btw('A', name.head, 'Z') then
          U16.add(name.head, Nat.to_u16(32))
        else if U16.eql(name.head, '.') then
          '_'
        else
          name.head
      String.cons(chr, Fm.Comp.hs.name(name.tail)),
  }

// Compile a term to Haskell
Fm.Comp.hs(comp: Fm.Comp): String
  case comp {
    nil: "()",
    var: String.flatten(["_",Fm.Comp.hs.name(comp.name)]),
    ref: String.flatten(["_",Fm.Comp.hs.name(comp.name)]),
    lam: String.flatten(["(\\_", Fm.Comp.hs.name(comp.name), "-> ", Fm.Comp.hs(comp.body), ")"]),
    app: String.flatten(["(app " ,Fm.Comp.hs(comp.func), " ", Fm.Comp.hs(comp.argm), ")"]),
    let: String.flatten(["(let _",Fm.Comp.hs.name(comp.name)," = ",Fm.Comp.hs(comp.expr)," in ",Fm.Comp.hs(comp.body),")"]),
    eli: String.flatten(["(_eli_",Fm.Prim.name(comp.prim)," ",Fm.Comp.hs(comp.expr),")"]),
    ins: String.flatten(["(_ins_",Fm.Prim.name(comp.prim)," ",Fm.Comp.hs(comp.expr),")"]),
    nat: String.flatten(["(",Nat.show(comp.natx),"::Integer)"]),
    chr: String.flatten(["(",Nat.show(Bits.to_nat(Word.to_bits<_>(U16.to_word(comp.chrx)))),"::Word16)"]),
    str: String.flatten([String.cons('"',String.nil), Fm.escape(comp.strx), String.cons('"',String.nil)]),
  }

Fm.Comp.prims: List(Pair(String, Fm.Prim))
  [
    {"Bool.Self", Fm.Prim.bool},
    {"Nat.Self", Fm.Prim.nat},
    {"U16.Self", Fm.Prim.u16},
    {"String.Self", Fm.Prim.string},
  ]
  //{"Bits.Self", Fm.Prim.bits},

Fm.Comp.hs.native_ops: Map(String)
  let pairs = [
    {"Nat.add"    , "_nat_add = \\n m-> (n::Integer) + (m::Integer)"},
    {"Nat.sub"    , "_nat_sub = \\n m-> max ((n::Integer) - (m::Integer)) 0"},
    {"Nat.mul"    , "_nat_mul = \\n m-> (n::Integer) * (m::Integer)"},
    {"Nat.div"    , "_nat_div = \\n m-> div (n::Integer) (m::Integer)"},
    {"Nat.div_mod", "_nat_div_mod = \\n m t-> t (div (n::Integer) (m::Integer)) (mod n m)"},
    {"Nat.pow"    , "_nat_pow = \\n m-> (n::Integer) ^ (m::Integer)"},
    {"Nat.ltn"    , "_nat_ltn = \\n m-> (n::Integer) < (m::Integer)"},
    {"Nat.lte"    , "_nat_lte = \\n m-> (n::Integer) <= (m::Integer)"},
    {"Nat.eql"    , "_nat_eql = \\n m-> (n::Integer) == (m::Integer)"},
    {"Nat.gte"    , "_nat_gte = \\n m-> (n::Integer) >= (m::Integer)"},
    {"Nat.gtn"    , "_nat_gtn = \\n m-> (n::Integer) > (m::Integer)"},
    {"Nat.to_u16" , "_nat_to_u16 = \\n-> (fromInteger (n::Integer)) :: Word16"},
    {"U16.add"    , "_u16_add = \\n m-> (n::Word16) + (m::Word16)"},
    {"U16.sub"    , "_u16_sub = \\n m-> (n::Word16) - (m::Word16)"},
    {"U16.mul"    , "_u16_add = \\n m-> (n::Word16) + (m::Word16)"},
    {"U16.div"    , "_u16_div = \\n m-> div (n::Word16) (m::Word16)"},
    {"U16.mod"    , "_u16_mod = \\n m-> mod (n::Word16) (m::Word16)"},
    {"U16.pow"    , "_u16_pow = \\n m-> (n::Word16) ^ (m::Word16)"},
    {"U16.ltn"    , "_u16_ltn = \\n m-> (n::Word16) < (m::Word16)"},
    {"U16.lte"    , "_u16_lte = \\n m-> (n::Word16) <= (m::Word16)"},
    {"U16.eql"    , "_u16_eql = \\n m-> (n::Word16) == (m::Word16)"},
    {"U16.gte"    , "_u16_gte = \\n m-> (n::Word16) >= (m::Word16)"},
    {"U16.gtn"    , "_u16_gtn = \\n m-> (n::Word16) > (m::Word16)"},
  ];
  //{"Bits.concat", "_bits_concat = \\a b-> let len = integerLog2# a in orInteger (shiftLInteger b len) (a - bitInteger len)"},
  //{"Bits.eql"   , "_bits_eql = \\a b t f-> if a == b then t else f"},
  let map = Map.new<_>;
  for pair in pairs with map:
    case pair {
      new: Fm.set<_>(pair.fst, pair.snd, map)
    }

Fm.Prim.name(prim: Fm.Prim): String
  case prim {
    bool: "bool",
    nat: "nat",
    u16: "u16",
    string: "string",
    data: "data",
  }

Fm.Prim.ctrs(prim: Fm.Prim): List(Nat)
  case prim {
    bool: [0, 0],
    nat: [0, 2],
    u16: [1],
    string: [0, 2],
    data: prim.ctrs,
  }

// Compile defs to Haskell
Fm.Comp.hs.defs(defs: Fm.Defs): String
  //"{-# LANGUAGE MagicHash #-}",
  //"import GHC.Integer.Logarithms",
  //"import GHC.Integer",
  //"_ins_bits = \\x-> x (1::Integer) (\\p-> shiftLInteger p 1#) (\\p-> orInteger 1 (shiftLInteger p 1#))",
  //"_eli_bits = \\x-> \\e o i-> if x == 1 then e else if testBitInteger x 0# then i (shiftRInteger x 1#) else o (shiftRInteger x 1#)",
  let list = Map.values<_>(defs);
  let code = String.join("\n", [
    "import Unsafe.Coerce",
    "import Data.Word",
    "import Data.Bits",
    "app = unsafeCoerce",
    "_ins_bool = \\x-> x True False",
    "_eli_bool = \\x-> case x of { True -> (\\t-> \\f-> t); False -> (\\t-> \\f-> f); }",
    "_ins_nat = \\x-> (x 0 (\\p-> 1 + p)) :: Integer",
    "_eli_nat = \\x-> \\z-> \\s-> if x == 0 then z else (app s (x - 1))",
    "_ins_string = \\x-> x [] (\\h t-> (toEnum (fromIntegral h) :: Char) : t)",
    "_eli_string = \\x-> case x::String of { []-> \\n e-> n; (c:cs)-> \\n e-> e(fromIntegral(fromEnum c) :: Word16)cs }",
    "_ins_u16 = \\x-> x (\\x -> (go 0 0 x)::Word16) where go i u x = if i<16 then x u (\\x-> app go (i + 1) u x) (\\x-> app go (i+1) (u.|.(shiftL 1 i)) x) else u",
    "_eli_u16 = \\x-> (\\t -> t (go 0 (\\n o i-> n) (x::Word16))) where go i w x = if i<16 then go (i+1) (if (shiftR x (16-i-1).&.1)>0 then \\n o i-> app i w else \\n o i-> app o w) x else w",
    "",
  ]);
  for defn in list with code:
    case defn {
      new: 
        let name = defn.name;
        let line = case Fm.get<_>(name, Fm.Comp.hs.native_ops) as got {
          none: 
            let comp = Fm.Comp.compile(defn.term, Maybe.some<_>(defn.type), defs, []);
            let body = case comp {none: "()", some: Fm.Comp.hs(comp.value)};
            String.flatten(["_",Fm.Comp.hs.name(name)," = ",body]),
          some:
            got.value,
        };
        String.flatten([code, line, "\n"])
    }

// Reports
// =======

Fm.Defs.report.get_file_code(file: String, files: List(Fm.File)): String
  case files {
    nil: "",
    cons: case files.head {
      new:
        if String.eql(files.head.name, file) then
          files.head.code
        else
          Fm.Defs.report.get_file_code(file, files.tail)
    }
  }

// REPORT: Synths, checks and reports errors of a defs
Fm.Defs.report(files: List(Fm.File), defs: Fm.Defs): String
  let errors = "";
  let errors = for defn in Map.values<_>(defs):
    case defn {
      new: case defn.stat {
        init: errors,
        wait: errors,
        done: errors,
        fail: case defn.stat.errors {
          nil:
            errors,
          cons: 
            let name_str = Fm.Name.show(defn.name);
            let relevant_errors = Fm.Error.relevant(defn.stat.errors, Bool.false);
            for error in relevant_errors with errors:
              String.flatten([
                errors,
                "On ", name_str, ":\n",
                Fm.Error.show(error, defs),
                case Fm.Error.origin(error) as origin {
                  none: "",
                  some: case origin.value {
                    new:
                      let code = Fm.Defs.report.get_file_code(defn.file, files);
                      let code = Fm.highlight(code, origin.value.from, origin.value.upto);
                      String.flatten(["On code:\n", code, "\n"])
                  },
                },
                "\n",
              ])
        }
      }
    };
  let types = "";
  let types = for defn in Map.values<_>(defs):
    case defn {
      new: case defn.stat {
        init: types,
        wait: types,
        done: String.flatten([types, defn.name, ": ", Fm.Term.show(defn.type), "\n"]),
        fail: types,
      }
    };
  case errors {
    cons: errors,
    nil: String.flatten([types, "\nAll terms check."]),
  }

// FormCore
// ========

Fm.Term.core(term: Fm.Term): String
  case term {
    ref:
      Fm.Name.show(term.name),
    var:
      Fm.Name.show(term.name),
    typ:
      "*",
    all:
      let eras = term.eras;
      let init = if eras then "%" else "@"
      let self = Fm.Name.show(term.self);
      let name = Fm.Name.show(term.name);
      let xtyp = Fm.Term.core(term.xtyp);
      let body = Fm.Term.core(term.body(Fm.Term.var(term.self,0),Fm.Term.var(term.name,0)));
      String.flatten([init,self,"(",name,":",xtyp,") ",body]),
    lam:
      let name = Fm.Name.show(term.name);
      let body = Fm.Term.core(term.body(Fm.Term.var(term.name,0)));
      String.flatten(["#",name," ",body]),
    app:
      let func = Fm.Term.core(term.func);
      let argm = Fm.Term.core(term.argm);
      String.flatten(["(",func," ",argm,")"]),
    let:
      let name = Fm.Name.show(term.name);
      let expr = Fm.Term.core(term.expr);
      let body = Fm.Term.core(term.body(Fm.Term.var(term.name,0)));
      String.flatten(["!", name, " = ", expr, "; ", body]),
    def:
      let name = Fm.Name.show(term.name);
      let expr = Fm.Term.core(term.expr);
      let body = Fm.Term.core(term.body(Fm.Term.var(term.name,0)));
      String.flatten(["$", name, " = ", expr, "; ", body]),
    ann:
      let term = Fm.Term.core(term.term);
      let type = Fm.Term.core(term.type);
      String.flatten(["{",term,":",type,"}"]),
    gol:
      "<GOL>",
    hol:
      "<HOL>",
    nat:
      String.flatten(["+", Nat.show(term.natx)]),
    chr:
      String.flatten(["'", Fm.escape.char(term.chrx), "'"]),
    str:
      String.flatten(["\"", Fm.escape(term.strx), "\""]),
    cse:
      "<CSE>",
    ori:
      Fm.Term.core(term.expr),
  }


// Converts everything to FormCore
Fm.Defs.core(defs: Fm.Defs): String
  let result = "";
  for defn in Map.values<_>(defs) with result:
    case defn {
      new: 
        case defn.stat {
          done:
            let name = defn.name;
            let term = Fm.Term.core(defn.term);
            let type = Fm.Term.core(defn.type);
            String.flatten([result, name, " : ", type, " = ", term, ";\n"]),
          wait: result,
          init: result,
          fail: result,
      }
    }

// API
// ===

type Fm.File {
  new(name: String, code: String)
}

Fm.exec(files: List(Fm.File), report: Fm.Defs -> String): String
  let reads = Pair.new<String,Fm.Defs>("", Map.new<_>);
  let reads = for file in files:
    case reads {
      new: case file {
        new: case reads {
          new: case Fm.Defs.read(file.name, file.code, reads.snd) as parsed {
            left: Pair.new<String,Fm.Defs>(String.flatten([reads.fst,"On ",file.name,":\n",parsed.value,"\n"]), reads.snd),
            right: Pair.new<String,Fm.Defs>(reads.fst, parsed.value),
          }
        }
      }
    };
  case reads {
    new:
      let errs = reads.fst;
      let defs = reads.snd;
      case errs {
        nil : report(defs),
        cons: errs,
      }
  }

Fm.to_core_one(files: List(Fm.File), name: String): String
  Fm.exec(files, (defs) Fm.Defs.core(Fm.Synth.one(name,defs)))

Fm.to_core_file(files: List(Fm.File), file: String): String
  Fm.exec(files, (defs) Fm.Defs.core(Fm.Synth.file(file,defs)))

Fm.to_core_all(files: List(Fm.File)): String
  Fm.exec(files, (defs) Fm.Defs.core(Fm.Synth.all(defs)))

Fm.check_all(files: List(Fm.File)): String
  Fm.exec(files, (defs) Fm.Defs.report(files, Fm.Synth.all(defs)))

Fm.check_file(files: List(Fm.File), file: String): String
  Fm.exec(files, (defs) Fm.Defs.report(files, Fm.Synth.file(file,defs)))

Fm.check_one(files: List(Fm.File), name: String): String
  Fm.exec(files, (defs) Fm.Defs.report(files, Fm.Synth.one(name,defs)))

Fm.exports: Unit
  let _ = Fm.to_core_all;
  let _ = Fm.to_core_file;
  let _ = Fm.to_core_one;
  let _ = Fm.check_all;
  let _ = Fm.check_file;
  let _ = Fm.check_one;
  Unit.new

Fm: IO(Unit)
  do IO {
    let file = "Pair.fm";
    var code = IO.get_file(file);
    let files = [Fm.File.new(file, code)];
    IO.print(Fm.check_all(files));
  }
